var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    init_react();
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty2.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty2.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement7(type, config2, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            self2 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              key = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext3(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef3(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render.displayName == null) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare3) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare3 === void 0 ? null : compare3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type.displayName == null) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext4(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState4(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init2);
        }
        function useRef5(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback5(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement7.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            new Map([[frozenObject, null]]);
            new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext3;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef3;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback5;
        exports.useContext = useContext4;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect4;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect4;
        exports.useMemo = useMemo4;
        exports.useReducer = useReducer;
        exports.useRef = useRef5;
        exports.useState = useState4;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/@remix-run/dev/compiler/shims/react.ts
var React;
var init_react = __esm({
  "node_modules/@remix-run/dev/compiler/shims/react.ts"() {
    React = __toModule(require_react());
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    init_react();
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValue = parts.shift().split("=");
      var name = nameValue.shift();
      var value = nameValue.join("=");
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse;
    module.exports.parse = parse;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports, module) {
    init_react();
    "use strict";
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty2.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach2 = (array, callback) => {
      const length = array.length;
      let index = -1;
      while (++index < length) {
        callback(array[index]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase)
        return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString3 = object.toString;
    var isArray3 = Array.isArray;
    var isBuffer2 = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject2 = (value) => {
      return toString3.call(value) == "[object Object]";
    };
    var isString2 = (value) => {
      return typeof value == "string" || toString3.call(value) == "[object String]";
    };
    var isNumber2 = (value) => {
      return typeof value == "number" || toString3.call(value) == "[object Number]";
    };
    var isFunction2 = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString3.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString3.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc2 = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json2 = options && options.json;
      if (json2) {
        defaults.quotes = "double";
        defaults.wrap = true;
      }
      options = extend(defaults, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json2 && argument && isFunction2(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString2(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isBuffer2(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isArray3(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach2(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent) + jsesc2(value, options));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json2) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json2) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent) + jsesc2(key, options) + ":" + (compact ? "" : " ") + jsesc2(value, options));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {
        if (pair) {
          if (options.minimal)
            return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json2 && !regexDigit.test(string.charAt(index + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json2 || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc2.version = "3.0.2";
    module.exports = jsesc2;
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    init_react();
    "use strict";
    EventHandlers.prototype = Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    EventEmitter.prototype.once = function once(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type];
      if (typeof listeners2 === "function") {
        this.removeListener(type, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance, performanceNow, startTime, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_react();
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_default = browser$1;
  }
});

// ../../node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "../../node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_react();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_react();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    init_react();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// ../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_react();
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry2 = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry2;
      else
        this.head = entry2;
      this.tail = entry2;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry2 = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry2;
      this.head = entry2;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_react();
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// ../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    init_react();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    "use strict";
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// ../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry2;
    var count = 0;
    while (entry2) {
      buffer[count] = entry2;
      entry2 = entry2.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry2) {
      var chunk = entry2.chunk;
      var encoding = entry2.encoding;
      var cb = entry2.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry2 = entry2.next;
      if (state.writing) {
        break;
      }
    }
    if (entry2 === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry2;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry2 = _this.entry;
    _this.entry = null;
    while (entry2) {
      var cb = entry2.callback;
      state.pendingcb--;
      cb(err);
      entry2 = entry2.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_react();
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// ../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_react();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// ../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_react();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// ../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "../../node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_react();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_react();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_react();
    var polyfill = (init_stream(), stream_exports);
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    init_react();
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React6 = require_react();
        var _assign = require_object_assign();
        var stream = require_stream();
        var ReactVersion = "17.0.2";
        function formatProdErrorMessage(code) {
          var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;
          for (var i2 = 1; i2 < arguments.length; i2++) {
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
          }
          return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var enableSuspenseServerRenderer = false;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutInvalidateContextType = new Set();
        }
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function maskContext(type, context) {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        }
        function checkContextTypes(typeSpecs, values, location) {
          {
            checkPropTypes(typeSpecs, values, location, "Component");
          }
        }
        function validateContextBounds(context, threadID) {
          for (var i2 = context._threadCount | 0; i2 <= threadID; i2++) {
            context[i2] = context._currentValue2;
            context._threadCount = i2 + 1;
          }
        }
        function processContext(type, context, threadID, isClass) {
          if (isClass) {
            var contextType = type.contextType;
            {
              if ("contextType" in type) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
                  didWarnAboutInvalidateContextType.add(type);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              validateContextBounds(contextType, threadID);
              return contextType[threadID];
            }
            {
              var maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, maskedContext, "context");
                }
              }
              return maskedContext;
            }
          } else {
            {
              var _maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, _maskedContext, "context");
                }
              }
              return _maskedContext;
            }
          }
        }
        var nextAvailableThreadIDs = new Uint16Array(16);
        for (var i = 0; i < 15; i++) {
          nextAvailableThreadIDs[i] = i + 1;
        }
        nextAvailableThreadIDs[15] = 0;
        function growThreadCountAndReturnNextAvailable() {
          var oldArray = nextAvailableThreadIDs;
          var oldSize = oldArray.length;
          var newSize = oldSize * 2;
          if (!(newSize <= 65536)) {
            {
              throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
            }
          }
          var newArray = new Uint16Array(newSize);
          newArray.set(oldArray);
          nextAvailableThreadIDs = newArray;
          nextAvailableThreadIDs[0] = oldSize + 1;
          for (var _i = oldSize; _i < newSize - 1; _i++) {
            nextAvailableThreadIDs[_i] = _i + 1;
          }
          nextAvailableThreadIDs[newSize - 1] = 0;
          return oldSize;
        }
        function allocThreadID() {
          var nextID = nextAvailableThreadIDs[0];
          if (nextID === 0) {
            return growThreadCountAndReturnNextAvailable();
          }
          nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
          return nextID;
        }
        function freeThreadID(id) {
          nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
          nextAvailableThreadIDs[0] = id;
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index;
          var lastIndex = 0;
          for (index = match.index; index < str.length; index++) {
            switch (str.charCodeAt(index)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index) {
              html += str.substring(lastIndex, index);
            }
            lastIndex = index + 1;
            html += escape;
          }
          return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        function quoteAttributeValueForBrowser(value) {
          return '"' + escapeTextForBrowser(value) + '"';
        }
        function createMarkupForRoot() {
          return ROOT_ATTRIBUTE_NAME + '=""';
        }
        function createMarkupForProperty(name, value) {
          var propertyInfo = getPropertyInfo(name);
          if (name !== "style" && shouldIgnoreAttribute(name, propertyInfo, false)) {
            return "";
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
            return "";
          }
          if (propertyInfo !== null) {
            var attributeName = propertyInfo.attributeName;
            var type = propertyInfo.type;
            if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
              return attributeName + '=""';
            } else {
              if (propertyInfo.sanitizeURL) {
                value = "" + value;
                sanitizeURL(value);
              }
              return attributeName + "=" + quoteAttributeValueForBrowser(value);
            }
          } else if (isAttributeNameSafe(name)) {
            return name + "=" + quoteAttributeValueForBrowser(value);
          }
          return "";
        }
        function createMarkupForCustomAttribute(name, value) {
          if (!isAttributeNameSafe(name) || value == null) {
            return "";
          }
          return name + "=" + quoteAttributeValueForBrowser(value);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (!(currentlyRenderingComponent !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
            if (objectIs(nextDeps[i2], prevDeps[i2])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            {
              {
                throw Error("Rendered more hooks than during the previous render");
              }
            }
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          {
            isInHookUserCodeInDev = false;
          }
        }
        function finishHooks(Component, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext(context, observedBits) {
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return context[threadID];
        }
        function useContext4(context, observedBits) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          return context[threadID];
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState4(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(basicStateReducer, initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init2 !== void 0 ? init2(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo4(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef5(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect4(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
            {
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback5(callback, deps) {
          return useMemo4(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function useTransition2() {
          resolveCurrentlyRenderingComponent();
          var startTransition = function(callback) {
            callback();
          };
          return [startTransition, false];
        }
        function useOpaqueIdentifier() {
          return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
        }
        function noop2() {
        }
        var currentPartialRenderer = null;
        function setCurrentPartialRenderer(renderer) {
          currentPartialRenderer = renderer;
        }
        var Dispatcher = {
          readContext,
          useContext: useContext4,
          useMemo: useMemo4,
          useReducer,
          useRef: useRef5,
          useState: useState4,
          useLayoutEffect: useLayoutEffect4,
          useCallback: useCallback5,
          useImperativeHandle: noop2,
          useEffect: noop2,
          useDebugValue: noop2,
          useDeferredValue,
          useTransition: useTransition2,
          useOpaqueIdentifier,
          useMutableSource
        };
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var ariaProperties = {
          "aria-current": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var toArray = React6.Children.toArray;
        var currentDebugStacks = [];
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1;
        var prevGetCurrentStackImpl = null;
        var getCurrentServerStackImpl = function() {
          return "";
        };
        var describeStackFrame = function(element) {
          return "";
        };
        var validatePropertiesInDevelopment = function(type, props) {
        };
        var pushCurrentDebugStack = function(stack) {
        };
        var pushElementToDebugStack = function(element) {
        };
        var popCurrentDebugStack = function() {
        };
        var hasWarnedAboutUsingContextAsConsumer = false;
        {
          ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
          };
          describeStackFrame = function(element) {
            return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
          };
          pushCurrentDebugStack = function(stack) {
            currentDebugStacks.push(stack);
            if (currentDebugStacks.length === 1) {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
            }
          };
          pushElementToDebugStack = function(element) {
            var stack = currentDebugStacks[currentDebugStacks.length - 1];
            var frame = stack[stack.length - 1];
            frame.debugElementStack.push(element);
          };
          popCurrentDebugStack = function() {
            currentDebugStacks.pop();
            if (currentDebugStacks.length === 0) {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              prevGetCurrentStackImpl = null;
            }
          };
          getCurrentServerStackImpl = function() {
            if (currentDebugStacks.length === 0) {
              return "";
            }
            var frames = currentDebugStacks[currentDebugStacks.length - 1];
            var stack = "";
            for (var i2 = frames.length - 1; i2 >= 0; i2--) {
              var frame = frames[i2];
              var debugElementStack = frame.debugElementStack;
              for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
                stack += describeStackFrame(debugElementStack[ii]);
              }
            }
            return stack;
          };
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUndefinedDerivedState = {};
        var didWarnAboutUninitializedState = {};
        var valuePropNames = ["value", "defaultValue"];
        var newlineEatingTags = {
          listing: true,
          pre: true,
          textarea: true
        };
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        function validateDangerousTag(tag) {
          if (!validatedTagCache.hasOwnProperty(tag)) {
            if (!VALID_TAG_REGEX.test(tag)) {
              {
                throw Error("Invalid tag: " + tag);
              }
            }
            validatedTagCache[tag] = true;
          }
        }
        var styleNameCache = {};
        var processStyleName = function(styleName) {
          if (styleNameCache.hasOwnProperty(styleName)) {
            return styleNameCache[styleName];
          }
          var result = hyphenateStyleName(styleName);
          styleNameCache[styleName] = result;
          return result;
        };
        function createMarkupForStyles(styles) {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            var styleValue = styles[styleName];
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styleValue);
              }
            }
            if (styleValue != null) {
              serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentName(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        function shouldConstruct$1(Component) {
          return Component.prototype && Component.prototype.isReactComponent;
        }
        function getNonChildrenInnerMarkup(props) {
          var innerHTML = props.dangerouslySetInnerHTML;
          if (innerHTML != null) {
            if (innerHTML.__html != null) {
              return innerHTML.__html;
            }
          } else {
            var content = props.children;
            if (typeof content === "string" || typeof content === "number") {
              return escapeTextForBrowser(content);
            }
          }
          return null;
        }
        function flattenTopLevelChildren(children) {
          if (!React6.isValidElement(children)) {
            return toArray(children);
          }
          var element = children;
          if (element.type !== REACT_FRAGMENT_TYPE) {
            return [element];
          }
          var fragmentChildren = element.props.children;
          if (!React6.isValidElement(fragmentChildren)) {
            return toArray(fragmentChildren);
          }
          var fragmentChildElement = fragmentChildren;
          return [fragmentChildElement];
        }
        function flattenOptionChildren(children) {
          if (children === void 0 || children === null) {
            return children;
          }
          var content = "";
          React6.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Only strings and numbers are supported as <option> children.");
              }
            }
          });
          return content;
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var STYLE = "style";
        var RESERVED_PROPS = {
          children: null,
          dangerouslySetInnerHTML: null,
          suppressContentEditableWarning: null,
          suppressHydrationWarning: null
        };
        function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
          var ret = "<" + tagVerbatim;
          var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
          for (var propKey in props) {
            if (!hasOwnProperty$2.call(props, propKey)) {
              continue;
            }
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            if (propKey === STYLE) {
              propValue = createMarkupForStyles(propValue);
            }
            var markup = null;
            if (isCustomComponent$1) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += " " + markup;
            }
          }
          if (makeStaticMarkup) {
            return ret;
          }
          if (isRootElement) {
            ret += " " + createMarkupForRoot();
          }
          return ret;
        }
        function validateRenderResult(child, type) {
          if (child === void 0) {
            {
              {
                throw Error((getComponentName(type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
              }
            }
          }
        }
        function resolve(child, context, threadID) {
          while (React6.isValidElement(child)) {
            var element = child;
            var Component = element.type;
            {
              pushElementToDebugStack(element);
            }
            if (typeof Component !== "function") {
              break;
            }
            processChild(element, Component);
          }
          function processChild(element2, Component2) {
            var isClass = shouldConstruct$1(Component2);
            var publicContext = processContext(Component2, context, threadID, isClass);
            var queue2 = [];
            var replace = false;
            var updater = {
              isMounted: function(publicInstance) {
                return false;
              },
              enqueueForceUpdate: function(publicInstance) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "forceUpdate");
                  return null;
                }
              },
              enqueueReplaceState: function(publicInstance, completeState) {
                replace = true;
                queue2 = [completeState];
              },
              enqueueSetState: function(publicInstance, currentPartialState) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "setState");
                  return null;
                }
                queue2.push(currentPartialState);
              }
            };
            var inst;
            if (isClass) {
              inst = new Component2(element2.props, publicContext, updater);
              if (typeof Component2.getDerivedStateFromProps === "function") {
                {
                  if (inst.state === null || inst.state === void 0) {
                    var componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUninitializedState[componentName]) {
                      error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName);
                      didWarnAboutUninitializedState[componentName] = true;
                    }
                  }
                }
                var partialState = Component2.getDerivedStateFromProps.call(null, element2.props, inst.state);
                {
                  if (partialState === void 0) {
                    var _componentName = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                      error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName);
                      didWarnAboutUndefinedDerivedState[_componentName] = true;
                    }
                  }
                }
                if (partialState != null) {
                  inst.state = _assign({}, inst.state, partialState);
                }
              }
            } else {
              {
                if (Component2.prototype && typeof Component2.prototype.render === "function") {
                  var _componentName2 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutBadClass[_componentName2]) {
                    error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2);
                    didWarnAboutBadClass[_componentName2] = true;
                  }
                }
              }
              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              inst = Component2(element2.props, publicContext, updater);
              inst = finishHooks(Component2, element2.props, inst, publicContext);
              {
                if (inst != null && inst.render != null) {
                  var _componentName3 = getComponentName(Component2) || "Unknown";
                  if (!didWarnAboutModulePatternComponent[_componentName3]) {
                    error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3);
                    didWarnAboutModulePatternComponent[_componentName3] = true;
                  }
                }
              }
              if (inst == null || inst.render == null) {
                child = inst;
                validateRenderResult(child, Component2);
                return;
              }
            }
            inst.props = element2.props;
            inst.context = publicContext;
            inst.updater = updater;
            var initialState = inst.state;
            if (initialState === void 0) {
              inst.state = initialState = null;
            }
            if (typeof inst.UNSAFE_componentWillMount === "function" || typeof inst.componentWillMount === "function") {
              if (typeof inst.componentWillMount === "function") {
                {
                  if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                    var _componentName4 = getComponentName(Component2) || "Unknown";
                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                      warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", _componentName4);
                      didWarnAboutDeprecatedWillMount[_componentName4] = true;
                    }
                  }
                }
                if (typeof Component2.getDerivedStateFromProps !== "function") {
                  inst.componentWillMount();
                }
              }
              if (typeof inst.UNSAFE_componentWillMount === "function" && typeof Component2.getDerivedStateFromProps !== "function") {
                inst.UNSAFE_componentWillMount();
              }
              if (queue2.length) {
                var oldQueue = queue2;
                var oldReplace = replace;
                queue2 = null;
                replace = false;
                if (oldReplace && oldQueue.length === 1) {
                  inst.state = oldQueue[0];
                } else {
                  var nextState = oldReplace ? oldQueue[0] : inst.state;
                  var dontMutate = true;
                  for (var i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2];
                    var _partialState = typeof partial === "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                    if (_partialState != null) {
                      if (dontMutate) {
                        dontMutate = false;
                        nextState = _assign({}, nextState, _partialState);
                      } else {
                        _assign(nextState, _partialState);
                      }
                    }
                  }
                  inst.state = nextState;
                }
              } else {
                queue2 = null;
              }
            }
            child = inst.render();
            {
              if (child === void 0 && inst.render._isMockFunction) {
                child = null;
              }
            }
            validateRenderResult(child, Component2);
            var childContext;
            {
              if (typeof inst.getChildContext === "function") {
                var _childContextTypes = Component2.childContextTypes;
                if (typeof _childContextTypes === "object") {
                  childContext = inst.getChildContext();
                  for (var contextKey in childContext) {
                    if (!(contextKey in _childContextTypes)) {
                      {
                        throw Error((getComponentName(Component2) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                      }
                    }
                  }
                } else {
                  {
                    error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component2) || "Unknown");
                  }
                }
              }
              if (childContext) {
                context = _assign({}, context, childContext);
              }
            }
          }
          return {
            child,
            context
          };
        }
        var ReactDOMServerRenderer = /* @__PURE__ */ function() {
          function ReactDOMServerRenderer2(children, makeStaticMarkup, options) {
            var flatChildren = flattenTopLevelChildren(children);
            var topFrame = {
              type: null,
              domNamespace: Namespaces.html,
              children: flatChildren,
              childIndex: 0,
              context: emptyObject,
              footer: ""
            };
            {
              topFrame.debugElementStack = [];
            }
            this.threadID = allocThreadID();
            this.stack = [topFrame];
            this.exhausted = false;
            this.currentSelectValue = null;
            this.previousWasTextNode = false;
            this.makeStaticMarkup = makeStaticMarkup;
            this.suspenseDepth = 0;
            this.contextIndex = -1;
            this.contextStack = [];
            this.contextValueStack = [];
            this.uniqueID = 0;
            this.identifierPrefix = options && options.identifierPrefix || "";
            {
              this.contextProviderStack = [];
            }
          }
          var _proto = ReactDOMServerRenderer2.prototype;
          _proto.destroy = function destroy() {
            if (!this.exhausted) {
              this.exhausted = true;
              this.clearProviders();
              freeThreadID(this.threadID);
            }
          };
          _proto.pushProvider = function pushProvider(provider) {
            var index = ++this.contextIndex;
            var context = provider.type._context;
            var threadID = this.threadID;
            validateContextBounds(context, threadID);
            var previousValue = context[threadID];
            this.contextStack[index] = context;
            this.contextValueStack[index] = previousValue;
            {
              this.contextProviderStack[index] = provider;
            }
            context[threadID] = provider.props.value;
          };
          _proto.popProvider = function popProvider(provider) {
            var index = this.contextIndex;
            {
              if (index < 0 || provider !== this.contextProviderStack[index]) {
                error("Unexpected pop.");
              }
            }
            var context = this.contextStack[index];
            var previousValue = this.contextValueStack[index];
            this.contextStack[index] = null;
            this.contextValueStack[index] = null;
            {
              this.contextProviderStack[index] = null;
            }
            this.contextIndex--;
            context[this.threadID] = previousValue;
          };
          _proto.clearProviders = function clearProviders() {
            for (var index = this.contextIndex; index >= 0; index--) {
              var context = this.contextStack[index];
              var previousValue = this.contextValueStack[index];
              context[this.threadID] = previousValue;
            }
          };
          _proto.read = function read2(bytes) {
            if (this.exhausted) {
              return null;
            }
            var prevPartialRenderer = currentPartialRenderer;
            setCurrentPartialRenderer(this);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            try {
              var out = [""];
              var suspended = false;
              while (out[0].length < bytes) {
                if (this.stack.length === 0) {
                  this.exhausted = true;
                  freeThreadID(this.threadID);
                  break;
                }
                var frame = this.stack[this.stack.length - 1];
                if (suspended || frame.childIndex >= frame.children.length) {
                  var footer = frame.footer;
                  if (footer !== "") {
                    this.previousWasTextNode = false;
                  }
                  this.stack.pop();
                  if (frame.type === "select") {
                    this.currentSelectValue = null;
                  } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                    var provider = frame.type;
                    this.popProvider(provider);
                  } else if (frame.type === REACT_SUSPENSE_TYPE) {
                    this.suspenseDepth--;
                    var buffered = out.pop();
                    if (suspended) {
                      suspended = false;
                      var fallbackFrame = frame.fallbackFrame;
                      if (!fallbackFrame) {
                        {
                          throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                        }
                      }
                      this.stack.push(fallbackFrame);
                      out[this.suspenseDepth] += "<!--$!-->";
                      continue;
                    } else {
                      out[this.suspenseDepth] += buffered;
                    }
                  }
                  out[this.suspenseDepth] += footer;
                  continue;
                }
                var child = frame.children[frame.childIndex++];
                var outBuffer = "";
                if (true) {
                  pushCurrentDebugStack(this.stack);
                  frame.debugElementStack.length = 0;
                }
                try {
                  outBuffer += this.render(child, frame.context, frame.domNamespace);
                } catch (err) {
                  if (err != null && typeof err.then === "function") {
                    if (enableSuspenseServerRenderer) {
                      if (!(this.suspenseDepth > 0)) {
                        {
                          throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                        }
                      }
                      suspended = true;
                    } else {
                      if (true) {
                        {
                          throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                        }
                      }
                    }
                  } else {
                    throw err;
                  }
                } finally {
                  if (true) {
                    popCurrentDebugStack();
                  }
                }
                if (out.length <= this.suspenseDepth) {
                  out.push("");
                }
                out[this.suspenseDepth] += outBuffer;
              }
              return out[0];
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
              setCurrentPartialRenderer(prevPartialRenderer);
              resetHooksState();
            }
          };
          _proto.render = function render(child, context, parentNamespace) {
            if (typeof child === "string" || typeof child === "number") {
              var text = "" + child;
              if (text === "") {
                return "";
              }
              if (this.makeStaticMarkup) {
                return escapeTextForBrowser(text);
              }
              if (this.previousWasTextNode) {
                return "<!-- -->" + escapeTextForBrowser(text);
              }
              this.previousWasTextNode = true;
              return escapeTextForBrowser(text);
            } else {
              var nextChild;
              var _resolve = resolve(child, context, this.threadID);
              nextChild = _resolve.child;
              context = _resolve.context;
              if (nextChild === null || nextChild === false) {
                return "";
              } else if (!React6.isValidElement(nextChild)) {
                if (nextChild != null && nextChild.$$typeof != null) {
                  var $$typeof = nextChild.$$typeof;
                  if (!($$typeof !== REACT_PORTAL_TYPE)) {
                    {
                      throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                    }
                  }
                  {
                    {
                      throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                    }
                  }
                }
                var nextChildren = toArray(nextChild);
                var frame = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                {
                  frame.debugElementStack = [];
                }
                this.stack.push(frame);
                return "";
              }
              var nextElement = nextChild;
              var elementType = nextElement.type;
              if (typeof elementType === "string") {
                return this.renderDOM(nextElement, context, parentNamespace);
              }
              switch (elementType) {
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_FRAGMENT_TYPE: {
                  var _nextChildren = toArray(nextChild.props.children);
                  var _frame = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  {
                    _frame.debugElementStack = [];
                  }
                  this.stack.push(_frame);
                  return "";
                }
                case REACT_SUSPENSE_TYPE: {
                  {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support Suspense.");
                      }
                    }
                  }
                }
                case REACT_SCOPE_TYPE: {
                  {
                    {
                      throw Error("ReactDOMServer does not yet support scope components.");
                    }
                  }
                }
              }
              if (typeof elementType === "object" && elementType !== null) {
                switch (elementType.$$typeof) {
                  case REACT_FORWARD_REF_TYPE: {
                    var element = nextChild;
                    var _nextChildren5;
                    var componentIdentity = {};
                    prepareToUseHooks(componentIdentity);
                    _nextChildren5 = elementType.render(element.props, element.ref);
                    _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                    _nextChildren5 = toArray(_nextChildren5);
                    var _frame5 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren5,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame5.debugElementStack = [];
                    }
                    this.stack.push(_frame5);
                    return "";
                  }
                  case REACT_MEMO_TYPE: {
                    var _element = nextChild;
                    var _nextChildren6 = [React6.createElement(elementType.type, _assign({
                      ref: _element.ref
                    }, _element.props))];
                    var _frame6 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren6,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame6.debugElementStack = [];
                    }
                    this.stack.push(_frame6);
                    return "";
                  }
                  case REACT_PROVIDER_TYPE: {
                    var provider = nextChild;
                    var nextProps = provider.props;
                    var _nextChildren7 = toArray(nextProps.children);
                    var _frame7 = {
                      type: provider,
                      domNamespace: parentNamespace,
                      children: _nextChildren7,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame7.debugElementStack = [];
                    }
                    this.pushProvider(provider);
                    this.stack.push(_frame7);
                    return "";
                  }
                  case REACT_CONTEXT_TYPE: {
                    var reactContext = nextChild.type;
                    {
                      if (reactContext._context === void 0) {
                        if (reactContext !== reactContext.Consumer) {
                          if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                          }
                        }
                      } else {
                        reactContext = reactContext._context;
                      }
                    }
                    var _nextProps = nextChild.props;
                    var threadID = this.threadID;
                    validateContextBounds(reactContext, threadID);
                    var nextValue = reactContext[threadID];
                    var _nextChildren8 = toArray(_nextProps.children(nextValue));
                    var _frame8 = {
                      type: nextChild,
                      domNamespace: parentNamespace,
                      children: _nextChildren8,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame8.debugElementStack = [];
                    }
                    this.stack.push(_frame8);
                    return "";
                  }
                  case REACT_FUNDAMENTAL_TYPE: {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support the fundamental API.");
                      }
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var _element2 = nextChild;
                    var lazyComponent = nextChild.type;
                    var payload = lazyComponent._payload;
                    var init2 = lazyComponent._init;
                    var result = init2(payload);
                    var _nextChildren10 = [React6.createElement(result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame10 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren10,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame10.debugElementStack = [];
                    }
                    this.stack.push(_frame10);
                    return "";
                  }
                }
              }
              var info = "";
              {
                var owner = nextElement._owner;
                if (elementType === void 0 || typeof elementType === "object" && elementType !== null && Object.keys(elementType).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentName(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              {
                {
                  throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                }
              }
            }
          };
          _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
            var tag = element.type.toLowerCase();
            var namespace = parentNamespace;
            if (parentNamespace === Namespaces.html) {
              namespace = getIntrinsicNamespace(tag);
            }
            {
              if (namespace === Namespaces.html) {
                if (tag !== element.type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type);
                }
              }
            }
            validateDangerousTag(tag);
            var props = element.props;
            if (tag === "input") {
              {
                checkControlledValueProps("input", props);
                if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                  error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultChecked = true;
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                  error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultInputValue = true;
                }
              }
              props = _assign({
                type: void 0
              }, props, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: props.value != null ? props.value : props.defaultValue,
                checked: props.checked != null ? props.checked : props.defaultChecked
              });
            } else if (tag === "textarea") {
              {
                checkControlledValueProps("textarea", props);
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                  error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultTextareaValue = true;
                }
              }
              var initialValue = props.value;
              if (initialValue == null) {
                var defaultValue = props.defaultValue;
                var textareaChildren = props.children;
                if (textareaChildren != null) {
                  {
                    error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                  }
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(textareaChildren)) {
                    if (!(textareaChildren.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    textareaChildren = textareaChildren[0];
                  }
                  defaultValue = "" + textareaChildren;
                }
                if (defaultValue == null) {
                  defaultValue = "";
                }
                initialValue = defaultValue;
              }
              props = _assign({}, props, {
                value: void 0,
                children: "" + initialValue
              });
            } else if (tag === "select") {
              {
                checkControlledValueProps("select", props);
                for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                  var propName = valuePropNames[i2];
                  if (props[propName] == null) {
                    continue;
                  }
                  var isArray3 = Array.isArray(props[propName]);
                  if (props.multiple && !isArray3) {
                    error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                  } else if (!props.multiple && isArray3) {
                    error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                  }
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                  error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultSelectValue = true;
                }
              }
              this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
              props = _assign({}, props, {
                value: void 0
              });
            } else if (tag === "option") {
              var selected = null;
              var selectValue = this.currentSelectValue;
              var optionChildren = flattenOptionChildren(props.children);
              if (selectValue != null) {
                var value;
                if (props.value != null) {
                  value = props.value + "";
                } else {
                  value = optionChildren;
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                  for (var j = 0; j < selectValue.length; j++) {
                    if ("" + selectValue[j] === value) {
                      selected = true;
                      break;
                    }
                  }
                } else {
                  selected = "" + selectValue === value;
                }
                props = _assign({
                  selected: void 0,
                  children: void 0
                }, props, {
                  selected,
                  children: optionChildren
                });
              }
            }
            {
              validatePropertiesInDevelopment(tag, props);
            }
            assertValidProps(tag, props);
            var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
            var footer = "";
            if (omittedCloseTags.hasOwnProperty(tag)) {
              out += "/>";
            } else {
              out += ">";
              footer = "</" + element.type + ">";
            }
            var children;
            var innerMarkup = getNonChildrenInnerMarkup(props);
            if (innerMarkup != null) {
              children = [];
              if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === "\n") {
                out += "\n";
              }
              out += innerMarkup;
            } else {
              children = toArray(props.children);
            }
            var frame = {
              domNamespace: getChildNamespace(parentNamespace, element.type),
              type: tag,
              children,
              childIndex: 0,
              context,
              footer
            };
            {
              frame.debugElementStack = [];
            }
            this.stack.push(frame);
            this.previousWasTextNode = false;
            return out;
          };
          return ReactDOMServerRenderer2;
        }();
        function renderToString2(element, options) {
          var renderer = new ReactDOMServerRenderer(element, false, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToStaticMarkup(element, options) {
          var renderer = new ReactDOMServerRenderer(element, true, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
          _inheritsLoose(ReactMarkupReadableStream2, _Readable);
          function ReactMarkupReadableStream2(element, makeStaticMarkup, options) {
            var _this;
            _this = _Readable.call(this, {}) || this;
            _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup, options);
            return _this;
          }
          var _proto = ReactMarkupReadableStream2.prototype;
          _proto._destroy = function _destroy(err, callback) {
            this.partialRenderer.destroy();
            callback(err);
          };
          _proto._read = function _read(size) {
            try {
              this.push(this.partialRenderer.read(size));
            } catch (err) {
              this.destroy(err);
            }
          };
          return ReactMarkupReadableStream2;
        }(stream.Readable);
        function renderToNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, false, options);
        }
        function renderToStaticNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, true, options);
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString2;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports, module) {
    init_react();
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_dom_server_node_development();
    }
  }
});

// node_modules/react-dom/server.js
var require_server = __commonJS({
  "node_modules/react-dom/server.js"(exports, module) {
    init_react();
    "use strict";
    module.exports = require_server_node();
  }
});

// <stdin>
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/index.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/cookieSigning.js
init_react();
var encoder = new TextEncoder();
async function sign(value, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["sign"]);
  let data = encoder.encode(value);
  let signature = await crypto.subtle.sign("HMAC", key, data);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
  return value + "." + hash;
}
async function unsign(cookie, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["verify"]);
  let value = cookie.slice(0, cookie.lastIndexOf("."));
  let hash = cookie.slice(cookie.lastIndexOf(".") + 1);
  let data = encoder.encode(value);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data);
  return valid ? value : false;
}
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
function installGlobals() {
  self.sign = sign;
  self.unsign = unsign;
}

// node_modules/@remix-run/cloudflare-pages/esm/sessions/cloudflareKVSessionStorage.js
init_react();

// node_modules/@remix-run/server-runtime/esm/index.js
init_react();

// node_modules/@remix-run/server-runtime/esm/responses.js
init_react();
function json(data, init2 = {}) {
  let responseInit = init2;
  if (typeof init2 === "number") {
    responseInit = {
      status: init2
    };
  }
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), __spreadProps(__spreadValues({}, responseInit), {
    headers
  }));
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
var redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response) {
  return redirectStatusCodes.has(response.status);
}
function isCatchResponse(response) {
  return response.headers.get("X-Remix-Catch") != null;
}

// node_modules/@remix-run/server-runtime/esm/server.js
init_react();

// node_modules/@remix-run/server-runtime/esm/data.js
init_react();
async function callRouteAction({
  loadContext,
  match,
  request
}) {
  let action = match.route.module.action;
  if (!action) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide an \`action\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await action({
      request: stripDataParam(stripIndexParam(request.clone())),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
async function callRouteLoader({
  loadContext,
  match,
  request
}) {
  let loader = match.route.module.loader;
  if (!loader) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await loader({
      request: stripDataParam(stripIndexParam(request.clone())),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
function stripIndexParam(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_data");
  return new Request(url.href, request);
}
function extractData(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}

// node_modules/@remix-run/server-runtime/esm/entry.js
init_react();
function createEntryMatches(matches, routes2) {
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: routes2[match.route.id]
  }));
}
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo, routeId) => {
    memo[routeId] = manifest[routeId].module;
    return memo;
  }, {});
}

// node_modules/@remix-run/server-runtime/esm/errors.js
init_react();
async function serializeError(error) {
  return {
    message: error.message,
    stack: error.stack
  };
}

// node_modules/@remix-run/server-runtime/esm/headers.js
init_react();
var import_set_cookie_parser = __toModule(require_set_cookie());
function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
  return matches.reduce((parentHeaders, match, index) => {
    let routeModule = build.routes[match.route.id].module;
    let loaderHeaders = routeLoaderResponses[index] ? routeLoaderResponses[index].headers : new Headers();
    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);
    cookies.forEach((cookie) => {
      childHeaders.append("Set-Cookie", cookie);
    });
  }
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
init_react();

// node_modules/react-router-dom/index.js
init_react();
var import_react2 = __toModule(require_react());

// node_modules/history/index.js
init_react();

// node_modules/@babel/runtime/helpers/esm/extends.js
init_react();

// node_modules/history/index.js
var r;
var B = r || (r = {});
B.Pop = "POP";
B.Push = "PUSH";
B.Replace = "REPLACE";
function I(b) {
  var h = b.pathname;
  h = h === void 0 ? "/" : h;
  var e = b.search;
  e = e === void 0 ? "" : e;
  b = b.hash;
  b = b === void 0 ? "" : b;
  e && e !== "?" && (h += e.charAt(0) === "?" ? e : "?" + e);
  b && b !== "#" && (h += b.charAt(0) === "#" ? b : "#" + b);
  return h;
}
function J(b) {
  var h = {};
  if (b) {
    var e = b.indexOf("#");
    0 <= e && (h.hash = b.substr(e), b = b.substr(0, e));
    e = b.indexOf("?");
    0 <= e && (h.search = b.substr(e), b = b.substr(0, e));
    b && (h.pathname = b);
  }
  return h;
}

// node_modules/react-router/index.js
init_react();
var import_react = __toModule(require_react());
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning(false, message) : void 0;
  }
}
var NavigationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = /* @__PURE__ */ (0, import_react.createContext)({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = r.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0, import_react.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = J(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = (0, import_react.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  true ? warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ (0, import_react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react.createElement)(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
function useHref(to) {
  !useInRouterContext() ? true ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0, import_react.useContext)(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  return (0, import_react.useContext)(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0, import_react.useCallback)(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = /* @__PURE__ */ (0, import_react.createContext)(null);
function useOutlet(context) {
  let outlet = (0, import_react.useContext)(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ (0, import_react.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to) {
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0, import_react.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes2, locationArg) {
  !useInRouterContext() ? true ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    matches: parentMatches
  } = (0, import_react.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? J(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : void 0;
    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function matchRoutes(routes2, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? J(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes2.forEach((route, index) => {
    let meta2 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta2.relativePath.startsWith("/")) {
      !meta2.relativePath.startsWith(parentPath) ? true ? invariant(false, 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : invariant(false) : void 0;
      meta2.relativePath = meta2.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta2.relativePath]);
    let routesMeta = parentsMeta.concat(meta2);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ? true ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index) => {
    return /* @__PURE__ */ (0, import_react.createElement)(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : /* @__PURE__ */ (0, import_react.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')) : void 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    true ? warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")) : void 0;
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? J(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? J(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? J(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

// node_modules/react-router-dom/index.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0, import_react2.useState)({
    action: history.action,
    location: history.location
  });
  (0, import_react2.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0, import_react2.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var Link = /* @__PURE__ */ (0, import_react2.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ (0, import_react2.createElement)("a", _extends2({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = /* @__PURE__ */ (0, import_react2.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let location = useLocation();
  let path = useResolvedPath(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ (0, import_react2.createElement)(Link, _extends2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to);
  return (0, import_react2.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || I(location) === I(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/server-runtime/esm/mode.js
init_react();
var ServerMode;
(function(ServerMode2) {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
})(ServerMode || (ServerMode = {}));
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}

// node_modules/@remix-run/server-runtime/esm/routes.js
init_react();
function createRoutes(manifest, parentId) {
  return Object.keys(manifest).filter((key) => manifest[key].parentId === parentId).map((id) => __spreadProps(__spreadValues({}, manifest[id]), {
    children: createRoutes(manifest, id)
  }));
}

// node_modules/@remix-run/server-runtime/esm/serverHandoff.js
init_react();
var import_jsesc = __toModule(require_jsesc());
function createServerHandoffString(serverHandoff) {
  return (0, import_jsesc.default)(serverHandoff, {
    isScriptContext: true
  });
}

// node_modules/@remix-run/server-runtime/esm/server.js
function createRequestHandler(build, platform2, mode) {
  let routes2 = createRoutes(build.routes);
  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;
  return async function requestHandler(request, loadContext) {
    let url = new URL(request.url);
    let matches = matchServerRoutes(routes2, url.pathname);
    let requestType = getRequestType(url, matches);
    let response;
    switch (requestType) {
      case "data":
        response = await handleDataRequest({
          request,
          loadContext,
          matches,
          handleDataRequest: build.entry.module.handleDataRequest,
          serverMode
        });
        break;
      case "document":
        response = await renderDocumentRequest({
          build,
          loadContext,
          matches,
          request,
          routes: routes2,
          serverMode
        });
        break;
      case "resource":
        response = await handleResourceRequest({
          request,
          loadContext,
          matches,
          serverMode
        });
        break;
    }
    if (request.method.toLowerCase() === "head") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
}
async function handleDataRequest({
  handleDataRequest: handleDataRequest2,
  loadContext,
  matches,
  request,
  serverMode
}) {
  if (!isValidRequestMethod(request)) {
    return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
  }
  let url = new URL(request.url);
  if (!matches) {
    return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
  }
  let response;
  let match;
  try {
    if (isActionRequest(request)) {
      match = getActionRequestMatch(url, matches);
      response = await callRouteAction({
        loadContext,
        match,
        request
      });
    } else {
      let routeId = url.searchParams.get("_data");
      if (!routeId) {
        return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
      }
      let tempMatch = matches.find((match2) => match2.route.id === routeId);
      if (!tempMatch) {
        return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
      }
      match = tempMatch;
      response = await callRouteLoader({
        loadContext,
        match,
        request
      });
    }
    if (isRedirectResponse(response)) {
      let headers = new Headers(response.headers);
      headers.set("X-Remix-Redirect", headers.get("Location"));
      headers.delete("Location");
      return new Response(null, {
        status: 204,
        headers
      });
    }
    if (handleDataRequest2) {
      response = await handleDataRequest2(response.clone(), {
        context: loadContext,
        params: match.params,
        request: request.clone()
      });
    }
    return response;
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    if (serverMode === ServerMode.Development) {
      return errorBoundaryError(error, 500);
    }
    return errorBoundaryError(new Error("Unexpected Server Error"), 500);
  }
}
async function renderDocumentRequest({
  build,
  loadContext,
  matches,
  request,
  routes: routes2,
  serverMode
}) {
  let url = new URL(request.url);
  let appState = {
    trackBoundaries: true,
    trackCatchBoundaries: true,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: void 0,
    catch: void 0
  };
  if (!isValidRequestMethod(request)) {
    matches = null;
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 405,
      statusText: "Method Not Allowed"
    };
  } else if (!matches) {
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 404,
      statusText: "Not Found"
    };
  }
  let actionStatus;
  let actionData;
  let actionMatch;
  let actionResponse;
  if (matches && isActionRequest(request)) {
    actionMatch = getActionRequestMatch(url, matches);
    try {
      actionResponse = await callRouteAction({
        loadContext,
        match: actionMatch,
        request
      });
      if (isRedirectResponse(actionResponse)) {
        return actionResponse;
      }
      actionStatus = {
        status: actionResponse.status,
        statusText: actionResponse.statusText
      };
      if (isCatchResponse(actionResponse)) {
        appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
        appState.trackCatchBoundaries = false;
        appState.catch = __spreadProps(__spreadValues({}, actionStatus), {
          data: await extractData(actionResponse)
        });
      } else {
        actionData = {
          [actionMatch.route.id]: await extractData(actionResponse)
        };
      }
    } catch (error) {
      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the action for route ${actionMatch.route.id}`);
      }
    }
  }
  let routeModules = createEntryRouteModules(build.routes);
  let matchesToLoad = matches || [];
  if (appState.catch) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "CatchBoundary");
  } else if (appState.error) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "ErrorBoundary");
  }
  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? callRouteLoader({
    loadContext,
    match,
    request
  }) : Promise.resolve(void 0)));
  let actionCatch = appState.catch;
  let actionError = appState.error;
  let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
  let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
  appState.catch = void 0;
  appState.error = void 0;
  let routeLoaderResponses = [];
  let loaderStatusCodes = [];
  let routeData = {};
  for (let index = 0; index < matchesToLoad.length; index++) {
    let match = matchesToLoad[index];
    let result = routeLoaderResults[index];
    let error = result.status === "rejected" ? result.reason : void 0;
    let response = result.status === "fulfilled" ? result.value : void 0;
    let isRedirect = response ? isRedirectResponse(response) : false;
    let isCatch = response ? isCatchResponse(response) : false;
    if (appState.catch || appState.error) {
      break;
    }
    if (!actionCatch && !actionError && response && isRedirect) {
      return response;
    }
    if (match.route.module.CatchBoundary) {
      appState.catchBoundaryRouteId = match.route.id;
    }
    if (match.route.module.ErrorBoundary) {
      appState.loaderBoundaryRouteId = match.route.id;
    }
    if (error) {
      loaderStatusCodes.push(500);
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the data loader for route ${match.route.id}`);
      }
      break;
    } else if (response) {
      routeLoaderResponses.push(response);
      loaderStatusCodes.push(response.status);
      if (isCatch) {
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: await extractData(response),
          status: response.status,
          statusText: response.statusText
        };
        break;
      } else {
        routeData[match.route.id] = await extractData(response);
      }
    }
  }
  if (!appState.catch) {
    appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
  }
  if (!appState.error) {
    appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
  }
  appState.catch = actionCatch || appState.catch;
  appState.error = actionError || appState.error;
  let renderableMatches = getRenderableMatches(matches, appState);
  if (!renderableMatches) {
    renderableMatches = [];
    let root = routes2[0];
    if (root !== null && root !== void 0 && root.module.CatchBoundary) {
      appState.catchBoundaryRouteId = "root";
      renderableMatches.push({
        params: {},
        pathname: "",
        route: routes2[0]
      });
    }
  }
  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
  let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
  let responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);
  let serverHandoff = {
    actionData,
    appState,
    matches: entryMatches,
    routeData
  };
  let entryContext = __spreadProps(__spreadValues({}, serverHandoff), {
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff)
  });
  let handleDocumentRequest = build.entry.module.default;
  try {
    return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
  } catch (error) {
    responseStatusCode = 500;
    appState.trackBoundaries = false;
    appState.error = await serializeError(error);
    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
    try {
      return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
    } catch (error2) {
      if (serverMode !== ServerMode.Test) {
        console.error(error2);
      }
      let message = "Unexpected Server Error";
      if (serverMode === ServerMode.Development) {
        message += `

${String(error2)}`;
      }
      return new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
  }
}
async function handleResourceRequest({
  loadContext,
  matches,
  request,
  serverMode
}) {
  let match = matches.slice(-1)[0];
  try {
    if (isActionRequest(request)) {
      return await callRouteAction({
        match,
        loadContext,
        request
      });
    } else {
      return await callRouteLoader({
        match,
        loadContext,
        request
      });
    }
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    let message = "Unexpected Server Error";
    if (serverMode === ServerMode.Development) {
      message += `

${String(error)}`;
    }
    return new Response(message, {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
}
function getRequestType(url, matches) {
  if (url.searchParams.has("_data")) {
    return "data";
  }
  if (!matches) {
    return "document";
  }
  let match = matches.slice(-1)[0];
  if (!match.route.module.default) {
    return "resource";
  }
  return "document";
}
function isActionRequest(request) {
  let method = request.method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function isHeadRequest(request) {
  return request.method.toLowerCase() === "head";
}
function isValidRequestMethod(request) {
  return request.method.toLowerCase() === "get" || isHeadRequest(request) || isActionRequest(request);
}
async function errorBoundaryError(error, status) {
  return json(await serializeError(error), {
    status,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function isIndexRequestUrl(url) {
  let indexRequest = false;
  for (let param of url.searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
function getActionRequestMatch(url, matches) {
  let match = matches.slice(-1)[0];
  if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
    return matches.slice(-2)[0];
  }
  return match;
}
function getDeepestRouteIdWithBoundary(matches, key) {
  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
  return matched ? matched.route.id : null;
}
function getMatchesUpToDeepestBoundary(matches, key) {
  let deepestBoundaryIndex = -1;
  matches.forEach((match, index) => {
    if (match.route.module[key]) {
      deepestBoundaryIndex = index;
    }
  });
  if (deepestBoundaryIndex === -1) {
    return [];
  }
  return matches.slice(0, deepestBoundaryIndex + 1);
}
function getRenderableMatches(matches, appState) {
  if (!matches) {
    return null;
  }
  if (!appState.catch && !appState.error) {
    return matches;
  }
  let lastRenderableIndex = -1;
  matches.forEach((match, index) => {
    let id = match.route.id;
    if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {
      lastRenderableIndex = index;
    }
  });
  return matches.slice(0, lastRenderableIndex + 1);
}

// node_modules/@remix-run/cloudflare-pages/esm/worker.js
init_react();
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let platform2 = {};
  let handleRequest3 = createRequestHandler(build, platform2, mode);
  return (context) => {
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(context) : void 0;
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  const handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  });
  const handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      var _response;
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone());
      response = (_response = response) !== null && _response !== void 0 && _response.ok ? new Response(response.body, response) : void 0;
    } catch {
    }
    if (!response) {
      response = await handleRequest3(context);
    }
    return response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (e) {
      if (e instanceof Error) {
        console.error(e);
        return new Response(e.message || e.toString(), {
          status: 500
        });
      }
      return new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// node_modules/@remix-run/cloudflare-pages/esm/index.js
installGlobals();

// server-entry:@remix-run/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  entry: () => entry,
  routes: () => routes
});
init_react();

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
init_react();
var import_server3 = __toModule(require_server());

// node_modules/remix/esm/client.js
init_react();

// node_modules/@remix-run/react/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/components.js
init_react();

// node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js
init_react();
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// node_modules/@remix-run/react/esm/components.js
var React3 = __toModule(require_react());

// node_modules/@remix-run/react/esm/errorBoundaries.js
init_react();
var import_react3 = __toModule(require_react());
var RemixErrorBoundary = class extends import_react3.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ import_react3.default.createElement(this.props.component, {
        error: this.state.error
      });
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error
}) {
  console.error(error);
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react3.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX when your app throws errors than this. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
var RemixCatchContext = /* @__PURE__ */ import_react3.default.createContext(void 0);
function useCatch() {
  return (0, import_react3.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component,
  children
}) {
  if (catchVal) {
    return /* @__PURE__ */ import_react3.default.createElement(RemixCatchContext.Provider, {
      value: catchVal
    }, /* @__PURE__ */ import_react3.default.createElement(Component, null));
  }
  return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX when your app throws 404s (and other responses) than this. Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}

// node_modules/@remix-run/react/esm/invariant.js
init_react();
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// node_modules/@remix-run/react/esm/links.js
init_react();

// node_modules/@remix-run/react/esm/routeModules.js
init_react();
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push(__spreadProps(__spreadValues({}, descriptor), {
        rel: "preload",
        as: "style"
      }));
    }
  }
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  return object != null && typeof object.rel === "string" && typeof object.href === "string";
}
async function getStylesheetPrefetchLinks(matches, routeModules) {
  let links = await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(match.route, routeModules);
    return mod.links ? mod.links() : [];
  }));
  return links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((_a) => {
    var _b = _a, {
      rel
    } = _b, attrs = __objRest(_b, [
      "rel"
    ]);
    if (rel === "preload") {
      return __spreadValues({
        rel: "prefetch"
      }, attrs);
    }
    return __spreadValues({
      rel: "prefetch",
      as: "style"
    }, attrs);
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {
  let path = parsePathPatch(page);
  let isNew = (match, index) => {
    if (!currentMatches[index])
      return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _currentMatches$index;
    return currentMatches[index].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"];
  };
  let newMatches = mode === "data" && location.search !== path.search ? nextMatches.filter((match, index) => {
    if (!match.route.hasLoader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      return match.route.shouldReload({
        params: match.params,
        prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),
        url: new URL(page, window.origin)
      });
    }
    return true;
  }) : nextMatches.filter((match, index) => {
    return match.route.hasLoader && (isNew(match, index) || matchPathChanged(match, index));
  });
  return newMatches;
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path;
    let searchParams = new URLSearchParams(search);
    searchParams.set("_data", match.route.id);
    return `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let str = JSON.stringify(descriptor);
    if (!set.has(str)) {
      set.add(str);
      deduped.push(descriptor);
    }
    return deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = J(href);
  if (path.search === void 0)
    path.search = "";
  return path;
}

// node_modules/@remix-run/react/esm/markup.js
init_react();
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/esm/routes.js
init_react();
var React2 = __toModule(require_react());

// node_modules/@remix-run/react/esm/data.js
init_react();
function isCatchResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
async function fetchData(url, routeId, signal, submission) {
  url.searchParams.set("_data", routeId);
  let init2 = submission ? getActionInit(submission, signal) : {
    credentials: "same-origin",
    signal
  };
  let response = await fetch(url.href, init2);
  if (isErrorResponse(response)) {
    let data = await response.json();
    let error = new Error(data.message);
    error.stack = data.stack;
    return error;
  }
  return response;
}
async function extractData2(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission;
  let headers = void 0;
  let body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData) {
      invariant2(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
      body.append(key, value);
    }
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}

// node_modules/@remix-run/react/esm/transition.js
init_react();

// node_modules/@remix-run/react/esm/routeMatching.js
init_react();
function matchClientRoutes(routes2, location) {
  let matches = matchRoutes(routes2, location);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/react/esm/transition.js
var CatchValue = class {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText;
    this.data = data;
  }
};
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location) {
  return Boolean(location.state) && location.state.isRedirect;
}
function isLoaderRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loader";
}
function isActionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "action";
}
function isFetchActionRedirect(location) {
  return isRedirectLocation(location) && location.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loaderSubmission";
}
var TransitionRedirect = class {
  constructor(location) {
    this.location = typeof location === "string" ? location : location.pathname + location.search;
  }
};
var IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
};
var IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init2) {
  let {
    routes: routes2
  } = init2;
  let pendingNavigationController;
  let fetchControllers = new Map();
  let incrementingLoadId = 0;
  let navigationLoadId = -1;
  let fetchReloadIds = new Map();
  let matches = matchClientRoutes(routes2, init2.location);
  if (!matches) {
    matches = [{
      params: {},
      pathname: "",
      route: routes2[0]
    }];
  }
  let state = {
    location: init2.location,
    loaderData: init2.loaderData || {},
    actionData: init2.actionData,
    catch: init2.catch,
    error: init2.error,
    catchBoundaryId: init2.catchBoundaryId || null,
    errorBoundaryId: init2.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: new Map()
  };
  function update(updates) {
    state = Object.assign({}, state, updates);
    init2.onChange(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchReloadIds.delete(key);
    state.fetchers.delete(key);
  }
  async function send(event) {
    switch (event.type) {
      case "navigation": {
        let {
          action,
          location,
          submission
        } = event;
        let matches2 = matchClientRoutes(routes2, location);
        if (!matches2) {
          matches2 = [{
            params: {},
            pathname: "",
            route: routes2[0]
          }];
          await handleNotFoundNavigation(location, matches2);
        } else if (!submission && isHashChangeOnly(location)) {
          await handleHashChange(location, matches2);
        } else if (action === r.Pop) {
          await handleLoad(location, matches2);
        } else if (submission && isActionSubmission(submission)) {
          await handleActionSubmissionNavigation(location, submission, matches2);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderSubmissionNavigation(location, submission, matches2);
        } else if (isActionRedirectLocation(location)) {
          await handleActionRedirect(location, matches2);
        } else if (isLoaderSubmissionRedirectLocation(location)) {
          await handleLoaderSubmissionRedirect(location, matches2);
        } else if (isLoaderRedirectLocation(location)) {
          await handleLoaderRedirect(location, matches2);
        } else if (isFetchActionRedirect(location)) {
          await handleFetchActionRedirect(location, matches2);
        } else {
          await handleLoad(location, matches2);
        }
        navigationLoadId = -1;
        break;
      }
      case "fetcher": {
        let {
          key,
          submission,
          href
        } = event;
        let matches2 = matchClientRoutes(routes2, href);
        invariant2(matches2, "No matches found");
        let match = matches2.slice(-1)[0];
        if (fetchControllers.has(key))
          abortFetcher(key);
        if (submission && isActionSubmission(submission)) {
          await handleActionFetchSubmission(key, submission, match);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderFetchSubmission(href, key, submission, match);
        } else {
          await handleLoaderFetch(href, key, match);
        }
        break;
      }
      default: {
        throw new Error(`Unknown data event type: ${event.type}`);
      }
    }
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers) {
      controller.abort();
    }
  }
  async function handleActionFetchSubmission(key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callAction(submission, match, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "fetchAction"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let loadFetcher = {
      state: "loading",
      type: "actionReload",
      data: result.value,
      submission
    };
    state.fetchers.set(key, loadFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
    let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let matchesToLoad = state.nextMatches || state.matches;
    let hrefToLoad = createHref(state.transition.location || state.location);
    let results = await callLoaders(state, createUrl(hrefToLoad), matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
    if (controller.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    let redirect = findRedirect(results);
    if (redirect) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(redirect.location, locationState);
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult);
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    let abortedKeys = abortStaleFetchLoads(loadId);
    if (abortedKeys) {
      markFetchersDone(abortedKeys);
    }
    let yeetedNavigation = yeetStaleNavigationLoad(loadId);
    if (yeetedNavigation) {
      let {
        transition
      } = state;
      invariant2(transition.state === "loading", "Expected loading transition");
      update({
        location: transition.location,
        matches: state.nextMatches,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad),
        actionData: transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers)
      });
    } else {
      update({
        fetchers: new Map(state.fetchers),
        error,
        errorBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad)
      });
    }
  }
  function yeetStaleNavigationLoad(landedId) {
    let isLoadingNavigation = state.transition.state === "loading";
    if (isLoadingNavigation && navigationLoadId < landedId) {
      abortNormalNavigation();
      return true;
    }
    return false;
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant2(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    return yeetedKeys.length ? yeetedKeys : false;
  }
  async function handleLoaderFetchSubmission(href, key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    fetchControllers.delete(key);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function handleLoaderFetch(href, key, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (controller.signal.aborted)
      return;
    fetchControllers.delete(key);
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function maybeBailOnCatch(match, key, result) {
    if (isCatchResult(result)) {
      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers),
        catch: {
          data: result.value.data,
          status: result.value.status,
          statusText: result.value.statusText
        },
        catchBoundaryId
      });
      return true;
    }
    return false;
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      });
      return true;
    }
    return false;
  }
  async function handleNotFoundNavigation(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
    update({
      location,
      matches: matches2,
      catch: {
        data: null,
        status: 404,
        statusText: "Not Found"
      },
      catchBoundaryId,
      transition: IDLE_TRANSITION
    });
  }
  async function handleActionSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    let controller = new AbortController();
    pendingNavigationController = controller;
    if (!isIndexRequestAction(submission.action) && matches2[matches2.length - 1].route.id.endsWith("/index")) {
      matches2 = matches2.slice(0, -1);
    }
    let leafMatch = matches2.slice(-1)[0];
    let result = await callAction(submission, leafMatch, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "action"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (isCatchResult(result)) {
      let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], matches2, result);
      update({
        transition: IDLE_TRANSITION,
        catch: catchVal,
        catchBoundaryId
      });
      return;
    }
    let loadTransition = {
      state: "loading",
      type: "actionReload",
      submission,
      location
    };
    update({
      transition: loadTransition,
      actionData: {
        [leafMatch.route.id]: result.value
      }
    });
    await loadPageData(location, matches2, submission, leafMatch.route.id, result);
  }
  async function handleLoaderSubmissionNavigation(location, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleHashChange(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    update({
      location,
      matches: matches2,
      transition: IDLE_TRANSITION
    });
  }
  async function handleLoad(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleLoaderSubmissionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "loaderSubmissionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  async function handleFetchActionRedirect(location, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "fetchActionRedirect",
      submission: void 0,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2);
  }
  async function handleActionRedirect(location, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "actionRedirect",
      submission,
      location
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location, matches2, submission);
  }
  function isHashChangeOnly(location) {
    return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;
  }
  async function loadPageData(location, matches2, submission, submissionRouteId, actionResult) {
    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
    let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
    let controller = new AbortController();
    pendingNavigationController = controller;
    navigationLoadId = ++incrementingLoadId;
    let results = await callLoaders(state, createUrl(createHref(location)), matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId);
    if (controller.signal.aborted) {
      return;
    }
    let redirect = findRedirect(results);
    if (redirect) {
      if (state.transition.type === "actionReload") {
        let locationState = {
          isRedirect: true,
          type: "action"
        };
        init2.onRedirect(redirect.location, locationState);
      } else if (state.transition.type === "loaderSubmission") {
        let locationState = {
          isRedirect: true,
          type: "loaderSubmission"
        };
        init2.onRedirect(redirect.location, locationState);
      } else {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init2.onRedirect(redirect.location, locationState);
      }
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult);
    let abortedIds = abortStaleFetchLoads(navigationLoadId);
    if (abortedIds) {
      markFetchersDone(abortedIds);
    }
    update({
      location,
      matches: matches2,
      error,
      errorBoundaryId,
      catch: catchVal,
      catchBoundaryId,
      loaderData: makeLoaderData(state, results, matches2),
      actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
      transition: IDLE_TRANSITION,
      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
    });
  }
  function abortNormalNavigation() {
    var _pendingNavigationCon;
    (_pendingNavigationCon = pendingNavigationController) === null || _pendingNavigationCon === void 0 ? void 0 : _pendingNavigationCon.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant2(controller, `Expected fetch controller: ${key}`);
    controller.abort();
    fetchControllers.delete(key);
  }
  return {
    send,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
function isIndexRequestAction(action) {
  let indexRequest = false;
  let searchParams = new URLSearchParams(action.split("?", 2)[1] || "");
  for (let param of searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
async function callLoaders(state, url, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  let matchesToLoad = filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher);
  return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
}
async function callLoader(match, url, signal) {
  invariant2(match.route.loader, `Expected loader for ${match.route.id}`);
  try {
    let {
      params
    } = match;
    let value = await match.route.loader({
      params,
      url,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
async function callAction(submission, match, signal) {
  if (!match.route.action) {
    throw new Error(`Route "${match.route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
  }
  try {
    let value = await match.route.action({
      url: createUrl(submission.action),
      params: match.params,
      submission,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
function filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  if (submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = false;
    matches = matches.filter((match) => {
      if (foundProblematicRoute) {
        return false;
      }
      if (match.route.id === submissionRouteId) {
        foundProblematicRoute = true;
        return false;
      }
      return true;
    });
  }
  let isNew = (match, index) => {
    if (!state.matches[index])
      return true;
    return match.route.id !== state.matches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _state$matches$index$;
    return state.matches[index].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index].params["*"] !== match.params["*"];
  };
  let filterByRouteProps = (match, index) => {
    if (!match.route.loader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return true;
  };
  let isInRootCatchBoundary = state.matches.length === 1;
  if (isInRootCatchBoundary) {
    return matches.filter((match) => !!match.route.loader);
  }
  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
    return matches.filter(filterByRouteProps);
  } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search) {
    return matches.filter(filterByRouteProps);
  }
  return matches.filter((match, index, arr) => {
    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index) {
      return false;
    }
    return match.route.loader && (isNew(match, index) || matchPathChanged(match, index));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location) {
  return location.pathname + location.search;
}
function findRedirect(results) {
  for (let result of results) {
    if (isRedirectResult(result)) {
      return result.value;
    }
  }
  return null;
}
async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  let loaderCatchResult;
  for (let result of results) {
    if (isCatchResult(result)) {
      loaderCatchResult = result;
      break;
    }
  }
  let extractCatchData = async (res) => ({
    status: res.status,
    statusText: res.statusText,
    data: res.data
  });
  if (actionCatchResult && loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(actionCatchResult.value), boundaryId];
  }
  if (loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(loaderCatchResult.value), boundaryId];
  }
  return [void 0, void 0];
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results) {
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.CatchBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.ErrorBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results) {
    newData[match.route.id] = value;
  }
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    if (value !== void 0) {
      loaderData[route.id] = value;
    }
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}

// node_modules/@remix-run/react/esm/routes.js
function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ React2.createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    if (children.length > 0)
      route.children = children;
    return route;
  });
}
function createShouldReload(route, routeModules) {
  let shouldReload = (arg) => {
    let module = routeModules[route.id];
    invariant2(module, `Expected route module to be loaded for ${route.id}`);
    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }
    return true;
  };
  return shouldReload;
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  await prefetchStyleLinks(routeModule);
  return routeModule;
}
function createLoader(route, routeModules) {
  let loader = async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect = await checkRedirect(result);
      if (redirect)
        return redirect;
      if (isCatchResponse2(result)) {
        throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
      }
      return extractData2(result);
    } else {
      await loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  };
  return loader;
}
function createAction(route) {
  if (!route.hasAction)
    return void 0;
  let action = async ({
    url,
    signal,
    submission
  }) => {
    let result = await fetchData(url, route.id, signal, submission);
    if (result instanceof Error) {
      throw result;
    }
    let redirect = await checkRedirect(result);
    if (redirect)
      return redirect;
    if (isCatchResponse2(result)) {
      throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
    }
    return extractData2(result);
  };
  return action;
}
async function checkRedirect(response) {
  if (isRedirectResponse2(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
    if (url.origin !== window.location.origin) {
      await new Promise(() => {
        window.location.replace(url.href);
      });
    } else {
      return new TransitionRedirect(url.pathname + url.search);
    }
  }
  return null;
}

// node_modules/@remix-run/react/esm/components.js
var RemixEntryContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixEntryContext() {
  let context = React3.useContext(RemixEntryContext);
  invariant2(context, "You must render this element inside a <Remix> element");
  return context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = false
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext;
  let clientRoutes = React3.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
  let [clientState, setClientState] = React3.useState(entryComponentDidCatchEmulator);
  let [transitionManager] = React3.useState(() => {
    return createTransitionManager({
      routes: clientRoutes,
      actionData: documentActionData,
      loaderData: documentLoaderData,
      location: historyLocation,
      catch: entryComponentDidCatchEmulator.catch,
      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
      onRedirect: _navigator.replace,
      onChange: (state) => {
        setClientState({
          catch: state.catch,
          error: state.error,
          catchBoundaryRouteId: state.catchBoundaryId,
          loaderBoundaryRouteId: state.errorBoundaryId,
          renderBoundaryRouteId: null,
          trackBoundaries: false,
          trackCatchBoundaries: false
        });
      }
    });
  });
  let navigator = React3.useMemo(() => {
    let push = (to, state) => {
      return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
    };
    return __spreadProps(__spreadValues({}, _navigator), {
      push
    });
  }, [_navigator, transitionManager]);
  let {
    location,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  React3.useEffect(() => {
    let {
      location: location2
    } = transitionManager.getState();
    if (historyLocation === location2)
      return;
    transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ React3.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
    location,
    component: RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
    location,
    component: RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(Router, {
    navigationType: action,
    location,
    navigator,
    static: staticProp
  }, /* @__PURE__ */ React3.createElement(Routes2, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  error.stack = data.stack;
  return error;
}
function Routes2() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  let element = useRoutes(clientRoutes) || clientRoutes[0].element;
  return element;
}
var RemixRouteContext = /* @__PURE__ */ React3.createContext(void 0);
function DefaultRouteComponent({
  id
}) {
  throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id
}) {
  let location = useLocation();
  let {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  let data = routeData[id];
  let {
    default: Component,
    CatchBoundary,
    ErrorBoundary
  } = routeModules[id];
  let element = Component ? /* @__PURE__ */ React3.createElement(Component, null) : /* @__PURE__ */ React3.createElement(DefaultRouteComponent, {
    id
  });
  let context = {
    data,
    id
  };
  if (CatchBoundary) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
    if (appState.trackCatchBoundaries) {
      appState.catchBoundaryRouteId = id;
    }
    context = maybeServerCaught ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
      location,
      component: CatchBoundary,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
    if (appState.trackBoundaries) {
      appState.renderBoundaryRouteId = id;
    }
    context = maybeServerRenderError ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
      location,
      component: ErrorBoundary,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ React3.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext();
  let links = React3.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, links.map((link) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, _extends3({
    key: link.page
  }, link)) : /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.rel + link.href
  }, link))));
}
function PrefetchPageLinks(_a) {
  var _b = _a, {
    page
  } = _b, dataLinkProps = __objRest(_b, [
    "page"
  ]);
  let {
    clientRoutes
  } = useRemixEntryContext();
  let matches = React3.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
  if (!matches) {
    console.warn(`Tried to prefetch ${page} but no routes matched.`);
    return null;
  }
  return /* @__PURE__ */ React3.createElement(PrefetchPageLinksImpl, _extends3({
    page,
    matches
  }, dataLinkProps));
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext();
  let [styleLinks, setStyleLinks] = React3.useState([]);
  React3.useEffect(() => {
    let interrupted = false;
    getStylesheetPrefetchLinks(matches, routeModules).then((links) => {
      if (!interrupted)
        setStyleLinks(links);
    });
    return () => {
      interrupted = true;
    };
  }, [matches, routeModules]);
  return styleLinks;
}
function PrefetchPageLinksImpl(_a) {
  var _b = _a, {
    page,
    matches: nextMatches
  } = _b, linkProps = __objRest(_b, [
    "page",
    "matches"
  ]);
  let location = useLocation();
  let {
    matches,
    manifest
  } = useRemixEntryContext();
  let newMatchesForData = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "data"), [page, nextMatches, matches, location]);
  let newMatchesForAssets = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location, "assets"), [page, nextMatches, matches, location]);
  let dataHrefs = React3.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
  let moduleHrefs = React3.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  let location = useLocation();
  let meta2 = {};
  let parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id;
    let data = routeData[routeId];
    let params = match.params;
    let routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location
      }) : routeModule.meta;
      Object.assign(meta2, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, Object.entries(meta2).map(([name, value]) => {
    let isOpenGraphTag = name.startsWith("og:");
    return name === "title" ? /* @__PURE__ */ React3.createElement("title", {
      key: "title"
    }, value) : Array.isArray(value) ? value.map((content) => isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      property: name,
      content
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      name,
      content
    })) : isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      property: name,
      content: value
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      name,
      content: value
    });
  }));
}
var isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  React3.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = React3.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
    let routeModulesScript = `${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};`;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(contextScript)
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.url
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module"
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.entry.module,
      type: "module"
    })));
  }, []);
  let nextMatches = React3.useMemo(() => {
    if (pendingLocation) {
      let matches2 = matchClientRoutes(clientRoutes, pendingLocation);
      invariant2(matches2, `No routes match path "${pendingLocation.pathname}"`);
      return matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]);
  let routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1);
  let preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dedupe2(preloads).map((path) => /* @__PURE__ */ React3.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe2(array) {
  return [...new Set(array)];
}
var nextNavigationSubmission;
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  nextNavigationSubmission = void 0;
  return submission;
}
function useBeforeUnload(callback) {
  React3.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
function LiveReload({
  port = 8002
}) {
  if (false)
    return null;
  return /* @__PURE__ */ React3.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
          let ws = new WebSocket("ws://localhost:${port}/socket");
          ws.onmessage = message => {
            let event = JSON.parse(message.data);
            if (event.type === "LOG") {
              console.log(event.message);
            }
            if (event.type === "RELOAD") {
              console.log("\u{1F4BF} Reloading window ...");
              window.location.reload();
            }
          };
          ws.onerror = error => {
            console.log("Remix dev asset server web socket error:");
            console.error(error);
          };
      `
    }
  });
}

// node_modules/@remix-run/react/esm/scroll-restoration.js
init_react();
var React4 = __toModule(require_react());
var STORAGE_KEY = "positions";
var positions = {};
if (typeof document !== "undefined") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  if (sessionPositions) {
    positions = JSON.parse(sessionPositions);
  }
}
function ScrollRestoration() {
  useScrollRestoration();
  React4.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []);
  useBeforeUnload(React4.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  return /* @__PURE__ */ React4.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
          let STORAGE_KEY = ${JSON.stringify(STORAGE_KEY)};
          if (!window.history.state || !window.history.state.key) {
            window.history.replaceState({ key: Math.random().toString(32).slice(2) }, null);
          }
          try {
            let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY) ?? '{}')
            let storedY = positions[window.history.state.key];
            if (typeof storedY === 'number') {
              window.scrollTo(0, storedY)
            }
          } catch(error) {
            console.error(error)
            sessionStorage.removeItem(STORAGE_KEY)
          }
        `
    }
  });
}
var hydrated = false;
function useScrollRestoration() {
  let location = useLocation();
  let transition = useTransition();
  let wasSubmissionRef = React4.useRef(false);
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
  React4.useEffect(() => {
    if (transition.location) {
      positions[location.key] = window.scrollY;
    }
  }, [transition, location]);
  useBeforeUnload(React4.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, []));
  if (typeof document !== "undefined") {
    React4.useLayoutEffect(() => {
      if (!hydrated) {
        hydrated = true;
        return;
      }
      let y = positions[location.key];
      if (y) {
        window.scrollTo(0, y);
        return;
      }
      if (location.hash) {
        let el = document.querySelector(location.hash);
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (wasSubmissionRef.current === true) {
        wasSubmissionRef.current = false;
        return;
      }
      window.scrollTo(0, 0);
    }, [location]);
  }
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
}

// node_modules/@remix-run/react/esm/server.js
init_react();
var React5 = __toModule(require_react());
function RemixServer({
  context,
  url
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let location = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  };
  let staticNavigator = {
    createHref(to) {
      return typeof to === "string" ? to : I(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    },
    block() {
      throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
    }
  };
  return /* @__PURE__ */ React5.createElement(RemixEntry, {
    context,
    action: r.Pop,
    location,
    navigator: staticNavigator,
    static: true
  });
}

// app/entry.server.tsx
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  const markup = (0, import_server3.renderToString)(/* @__PURE__ */ React.createElement(RemixServer, {
    context: remixContext,
    url: request.url
  }));
  responseHeaders.set("Content-Type", "text/html");
  return new Response("<!DOCTYPE html>" + markup, {
    status: responseStatusCode,
    headers: responseHeaders
  });
}

// route:/Users/loganmcansh/Developer/github.com/remix/remix/deployment-test/remix-cf-pages-add8fbftest/app/root.tsx
var root_exports = {};
__export(root_exports, {
  default: () => App,
  meta: () => meta
});
init_react();
var meta = () => {
  return { title: "New Remix App" };
};
function App() {
  return /* @__PURE__ */ React.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ React.createElement("head", null, /* @__PURE__ */ React.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ React.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1"
  }), /* @__PURE__ */ React.createElement(Meta, null), /* @__PURE__ */ React.createElement(Links, null)), /* @__PURE__ */ React.createElement("body", null, /* @__PURE__ */ React.createElement(Outlet, null), /* @__PURE__ */ React.createElement(ScrollRestoration, null), /* @__PURE__ */ React.createElement(Scripts, null), /* @__PURE__ */ React.createElement(LiveReload, null)));
}

// route:/Users/loganmcansh/Developer/github.com/remix/remix/deployment-test/remix-cf-pages-add8fbftest/app/routes/index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index
});
init_react();
function Index() {
  return /* @__PURE__ */ React.createElement("div", {
    style: { fontFamily: "system-ui, sans-serif", lineHeight: "1.4" }
  }, /* @__PURE__ */ React.createElement("h1", null, "Welcome to Remix"), /* @__PURE__ */ React.createElement("ul", null, /* @__PURE__ */ React.createElement("li", null, /* @__PURE__ */ React.createElement("a", {
    target: "_blank",
    href: "https://remix.run/tutorials/blog",
    rel: "noreferrer"
  }, "15m Quickstart Blog Tutorial")), /* @__PURE__ */ React.createElement("li", null, /* @__PURE__ */ React.createElement("a", {
    target: "_blank",
    href: "https://remix.run/tutorials/jokes",
    rel: "noreferrer"
  }, "Deep Dive Jokes App Tutorial")), /* @__PURE__ */ React.createElement("li", null, /* @__PURE__ */ React.createElement("a", {
    target: "_blank",
    href: "https://remix.run/docs",
    rel: "noreferrer"
  }, "Remix Docs"))));
}

// assets:@remix-run/assets-manifest
init_react();
var assets_manifest_default = { "version": "931a52b7", "entry": { "module": "/build/entry.client-YKUXY7PH.js", "imports": ["/build/_shared/chunk-2LNACJPW.js", "/build/_shared/chunk-E7VMOUYL.js"] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "module": "/build/root-2GQIOZDH.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/index": { "id": "routes/index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/index-YLIXAVWT.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false } }, "url": "/build/manifest-931A52B7.js" };

// server-entry:@remix-run/server-build
var entry = { module: entry_server_exports };
var routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: routes_exports
  }
};

// <stdin>
var handleRequest2 = createPagesFunctionHandler({ build: server_build_exports, mode: "development" });
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/**
 * @remix-run/cloudflare-pages v1.1.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.1.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.1.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/** @license React v17.0.2
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vZGV2L2NvbXBpbGVyL3NoaW1zL3JlYWN0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvanNlc2MvanNlc2MuanMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpldmVudHMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpwcm9jZXNzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9pbmhlcml0cy5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnV0aWwiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpidWZmZXIiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9idWZmZXItbGlzdC5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnN0cmluZ19kZWNvZGVyIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6c3RyZWFtIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6c3RyZWFtIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmpzIiwgIjxzdGRpbj4iLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vZ2xvYmFscy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9jb29raWVTaWduaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL3Nlc3Npb25zL2Nsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vcmVzcG9uc2VzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9zZXJ2ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2RhdGEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2VudHJ5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9lcnJvcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL2hlYWRlcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3JvdXRlTWF0Y2hpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanMiLCAiLi4vLi4vcGFja2FnZXMvcmVhY3Qtcm91dGVyL2luZGV4LnRzeCIsICIuLi8uLi9wYWNrYWdlcy9yZWFjdC1yb3V0ZXItZG9tL2luZGV4LnRzeCIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vbW9kZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vcm91dGVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9zZXJ2ZXJIYW5kb2ZmLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL3dvcmtlci5qcyIsICJzZXJ2ZXItZW50cnk6QHJlbWl4LXJ1bi9zZXJ2ZXItYnVpbGQiLCAiLi4vYXBwL2VudHJ5LnNlcnZlci50c3giLCAiLi4vbm9kZV9tb2R1bGVzL3JlbWl4L2VzbS9jbGllbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9jb21wb25lbnRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9lcnJvckJvdW5kYXJpZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2ludmFyaWFudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbGlua3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTW9kdWxlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vbWFya3VwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9yb3V0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2RhdGEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3RyYW5zaXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlTWF0Y2hpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3Njcm9sbC1yZXN0b3JhdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vc2VydmVyLmpzIiwgInJvdXRlOi9Vc2Vycy9sb2dhbm1jYW5zaC9EZXZlbG9wZXIvZ2l0aHViLmNvbS9yZW1peC9yZW1peC9kZXBsb3ltZW50LXRlc3QvcmVtaXgtY2YtcGFnZXMtYWRkOGZiZnRlc3QvYXBwL3Jvb3QudHN4IiwgInJvdXRlOi9Vc2Vycy9sb2dhbm1jYW5zaC9EZXZlbG9wZXIvZ2l0aHViLmNvbS9yZW1peC9yZW1peC9kZXBsb3ltZW50LXRlc3QvcmVtaXgtY2YtcGFnZXMtYWRkOGZiZnRlc3QvYXBwL3JvdXRlcy9pbmRleC50c3giLCAiYXNzZXRzOkByZW1peC1ydW4vYXNzZXRzLW1hbmlmZXN0Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwgIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4yJztcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG5leHBvcnRzLlN0cmljdE1vZGUgPSAweGVhY2M7XG5leHBvcnRzLlByb2ZpbGVyID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG5leHBvcnRzLlN1c3BlbnNlID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgZXhwb3J0cy5TdXNwZW5zZSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgdHJhbnNpdGlvbjogMFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKSB7XG4gIHtcbiAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gIH1cbn1cblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIHtcbiAgICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgICB9XG4gIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUpIHtcbiAgICAgIHN0YWNrICs9IGN1cnJlbnRFeHRyYVN0YWNrRnJhbWU7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cblxuXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcblxuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbi8qKlxuICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG4gKi9cblxuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcbiAgfVxuXG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIGV4cG9ydHMuUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdHJpY3RNb2RlOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgY29tcG9uZW50TmFtZSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcblxuICAgICAge1xuICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAoISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICAgIGVzY2FwZWRQcmVmaXggKyAoIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICBtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgZXhpc3RpbmcgZWxlbWVudCdzIGtleSBjYW4gYmUgYSBudW1iZXJcbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIHJlc3VsdCwgJycsICcnLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5cblxuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgbiA9IDA7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcbiAgfSk7XG4gIHJldHVybiBuO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuICB9LCBmb3JFYWNoQ29udGV4dCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pIHx8IFtdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuICAgICAgICAgICAgd2FybignU2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIENvbnRleHQuQ29uc3VtZXIgaGFzIG5vIGVmZmVjdC4gJyArIFwiWW91IHNob3VsZCBzZXQgaXQgZGlyZWN0bHkgb24gdGhlIGNvbnRleHQgd2l0aCBDb250ZXh0LmRpc3BsYXlOYW1lID0gJyVzJy5cIiwgZGlzcGxheU5hbWUpO1xuXG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuXG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpOyAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG4gICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgIHBlbmRpbmcuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgcGVuZGluZy5fcmVzdWx0ID0gdGhlbmFibGU7XG4gICAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIHZhciBkZWZhdWx0RXhwb3J0ID0gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChkZWZhdWx0RXhwb3J0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuXG5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBSZXNvbHZlZCkge1xuICAgIHJldHVybiBwYXlsb2FkLl9yZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogY3RvclxuICB9O1xuICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0xBWllfVFlQRSxcbiAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7IC8vICRGbG93Rml4TWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgZGVmYXVsdFByb3BzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm9wVHlwZXM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdQcm9wVHlwZXMpIHtcbiAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG4gICAgICAgICAgcHJvcFR5cGVzID0gbmV3UHJvcFR5cGVzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHdhcyBnaXZlbiAlcy4nLCByZW5kZXIgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgcmVuZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbmRlci5sZW5ndGggIT09IDAgJiYgcmVuZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAocmVuZGVyLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZW5kZXIuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IGV4cG9ydHMuUHJvZmlsZXIgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdHJpY3RNb2RlIHx8IHR5cGUgPT09IGV4cG9ydHMuU3VzcGVuc2UgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnRUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgaWYgKHVuc3RhYmxlX29ic2VydmVkQml0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcigndXNlQ29udGV4dCgpIHNlY29uZCBhcmd1bWVudCBpcyByZXNlcnZlZCBmb3IgZnV0dXJlICcgKyAndXNlIGluIFJlYWN0LiBQYXNzaW5nIGl0IGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnWW91IHBhc3NlZDogJXMuJXMnLCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMsIHR5cGVvZiB1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzJdKSA/ICdcXG5cXG5EaWQgeW91IGNhbGwgYXJyYXkubWFwKHVzZUNvbnRleHQpPyAnICsgJ0NhbGxpbmcgSG9va3MgaW5zaWRlIGEgbG9vcCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0xlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyA6ICcnKTtcbiAgICB9IC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LkNvbnN1bWVyKSBpcyBub3Qgc3VwcG9ydGVkLCBtYXkgY2F1c2UgYnVncywgYW5kIHdpbGwgYmUgJyArICdyZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH0gZWxzZSBpZiAocmVhbENvbnRleHQuUHJvdmlkZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMuX19zb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mbztcbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgfVxuXG4gIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMocHJvcHMpO1xuXG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZztcblxuICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAge1xuICAgICAgZXJyb3IoJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG4gICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ1JlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBDb25zaWRlciB1c2luZyBKU1ggJyArICdvciB1c2UgUmVhY3QuY3JlYXRlRWxlbWVudCgpIGRpcmVjdGx5IGluc3RlYWQuJyk7XG4gICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxue1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtmcm96ZW5PYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxudmFyIGNyZWF0ZUVsZW1lbnQkMSA9ICBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiA7XG52YXIgQ2hpbGRyZW4gPSB7XG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG9ubHk6IG9ubHlDaGlsZFxufTtcblxuZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLlB1cmVDb21wb25lbnQgPSBQdXJlQ29tcG9uZW50O1xuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzO1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuZXhwb3J0cy5jcmVhdGVSZWYgPSBjcmVhdGVSZWY7XG5leHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gbGF6eTtcbmV4cG9ydHMubWVtbyA9IG1lbW87XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRWZmZWN0ID0gdXNlRWZmZWN0O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gdXNlSW1wZXJhdGl2ZUhhbmRsZTtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmV4cG9ydCB7IFJlYWN0IH07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICBkZWNvZGVWYWx1ZXM6IHRydWUsXG4gIG1hcDogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IHNldENvb2tpZVZhbHVlLnNwbGl0KFwiO1wiKS5maWx0ZXIoaXNOb25FbXB0eVN0cmluZyk7XG4gIHZhciBuYW1lVmFsdWUgPSBwYXJ0cy5zaGlmdCgpLnNwbGl0KFwiPVwiKTtcbiAgdmFyIG5hbWUgPSBuYW1lVmFsdWUuc2hpZnQoKTtcbiAgdmFyIHZhbHVlID0gbmFtZVZhbHVlLmpvaW4oXCI9XCIpOyAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCA9LCBqb2luZWQgYnkgYSBcIj1cIiBpZiB0aGVyZSB3YXMgbW9yZSB0aGFuIG9uZSBwYXJ0XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIHRyeSB7XG4gICAgdmFsdWUgPSBvcHRpb25zLmRlY29kZVZhbHVlcyA/IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiB2YWx1ZTsgLy8gZGVjb2RlIGNvb2tpZSB2YWx1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgK1xuICAgICAgICB2YWx1ZSArXG4gICAgICAgIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgZVxuICAgICk7XG4gIH1cblxuICB2YXIgY29va2llID0ge1xuICAgIG5hbWU6IG5hbWUsIC8vIGdyYWIgZXZlcnl0aGluZyBiZWZvcmUgdGhlIGZpcnN0ID1cbiAgICB2YWx1ZTogdmFsdWUsXG4gIH07XG5cbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIHZhciBzaWRlcyA9IHBhcnQuc3BsaXQoXCI9XCIpO1xuICAgIHZhciBrZXkgPSBzaWRlcy5zaGlmdCgpLnRyaW1MZWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdmFsdWUgPSBzaWRlcy5qb2luKFwiPVwiKTtcbiAgICBpZiAoa2V5ID09PSBcImV4cGlyZXNcIikge1xuICAgICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwibWF4LWFnZVwiKSB7XG4gICAgICBjb29raWUubWF4QWdlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgY29va2llLnNlY3VyZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaHR0cG9ubHlcIikge1xuICAgICAgY29va2llLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzYW1lc2l0ZVwiKSB7XG4gICAgICBjb29raWUuc2FtZVNpdGUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29va2llW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb29raWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICBpZiAoIWlucHV0KSB7XG4gICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgaWYgKGlucHV0LmhlYWRlcnMgJiYgaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl0pIHtcbiAgICAvLyBmYXN0LXBhdGggZm9yIG5vZGUuanMgKHdoaWNoIGF1dG9tYXRpY2FsbHkgbm9ybWFsaXplcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXItY2FzZVxuICAgIGlucHV0ID0gaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl07XG4gIH0gZWxzZSBpZiAoaW5wdXQuaGVhZGVycykge1xuICAgIC8vIHNsb3ctcGF0aCBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gc2VlICMyNVxuICAgIHZhciBzY2ggPVxuICAgICAgaW5wdXQuaGVhZGVyc1tcbiAgICAgICAgT2JqZWN0LmtleXMoaW5wdXQuaGVhZGVycykuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSBcInNldC1jb29raWVcIjtcbiAgICAgICAgfSlcbiAgICAgIF07XG4gICAgLy8gd2FybiBpZiBjYWxsZWQgb24gYSByZXF1ZXN0LWxpa2Ugb2JqZWN0IHdpdGggYSBjb29raWUgaGVhZGVyIHJhdGhlciB0aGFuIGEgc2V0LWNvb2tpZSBoZWFkZXIgLSBzZWUgIzM0LCAzNlxuICAgIGlmICghc2NoICYmIGlucHV0LmhlYWRlcnMuY29va2llICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIldhcm5pbmc6IHNldC1jb29raWUtcGFyc2VyIGFwcGVhcnMgdG8gaGF2ZSBiZWVuIGNhbGxlZCBvbiBhIHJlcXVlc3Qgb2JqZWN0LiBJdCBpcyBkZXNpZ25lZCB0byBwYXJzZSBTZXQtQ29va2llIGhlYWRlcnMgZnJvbSByZXNwb25zZXMsIG5vdCBDb29raWUgaGVhZGVycyBmcm9tIHJlcXVlc3RzLiBTZXQgdGhlIG9wdGlvbiB7c2lsZW50OiB0cnVlfSB0byBzdXBwcmVzcyB0aGlzIHdhcm5pbmcuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlucHV0ID0gc2NoO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpbnB1dCA9IFtpbnB1dF07XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucylcbiAgICA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG5cbiAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb29raWVzID0ge307XG4gICAgcmV0dXJuIGlucHV0LmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKS5yZWR1Y2UoZnVuY3Rpb24gKGNvb2tpZXMsIHN0cikge1xuICAgICAgdmFyIGNvb2tpZSA9IHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICBjb29raWVzW2Nvb2tpZS5uYW1lXSA9IGNvb2tpZTtcbiAgICAgIHJldHVybiBjb29raWVzO1xuICAgIH0sIGNvb2tpZXMpO1xuICB9XG59XG5cbi8qXG4gIFNldC1Db29raWUgaGVhZGVyIGZpZWxkLXZhbHVlcyBhcmUgc29tZXRpbWVzIGNvbW1hIGpvaW5lZCBpbiBvbmUgc3RyaW5nLiBUaGlzIHNwbGl0cyB0aGVtIHdpdGhvdXQgY2hva2luZyBvbiBjb21tYXNcbiAgdGhhdCBhcmUgd2l0aGluIGEgc2luZ2xlIHNldC1jb29raWUgZmllbGQtdmFsdWUsIHN1Y2ggYXMgaW4gdGhlIEV4cGlyZXMgcG9ydGlvbi5cblxuICBUaGlzIGlzIHVuY29tbW9uLCBidXQgZXhwbGljaXRseSBhbGxvd2VkIC0gc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tNC4yXG4gIE5vZGUuanMgZG9lcyB0aGlzIGZvciBldmVyeSBoZWFkZXIgKmV4Y2VwdCogc2V0LWNvb2tpZSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9kNWUzNjNiNzdlYmFmMWNhZjY3Y2Q3NTI4MjI0YjY1MWM4NjgxNWMxL2xpYi9faHR0cF9pbmNvbWluZy5qcyNMMTI4XG4gIFJlYWN0IE5hdGl2ZSdzIGZldGNoIGRvZXMgdGhpcyBmb3IgKmV2ZXJ5KiBoZWFkZXIsIGluY2x1ZGluZyBzZXQtY29va2llLlxuXG4gIEJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2oyb2JqYy9jb21taXQvMTY4MjBmZGJjOGY3NmNhMGMzMzQ3MjgxMGNlMGNiMDNkMjBlZmUyNVxuICBDcmVkaXRzIHRvOiBodHRwczovL2dpdGh1Yi5jb20vdG9tYmFsbCBmb3Igb3JpZ2luYWwgYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJ1c2FydCBmb3IgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuKi9cbmZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZyhjb29raWVzU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvb2tpZXNTdHJpbmcpKSB7XG4gICAgcmV0dXJuIGNvb2tpZXNTdHJpbmc7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb29raWVzU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gIHZhciBwb3MgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciBjaDtcbiAgdmFyIGxhc3RDb21tYTtcbiAgdmFyIG5leHRTdGFydDtcbiAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcblxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcbiAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgcG9zICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcblxuICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgfVxuXG4gIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgLy8gJywnIGlzIGEgY29va2llIHNlcGFyYXRvciBpZiB3ZSBoYXZlIGxhdGVyIGZpcnN0ICc9Jywgbm90ICc7JyBvciAnLCdcbiAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICBwb3MgKz0gMTtcblxuICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICBuZXh0U3RhcnQgPSBwb3M7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1cnJlbnRseSBzcGVjaWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAvLyB3ZSBmb3VuZCBjb29raWVzIHNlcGFyYXRvclxuICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgLy8gcG9zIGlzIGluc2lkZSB0aGUgbmV4dCBjb29raWUsIHNvIGJhY2sgdXAgYW5kIHJldHVybiBpdC5cbiAgICAgICAgICBwb3MgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW4gcGFyYW0gJywnIG9yIHBhcmFtIHNlcGFyYXRvciAnOycsXG4gICAgICAgICAgLy8gd2UgY29udGludWUgZnJvbSB0aGF0IGNvbW1hXG4gICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBjb29raWVzU3RyaW5nLmxlbmd0aCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb29raWVzU3RyaW5ncztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMuc3BsaXRDb29raWVzU3RyaW5nID0gc3BsaXRDb29raWVzU3RyaW5nO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb2JqZWN0ID0ge307XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGZvck93biA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG5cdGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuXHRcdFx0Y2FsbGJhY2soa2V5LCBvYmplY3Rba2V5XSk7XG5cdFx0fVxuXHR9XG59O1xuXG5jb25zdCBleHRlbmQgPSAoZGVzdGluYXRpb24sIHNvdXJjZSkgPT4ge1xuXHRpZiAoIXNvdXJjZSkge1xuXHRcdHJldHVybiBkZXN0aW5hdGlvbjtcblx0fVxuXHRmb3JPd24oc291cmNlLCAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdGRlc3RpbmF0aW9uW2tleV0gPSB2YWx1ZTtcblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cbmNvbnN0IGZvckVhY2ggPSAoYXJyYXksIGNhbGxiYWNrKSA9PiB7XG5cdGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0bGV0IGluZGV4ID0gLTE7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y2FsbGJhY2soYXJyYXlbaW5kZXhdKTtcblx0fVxufTtcblxuY29uc3QgZm91ckhleEVzY2FwZSA9IChoZXgpID0+IHtcblx0cmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgaGV4KS5zbGljZSgtNCk7XG59XG5cbmNvbnN0IGhleGFkZWNpbWFsID0gKGNvZGUsIGxvd2VyY2FzZSkgPT4ge1xuXHRsZXQgaGV4YWRlY2ltYWwgPSBjb2RlLnRvU3RyaW5nKDE2KTtcblx0aWYgKGxvd2VyY2FzZSkgcmV0dXJuIGhleGFkZWNpbWFsO1xuXHRyZXR1cm4gaGV4YWRlY2ltYWwudG9VcHBlckNhc2UoKTtcbn07XG5cbmNvbnN0IHRvU3RyaW5nID0gb2JqZWN0LnRvU3RyaW5nO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc0J1ZmZlciA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xufTtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG5cdC8vIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsZSBjaGVjaywgYnV0IGl0XHUyMDE5cyBnb29kIGVub3VnaCBmb3Igd2hhdCB3ZSBuZWVkLlxuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59O1xuY29uc3QgaXNTdHJpbmcgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuXHRcdHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcblx0XHR0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbn07XG5jb25zdCBpc01hcCA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTWFwXSc7XG59O1xuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFNldF0nO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjc2luZ2xlXG5jb25zdCBzaW5nbGVFc2NhcGVzID0ge1xuXHQnXFxcXCc6ICdcXFxcXFxcXCcsXG5cdCdcXGInOiAnXFxcXGInLFxuXHQnXFxmJzogJ1xcXFxmJyxcblx0J1xcbic6ICdcXFxcbicsXG5cdCdcXHInOiAnXFxcXHInLFxuXHQnXFx0JzogJ1xcXFx0J1xuXHQvLyBgXFx2YCBpcyBvbWl0dGVkIGludGVudGlvbmFsbHksIGJlY2F1c2UgaW4gSUUgPCA5LCAnXFx2JyA9PSAndicuXG5cdC8vICdcXHYnOiAnXFxcXHgwQidcbn07XG5jb25zdCByZWdleFNpbmdsZUVzY2FwZSA9IC9bXFxcXFxcYlxcZlxcblxcclxcdF0vO1xuXG5jb25zdCByZWdleERpZ2l0ID0gL1swLTldLztcbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZSA9IC9bXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLztcblxuY29uc3QgZXNjYXBlRXZlcnl0aGluZ1JlZ2V4ID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKXwoW1xcdUQ4MDAtXFx1REZGRl0pfChbJ1wiYF0pfFteXS9nO1xuY29uc3QgZXNjYXBlTm9uQXNjaWlSZWdleCA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSl8KFtcXHVEODAwLVxcdURGRkZdKXwoWydcImBdKXxbXiAhIy0mXFwoLVxcW1xcXS1fYS1+XS9nO1xuXG5jb25zdCBqc2VzYyA9IChhcmd1bWVudCwgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBpbmNyZWFzZUluZGVudGF0aW9uID0gKCkgPT4ge1xuXHRcdG9sZEluZGVudCA9IGluZGVudDtcblx0XHQrK29wdGlvbnMuaW5kZW50TGV2ZWw7XG5cdFx0aW5kZW50ID0gb3B0aW9ucy5pbmRlbnQucmVwZWF0KG9wdGlvbnMuaW5kZW50TGV2ZWwpXG5cdH07XG5cdC8vIEhhbmRsZSBvcHRpb25zXG5cdGNvbnN0IGRlZmF1bHRzID0ge1xuXHRcdCdlc2NhcGVFdmVyeXRoaW5nJzogZmFsc2UsXG5cdFx0J21pbmltYWwnOiBmYWxzZSxcblx0XHQnaXNTY3JpcHRDb250ZXh0JzogZmFsc2UsXG5cdFx0J3F1b3Rlcyc6ICdzaW5nbGUnLFxuXHRcdCd3cmFwJzogZmFsc2UsXG5cdFx0J2VzNic6IGZhbHNlLFxuXHRcdCdqc29uJzogZmFsc2UsXG5cdFx0J2NvbXBhY3QnOiB0cnVlLFxuXHRcdCdsb3dlcmNhc2VIZXgnOiBmYWxzZSxcblx0XHQnbnVtYmVycyc6ICdkZWNpbWFsJyxcblx0XHQnaW5kZW50JzogJ1xcdCcsXG5cdFx0J2luZGVudExldmVsJzogMCxcblx0XHQnX19pbmxpbmUxX18nOiBmYWxzZSxcblx0XHQnX19pbmxpbmUyX18nOiBmYWxzZVxuXHR9O1xuXHRjb25zdCBqc29uID0gb3B0aW9ucyAmJiBvcHRpb25zLmpzb247XG5cdGlmIChqc29uKSB7XG5cdFx0ZGVmYXVsdHMucXVvdGVzID0gJ2RvdWJsZSc7XG5cdFx0ZGVmYXVsdHMud3JhcCA9IHRydWU7XG5cdH1cblx0b3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cdGlmIChcblx0XHRvcHRpb25zLnF1b3RlcyAhPSAnc2luZ2xlJyAmJlxuXHRcdG9wdGlvbnMucXVvdGVzICE9ICdkb3VibGUnICYmXG5cdFx0b3B0aW9ucy5xdW90ZXMgIT0gJ2JhY2t0aWNrJ1xuXHQpIHtcblx0XHRvcHRpb25zLnF1b3RlcyA9ICdzaW5nbGUnO1xuXHR9XG5cdGNvbnN0IHF1b3RlID0gb3B0aW9ucy5xdW90ZXMgPT0gJ2RvdWJsZScgP1xuXHRcdCdcIicgOlxuXHRcdChvcHRpb25zLnF1b3RlcyA9PSAnYmFja3RpY2snID9cblx0XHRcdCdgJyA6XG5cdFx0XHQnXFwnJ1xuXHRcdCk7XG5cdGNvbnN0IGNvbXBhY3QgPSBvcHRpb25zLmNvbXBhY3Q7XG5cdGNvbnN0IGxvd2VyY2FzZUhleCA9IG9wdGlvbnMubG93ZXJjYXNlSGV4O1xuXHRsZXQgaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQucmVwZWF0KG9wdGlvbnMuaW5kZW50TGV2ZWwpO1xuXHRsZXQgb2xkSW5kZW50ID0gJyc7XG5cdGNvbnN0IGlubGluZTEgPSBvcHRpb25zLl9faW5saW5lMV9fO1xuXHRjb25zdCBpbmxpbmUyID0gb3B0aW9ucy5fX2lubGluZTJfXztcblx0Y29uc3QgbmV3TGluZSA9IGNvbXBhY3QgPyAnJyA6ICdcXG4nO1xuXHRsZXQgcmVzdWx0O1xuXHRsZXQgaXNFbXB0eSA9IHRydWU7XG5cdGNvbnN0IHVzZUJpbk51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2JpbmFyeSc7XG5cdGNvbnN0IHVzZU9jdE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ29jdGFsJztcblx0Y29uc3QgdXNlRGVjTnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnZGVjaW1hbCc7XG5cdGNvbnN0IHVzZUhleE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2hleGFkZWNpbWFsJztcblxuXHRpZiAoanNvbiAmJiBhcmd1bWVudCAmJiBpc0Z1bmN0aW9uKGFyZ3VtZW50LnRvSlNPTikpIHtcblx0XHRhcmd1bWVudCA9IGFyZ3VtZW50LnRvSlNPTigpO1xuXHR9XG5cblx0aWYgKCFpc1N0cmluZyhhcmd1bWVudCkpIHtcblx0XHRpZiAoaXNNYXAoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoYXJndW1lbnQuc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnbmV3IE1hcCgpJztcblx0XHRcdH1cblx0XHRcdGlmICghY29tcGFjdCkge1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMV9fID0gdHJ1ZTtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTJfXyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICduZXcgTWFwKCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc1NldChhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5zaXplID09IDApIHtcblx0XHRcdFx0cmV0dXJuICduZXcgU2V0KCknO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICduZXcgU2V0KCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc0J1ZmZlcihhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ0J1ZmZlci5mcm9tKFtdKSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ0J1ZmZlci5mcm9tKCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc0FycmF5KGFyZ3VtZW50KSkge1xuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0aWYgKGlubGluZTEpIHtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTFfXyA9IGZhbHNlO1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICghaW5saW5lMikge1xuXHRcdFx0XHRpbmNyZWFzZUluZGVudGF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRmb3JFYWNoKGFyZ3VtZW50LCAodmFsdWUpID0+IHtcblx0XHRcdFx0aXNFbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoaW5saW5lMikge1xuXHRcdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHQoY29tcGFjdCB8fCBpbmxpbmUyID8gJycgOiBpbmRlbnQpICtcblx0XHRcdFx0XHRqc2VzYyh2YWx1ZSwgb3B0aW9ucylcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzRW1wdHkpIHtcblx0XHRcdFx0cmV0dXJuICdbXSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5saW5lMikge1xuXHRcdFx0XHRyZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ1snICsgbmV3TGluZSArIHJlc3VsdC5qb2luKCcsJyArIG5ld0xpbmUpICsgbmV3TGluZSArXG5cdFx0XHRcdChjb21wYWN0ID8gJycgOiBvbGRJbmRlbnQpICsgJ10nO1xuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoanNvbikge1xuXHRcdFx0XHQvLyBTb21lIG51bWJlciB2YWx1ZXMgKGUuZy4gYEluZmluaXR5YCkgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04uXG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlRGVjTnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VIZXhOdW1iZXJzKSB7XG5cdFx0XHRcdGxldCBoZXhhZGVjaW1hbCA9IGFyZ3VtZW50LnRvU3RyaW5nKDE2KTtcblx0XHRcdFx0aWYgKCFsb3dlcmNhc2VIZXgpIHtcblx0XHRcdFx0XHRoZXhhZGVjaW1hbCA9IGhleGFkZWNpbWFsLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICcweCcgKyBoZXhhZGVjaW1hbDtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VCaW5OdW1iZXJzKSB7XG5cdFx0XHRcdHJldHVybiAnMGInICsgYXJndW1lbnQudG9TdHJpbmcoMik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlT2N0TnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gJzBvJyArIGFyZ3VtZW50LnRvU3RyaW5nKDgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzT2JqZWN0KGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGpzb24pIHtcblx0XHRcdFx0Ly8gRm9yIHNvbWUgdmFsdWVzIChlLmcuIGB1bmRlZmluZWRgLCBgZnVuY3Rpb25gIG9iamVjdHMpLFxuXHRcdFx0XHQvLyBgSlNPTi5zdHJpbmdpZnkodmFsdWUpYCByZXR1cm5zIGB1bmRlZmluZWRgICh3aGljaCBpc25cdTIwMTl0IHZhbGlkXG5cdFx0XHRcdC8vIEpTT04pIGluc3RlYWQgb2YgYCdudWxsJ2AuXG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudCkgfHwgJ251bGwnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdFx0fSBlbHNlIHsgLy8gaXRcdTIwMTlzIGFuIG9iamVjdFxuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0aW5jcmVhc2VJbmRlbnRhdGlvbigpO1xuXHRcdFx0Zm9yT3duKGFyZ3VtZW50LCAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpc0VtcHR5ID0gZmFsc2U7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdChjb21wYWN0ID8gJycgOiBpbmRlbnQpICtcblx0XHRcdFx0XHRqc2VzYyhrZXksIG9wdGlvbnMpICsgJzonICtcblx0XHRcdFx0XHQoY29tcGFjdCA/ICcnIDogJyAnKSArXG5cdFx0XHRcdFx0anNlc2ModmFsdWUsIG9wdGlvbnMpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0VtcHR5KSB7XG5cdFx0XHRcdHJldHVybiAne30nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICd7JyArIG5ld0xpbmUgKyByZXN1bHQuam9pbignLCcgKyBuZXdMaW5lKSArIG5ld0xpbmUgK1xuXHRcdFx0XHQoY29tcGFjdCA/ICcnIDogb2xkSW5kZW50KSArICd9Jztcblx0XHR9XG5cdH1cblxuXHRjb25zdCByZWdleCA9IG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZyA/IGVzY2FwZUV2ZXJ5dGhpbmdSZWdleCA6IGVzY2FwZU5vbkFzY2lpUmVnZXg7XG5cdHJlc3VsdCA9IGFyZ3VtZW50LnJlcGxhY2UocmVnZXgsIChjaGFyLCBwYWlyLCBsb25lLCBxdW90ZUNoYXIsIGluZGV4LCBzdHJpbmcpID0+IHtcblx0XHRpZiAocGFpcikge1xuXHRcdFx0aWYgKG9wdGlvbnMubWluaW1hbCkgcmV0dXJuIHBhaXI7XG5cdFx0XHRjb25zdCBmaXJzdCA9IHBhaXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdGNvbnN0IHNlY29uZCA9IHBhaXIuY2hhckNvZGVBdCgxKTtcblx0XHRcdGlmIChvcHRpb25zLmVzNikge1xuXHRcdFx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0XHRcdFx0Y29uc3QgY29kZVBvaW50ID0gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcblx0XHRcdFx0Y29uc3QgaGV4ID0gaGV4YWRlY2ltYWwoY29kZVBvaW50LCBsb3dlcmNhc2VIZXgpO1xuXHRcdFx0XHRyZXR1cm4gJ1xcXFx1eycgKyBoZXggKyAnfSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXhhZGVjaW1hbChmaXJzdCwgbG93ZXJjYXNlSGV4KSkgKyBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKHNlY29uZCwgbG93ZXJjYXNlSGV4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxvbmUpIHtcblx0XHRcdHJldHVybiBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKGxvbmUuY2hhckNvZGVBdCgwKSwgbG93ZXJjYXNlSGV4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0Y2hhciA9PSAnXFwwJyAmJlxuXHRcdFx0IWpzb24gJiZcblx0XHRcdCFyZWdleERpZ2l0LnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCArIDEpKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuICdcXFxcMCc7XG5cdFx0fVxuXG5cdFx0aWYgKHF1b3RlQ2hhcikge1xuXHRcdFx0aWYgKHF1b3RlQ2hhciA9PSBxdW90ZSB8fCBvcHRpb25zLmVzY2FwZUV2ZXJ5dGhpbmcpIHtcblx0XHRcdFx0cmV0dXJuICdcXFxcJyArIHF1b3RlQ2hhcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBxdW90ZUNoYXI7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ2V4U2luZ2xlRXNjYXBlLnRlc3QoY2hhcikpIHtcblx0XHRcdC8vIG5vIG5lZWQgZm9yIGEgYGhhc093blByb3BlcnR5YCBjaGVjayBoZXJlXG5cdFx0XHRyZXR1cm4gc2luZ2xlRXNjYXBlc1tjaGFyXTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5taW5pbWFsICYmICFyZWdleFdoaXRlc3BhY2UudGVzdChjaGFyKSkge1xuXHRcdFx0cmV0dXJuIGNoYXI7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGV4ID0gaGV4YWRlY2ltYWwoY2hhci5jaGFyQ29kZUF0KDApLCBsb3dlcmNhc2VIZXgpO1xuXHRcdGlmIChqc29uIHx8IGhleC5sZW5ndGggPiAyKSB7XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBoZXgpLnNsaWNlKC0yKTtcblx0fSk7XG5cblx0aWYgKHF1b3RlID09ICdgJykge1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXCRcXHsvZywgJ1xcXFwkeycpO1xuXHR9XG5cdGlmIChvcHRpb25zLmlzU2NyaXB0Q29udGV4dCkge1xuXHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9ldGFnb1xuXHRcdHJlc3VsdCA9IHJlc3VsdFxuXHRcdFx0LnJlcGxhY2UoLzxcXC8oc2NyaXB0fHN0eWxlKS9naSwgJzxcXFxcLyQxJylcblx0XHRcdC5yZXBsYWNlKC88IS0tL2csIGpzb24gPyAnXFxcXHUwMDNDIS0tJyA6ICdcXFxceDNDIS0tJyk7XG5cdH1cblx0aWYgKG9wdGlvbnMud3JhcCkge1xuXHRcdHJlc3VsdCA9IHF1b3RlICsgcmVzdWx0ICsgcXVvdGU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmpzZXNjLnZlcnNpb24gPSAnMy4wLjInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzZXNjO1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIGRvbWFpbjtcblxuLy8gVGhpcyBjb25zdHJ1Y3RvciBpcyB1c2VkIHRvIHN0b3JlIGV2ZW50IGhhbmRsZXJzLiBJbnN0YW50aWF0aW5nIHRoaXMgaXNcbi8vIGZhc3RlciB0aGFuIGV4cGxpY2l0bHkgY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgdG8gZ2V0IGEgXCJjbGVhblwiIGVtcHR5XG4vLyBvYmplY3QgKHRlc3RlZCB3aXRoIHY4IHY0LjkpLlxuZnVuY3Rpb24gRXZlbnRIYW5kbGVycygpIHt9XG5FdmVudEhhbmRsZXJzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlcjtcbmV4cG9ydCB7RXZlbnRFbWl0dGVyfTtcblxuLy8gbm9kZWpzIG9kZGl0eVxuLy8gcmVxdWlyZSgnZXZlbnRzJykgPT09IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlclxuXG5FdmVudEVtaXR0ZXIudXNpbmdEb21haW5zID0gZmFsc2U7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZG9tYWluID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRvbWFpbiA9IG51bGw7XG4gIGlmIChFdmVudEVtaXR0ZXIudXNpbmdEb21haW5zKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIGRvbWFpbiwgdGhlbiBhdHRhY2ggdG8gaXQuXG4gICAgaWYgKGRvbWFpbi5hY3RpdmUgJiYgISh0aGlzIGluc3RhbmNlb2YgZG9tYWluLkRvbWFpbikpIHtcbiAgICAgIHRoaXMuZG9tYWluID0gZG9tYWluLmFjdGl2ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzLCBkb21haW47XG4gIHZhciBuZWVkRG9tYWluRXhpdCA9IGZhbHNlO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGRvbWFpbiA9IHRoaXMuZG9tYWluO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZG9tYWluKSB7XG4gICAgICBpZiAoIWVyKVxuICAgICAgICBlciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudCcpO1xuICAgICAgZXIuZG9tYWluRW1pdHRlciA9IHRoaXM7XG4gICAgICBlci5kb21haW4gPSBkb21haW47XG4gICAgICBlci5kb21haW5UaHJvd24gPSBmYWxzZTtcbiAgICAgIGRvbWFpbi5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICBpZiAobmVlZERvbWFpbkV4aXQpXG4gICAgZG9tYWluLmV4aXQoKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyB0eXBlICsgJyBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBlbWl0V2FybmluZyh3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZW1pdFdhcm5pbmcoZSkge1xuICB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nID8gY29uc29sZS53YXJuKGUpIDogY29uc29sZS5sb2coZSk7XG59XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBnKCkge1xuICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgcmV0dXJuIGc7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IChsaXN0Lmxpc3RlbmVyICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbGlzdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5OyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9IHdoaWxlIChsaXN0ZW5lcnNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHZhciBldmxpc3RlbmVyO1xuICB2YXIgcmV0O1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIHtcbiAgICBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICghZXZsaXN0ZW5lcilcbiAgICAgIHJldCA9IFtdO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgcmV0ID0gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl07XG4gICAgZWxzZVxuICAgICAgcmV0ID0gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIGkpIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCAiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG4vLyBiYXNlZCBvZmYgaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS1wcm9jZXNzL2Jsb2IvbWFzdGVyL2Jyb3dzZXIuanNcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG52YXIgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbmlmICh0eXBlb2YgZ2xvYmFsLnNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbn1cbmlmICh0eXBlb2YgZ2xvYmFsLmNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbn1cblxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuZnVuY3Rpb24gbmV4dFRpY2soZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn1cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG52YXIgdGl0bGUgPSAnYnJvd3Nlcic7XG52YXIgcGxhdGZvcm0gPSAnYnJvd3Nlcic7XG52YXIgYnJvd3NlciA9IHRydWU7XG52YXIgZW52ID0ge307XG52YXIgYXJndiA9IFtdO1xudmFyIHZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnZhciB2ZXJzaW9ucyA9IHt9O1xudmFyIHJlbGVhc2UgPSB7fTtcbnZhciBjb25maWcgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBvbiA9IG5vb3A7XG52YXIgYWRkTGlzdGVuZXIgPSBub29wO1xudmFyIG9uY2UgPSBub29wO1xudmFyIG9mZiA9IG5vb3A7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBub29wO1xudmFyIHJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG52YXIgZW1pdCA9IG5vb3A7XG5cbmZ1bmN0aW9uIGJpbmRpbmcobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuZnVuY3Rpb24gY3dkICgpIHsgcmV0dXJuICcvJyB9XG5mdW5jdGlvbiBjaGRpciAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1mdW5jdGlvbiB1bWFzaygpIHsgcmV0dXJuIDA7IH1cblxuLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3VtYXZpcy9icm93c2VyLXByb2Nlc3MtaHJ0aW1lL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG52YXIgcGVyZm9ybWFuY2UgPSBnbG9iYWwucGVyZm9ybWFuY2UgfHwge307XG52YXIgcGVyZm9ybWFuY2VOb3cgPVxuICBwZXJmb3JtYW5jZS5ub3cgICAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1vek5vdyAgICAgfHxcbiAgcGVyZm9ybWFuY2UubXNOb3cgICAgICB8fFxuICBwZXJmb3JtYW5jZS5vTm93ICAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLndlYmtpdE5vdyAgfHxcbiAgZnVuY3Rpb24oKXsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgfTtcblxuLy8gZ2VuZXJhdGUgdGltZXN0YW1wIG9yIGRlbHRhXG4vLyBzZWUgaHR0cDovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfaHJ0aW1lXG5mdW5jdGlvbiBocnRpbWUocHJldmlvdXNUaW1lc3RhbXApe1xuICB2YXIgY2xvY2t0aW1lID0gcGVyZm9ybWFuY2VOb3cuY2FsbChwZXJmb3JtYW5jZSkqMWUtMztcbiAgdmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKGNsb2NrdGltZSk7XG4gIHZhciBuYW5vc2Vjb25kcyA9IE1hdGguZmxvb3IoKGNsb2NrdGltZSUxKSoxZTkpO1xuICBpZiAocHJldmlvdXNUaW1lc3RhbXApIHtcbiAgICBzZWNvbmRzID0gc2Vjb25kcyAtIHByZXZpb3VzVGltZXN0YW1wWzBdO1xuICAgIG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFsxXTtcbiAgICBpZiAobmFub3NlY29uZHM8MCkge1xuICAgICAgc2Vjb25kcy0tO1xuICAgICAgbmFub3NlY29uZHMgKz0gMWU5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3NlY29uZHMsbmFub3NlY29uZHNdXG59XG5cbnZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuZnVuY3Rpb24gdXB0aW1lKCkge1xuICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICB2YXIgZGlmID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gIHJldHVybiBkaWYgLyAxMDAwO1xufVxuXG52YXIgYnJvd3NlciQxID0ge1xuICBuZXh0VGljazogbmV4dFRpY2ssXG4gIHRpdGxlOiB0aXRsZSxcbiAgYnJvd3NlcjogYnJvd3NlcixcbiAgZW52OiBlbnYsXG4gIGFyZ3Y6IGFyZ3YsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIHZlcnNpb25zOiB2ZXJzaW9ucyxcbiAgb246IG9uLFxuICBhZGRMaXN0ZW5lcjogYWRkTGlzdGVuZXIsXG4gIG9uY2U6IG9uY2UsXG4gIG9mZjogb2ZmLFxuICByZW1vdmVMaXN0ZW5lcjogcmVtb3ZlTGlzdGVuZXIsXG4gIHJlbW92ZUFsbExpc3RlbmVyczogcmVtb3ZlQWxsTGlzdGVuZXJzLFxuICBlbWl0OiBlbWl0LFxuICBiaW5kaW5nOiBiaW5kaW5nLFxuICBjd2Q6IGN3ZCxcbiAgY2hkaXI6IGNoZGlyLFxuICB1bWFzazogdW1hc2ssXG4gIGhydGltZTogaHJ0aW1lLFxuICBwbGF0Zm9ybTogcGxhdGZvcm0sXG4gIHJlbGVhc2U6IHJlbGVhc2UsXG4gIGNvbmZpZzogY29uZmlnLFxuICB1cHRpbWU6IHVwdGltZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYnJvd3NlciQxO1xuZXhwb3J0IHsgYWRkTGlzdGVuZXIsIGFyZ3YsIGJpbmRpbmcsIGJyb3dzZXIsIGNoZGlyLCBjb25maWcsIGN3ZCwgZW1pdCwgZW52LCBocnRpbWUsIG5leHRUaWNrLCBvZmYsIG9uLCBvbmNlLCBwbGF0Zm9ybSwgcmVsZWFzZSwgcmVtb3ZlQWxsTGlzdGVuZXJzLCByZW1vdmVMaXN0ZW5lciwgdGl0bGUsIHVtYXNrLCB1cHRpbWUsIHZlcnNpb24sIHZlcnNpb25zIH07XG4iLCAiXG52YXIgaW5oZXJpdHM7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpe1xuICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICBpbmhlcml0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBpbmhlcml0cztcbiIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCBwcm9jZXNzIGZyb20gJ3Byb2Nlc3MnO1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnbG9nKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IDA7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBpbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlcihtYXliZUJ1Zikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG1heWJlQnVmKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0IGZ1bmN0aW9uIGxvZygpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xufVxuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnLi9pbmhlcml0cyc7XG5leHBvcnQge2luaGVyaXRzfVxuXG5leHBvcnQgZnVuY3Rpb24gX2V4dGVuZChvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbmhlcml0czogaW5oZXJpdHMsXG4gIF9leHRlbmQ6IF9leHRlbmQsXG4gIGxvZzogbG9nLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNFcnJvcjogaXNFcnJvcixcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNSZWdFeHA6IGlzUmVnRXhwLFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzU3ltYm9sOiBpc1N5bWJvbCxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBpc051bGxPclVuZGVmaW5lZCxcbiAgaXNOdWxsOiBpc051bGwsXG4gIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICBpc0FycmF5OiBpc0FycmF5LFxuICBpbnNwZWN0OiBpbnNwZWN0LFxuICBkZXByZWNhdGU6IGRlcHJlY2F0ZSxcbiAgZm9ybWF0OiBmb3JtYXQsXG4gIGRlYnVnbG9nOiBkZWJ1Z2xvZ1xufVxuIiwgInZhciBsb29rdXAgPSBbXTtcbnZhciByZXZMb29rdXAgPSBbXTtcbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG52YXIgaW5pdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgaW5pdGVkID0gdHJ1ZTtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2Mztcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICBpZiAoIWluaXRlZCkge1xuICAgIGluaXQoKTtcbiAgfVxuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7XG5cbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuO1xuXG4gIHZhciBMID0gMDtcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMik7XG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcDtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSk7XG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIHRtcDtcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MzsgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSk7XG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl07XG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl07XG4gICAgb3V0cHV0ICs9ICc9PSc7XG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSk7XG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPSc7XG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dCk7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIHJlYWQgKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG07XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSAtNztcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMDtcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGM7XG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApO1xuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpO1xuICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn1cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHJ1ZTtcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xudmFyIF9rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpO1xuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyOyAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgcmV0dXJuIGFyclxufTtcblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59O1xuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZTtcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufTtcblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKTtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn07XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDA7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKTtcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbCk7XG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTU7XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGg7IC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5O1xuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKTtcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pO1xuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwO1xuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cbkJ1ZmZlci5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuZnVuY3Rpb24gaW50ZXJuYWxJc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpO1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXJcbn07XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDA7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dO1xuICBiW25dID0gYlttXTtcbiAgYlttXSA9IGk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMik7XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSk7XG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICc7XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDtcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwO1xuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwO1xuICBlbmQgPj4+PSAwO1xuICB0aGlzU3RhcnQgPj4+PSAwO1xuICB0aGlzRW5kID4+Pj0gMDtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcbiAgdmFyIHkgPSBlbmQgLSBzdGFydDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpO1xuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTtcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldO1xuICAgICAgeSA9IHRhcmdldENvcHlbaV07XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn07XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMDtcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDtcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7XG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkY7IC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDE7XG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDI7XG4gICAgICBhcnJMZW5ndGggLz0gMjtcbiAgICAgIHZhbExlbmd0aCAvPSAyO1xuICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGk7XG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufTtcblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIG9mZnNldCA9IDA7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDA7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufTtcblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICB2YXIgcmVzID0gW107XG5cbiAgdmFyIGkgPSBzdGFydDtcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldO1xuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsO1xuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMTtcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRik7XG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRjtcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZTtcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJyc7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJztcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgc3RhcnQgPSB+fnN0YXJ0O1xuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW47XG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW47XG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICB2YXIgbmV3QnVmO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufTtcblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF07XG4gIHZhciBtdWwgPSAxO1xuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsO1xuICB9XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzW29mZnNldF1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gIH1cbiAgbXVsICo9IDB4ODA7XG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG5cbiAgcmV0dXJuIHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGg7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldO1xuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKTtcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpO1xuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgfVxuXG4gIHZhciBtdWwgPSAxO1xuICB2YXIgaSA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKTtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAxXG59O1xuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4O1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgc3ViID0gMDtcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gIHZhciBtdWwgPSAxO1xuICB2YXIgc3ViID0gMDtcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDE7XG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAxXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZik7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgfVxuICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufTtcblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCk7XG4gIH1cbiAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDA7XG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICB2YXIgaTtcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGxlblxufTtcblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NTtcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDtcblxuICBpZiAoIXZhbCkgdmFsID0gMDtcblxuICB2YXIgaTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gaW50ZXJuYWxJc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpO1xuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59O1xuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZztcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKTtcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5O1xuICB2YXIgY29kZVBvaW50O1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbDtcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsbztcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhpID0gYyA+PiA4O1xuICAgIGxvID0gYyAlIDI1NjtcbiAgICBieXRlQXJyYXkucHVzaChsbyk7XG4gICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gdG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuLy8gdGhlIGZvbGxvd2luZyBpcyBmcm9tIGlzLWJ1ZmZlciwgYWxzbyBieSBGZXJvc3MgQWJvdWtoYWRpamVoIGFuZCB3aXRoIHNhbWUgbGlzZW5jZVxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoISFvYmouX2lzQnVmZmVyIHx8IGlzRmFzdEJ1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopKVxufVxuXG5mdW5jdGlvbiBpc0Zhc3RCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Zhc3RCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5leHBvcnQgeyBCdWZmZXIsIElOU1BFQ1RfTUFYX0JZVEVTLCBTbG93QnVmZmVyLCBpc0J1ZmZlciwgX2tNYXhMZW5ndGggYXMga01heExlbmd0aCB9O1xuIiwgImltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJMaXN0O1xuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgLS10aGlzLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gIH1yZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKHApIHtcbiAgICBwLmRhdGEuY29weShyZXQsIGkpO1xuICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuIiwgIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG5leHBvcnQgZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7aW5oZXJpdHMsIGRlYnVnbG9nfSBmcm9tICd1dGlsJztcbmltcG9ydCBCdWZmZXJMaXN0IGZyb20gJy4vYnVmZmVyLWxpc3QnO1xuaW1wb3J0IHtTdHJpbmdEZWNvZGVyfSBmcm9tICdzdHJpbmdfZGVjb2Rlcic7XG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5cbnZhciBkZWJ1ZyA9IGRlYnVnbG9nKCdzdHJlYW0nKTtcbmluaGVyaXRzKFJlYWRhYmxlLCBFdmVudEVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pXG4gICAgICBlbWl0dGVyLm9uKGV2ZW50LCBmbik7XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSlcbiAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7XG4gICAgZWxzZVxuICAgICAgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQgKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgUmVhZGFibGU7XG5leHBvcnQgZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIG5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBuZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgbmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKGxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgc3JjLmxpc3RlbmVycygnZGF0YScpLmxlbmd0aCkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBuZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgbmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwgIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuXG5pbXBvcnQge2luaGVyaXRzLCBkZXByZWNhdGV9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbmltcG9ydCB7RXZlbnRFbWl0dGVyfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vZHVwbGV4JztcbmltcG9ydCB7bmV4dFRpY2t9IGZyb20gJ3Byb2Nlc3MnO1xuaW5oZXJpdHMoV3JpdGFibGUsIEV2ZW50RW1pdHRlcik7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7XG4gICAgZ2V0OiBkZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nKVxuICB9KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgV3JpdGFibGU7XG5leHBvcnQgZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIG5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG4gIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxuICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3dcbiAgLy8gaWYgaXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBuZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIG5leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgICAgbmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBuZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn1cbiIsICJcbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHtuZXh0VGlja30gZnJvbSAncHJvY2Vzcyc7XG5pbXBvcnQge1JlYWRhYmxlfSBmcm9tICcuL3JlYWRhYmxlJztcbmltcG9ydCB7V3JpdGFibGV9IGZyb20gJy4vd3JpdGFibGUnO1xuXG5cbmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IE9iamVjdC5rZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cbmV4cG9ydCBkZWZhdWx0IER1cGxleDtcbmV4cG9ydCBmdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBuZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG4iLCAiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5cbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL2R1cGxleCc7XG5cblxuaW1wb3J0IHtpbmhlcml0c30gZnJvbSAndXRpbCc7XG5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFRyYW5zZm9ybTtcbmV4cG9ydCBmdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsICJcbmltcG9ydCB7VHJhbnNmb3JtfSBmcm9tICcuL3RyYW5zZm9ybSc7XG5cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5leHBvcnQgZGVmYXVsdCBQYXNzVGhyb3VnaDtcbmV4cG9ydCBmdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcbiIsICJpbXBvcnQgRUUgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJztcbmltcG9ydCB7UmVhZGFibGV9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJztcbmltcG9ydCB7V3JpdGFibGV9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJztcbmltcG9ydCB7VHJhbnNmb3JtfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtQYXNzVGhyb3VnaH0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnO1xuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSBSZWFkYWJsZTtcblN0cmVhbS5Xcml0YWJsZSA9IFdyaXRhYmxlO1xuU3RyZWFtLkR1cGxleCA9IER1cGxleDtcblN0cmVhbS5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSBQYXNzVGhyb3VnaDtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cbmV4cG9ydCBkZWZhdWx0IFN0cmVhbTtcbmV4cG9ydCB7UmVhZGFibGUsV3JpdGFibGUsRHVwbGV4LFRyYW5zZm9ybSxQYXNzVGhyb3VnaCxTdHJlYW19XG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCAiXG5jb25zdCBwb2x5ZmlsbCA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbmlmIChwb2x5ZmlsbCAmJiBwb2x5ZmlsbC5kZWZhdWx0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbC5kZWZhdWx0XG4gICAgZm9yIChsZXQgayBpbiBwb2x5ZmlsbCkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0c1trXSA9IHBvbHlmaWxsW2tdXG4gICAgfVxufSBlbHNlIGlmIChwb2x5ZmlsbCkgIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsXG59XG5cblxuIiwgIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjInO1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscyB3aXRoXG4vLyB0ZW1wbGF0ZSBsaXRlcmFsIHN0cmluZ3MuIFRoZSBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgY29kZXNcbi8vIGR1cmluZyBidWlsZC5cbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICB2YXIgdXJsID0gJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdXJsICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBcIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIiArIGNvZGUgKyBcIjsgdmlzaXQgXCIgKyB1cmwgKyBcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciBcIiArICd1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsICcgKyAnaGVscGZ1bCB3YXJuaW5ncy4nO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlciA9IGZhbHNlO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG5cbntcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xufVxuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCkge1xuICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICB2YXIgbWFza2VkQ29udGV4dCA9IHt9O1xuXG4gIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gIH1cblxuICByZXR1cm4gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XG4gIHtcbiAgICBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sICdDb21wb25lbnQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpIHtcbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBlbm91Z2ggc2xvdHMgaW4gdGhpcyBjb250ZXh0IHRvIHN0b3JlIHRoaXMgdGhyZWFkSUQsXG4gIC8vIGZpbGwgaXQgaW4gd2l0aG91dCBsZWF2aW5nIGFueSBob2xlcyB0byBlbnN1cmUgdGhhdCB0aGUgVk0gb3B0aW1pemVzXG4gIC8vIHRoaXMgYXMgbm9uLWhvbGV5IGluZGV4IHByb3BlcnRpZXMuXG4gIC8vIChOb3RlOiBJZiBgcmVhY3RgIHBhY2thZ2UgaXMgPCAxNi42LCBfdGhyZWFkQ291bnQgaXMgdW5kZWZpbmVkLilcbiAgZm9yICh2YXIgaSA9IGNvbnRleHQuX3RocmVhZENvdW50IHwgMDsgaSA8PSB0aHJlYWRJRDsgaSsrKSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgZGVmYXVsdFZhbHVlIHdoaWNoIG1pZ2h0IG5vdCBiZVxuICAgIC8vIHRydWUgaWYgd2UncmUgcmVuZGVyaW5nIGluc2lkZSBhIHNlY29uZGFyeSByZW5kZXJlciBidXQgdGhleSBhcmVcbiAgICAvLyBzZWNvbmRhcnkgYmVjYXVzZSB0aGVzZSB1c2UgY2FzZXMgYXJlIHZlcnkgcmFyZS5cbiAgICBjb250ZXh0W2ldID0gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IGkgKyAxO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29udGV4dCh0eXBlLCBjb250ZXh0LCB0aHJlYWRJRCwgaXNDbGFzcykge1xuICBpZiAoaXNDbGFzcykge1xuICAgIHZhciBjb250ZXh0VHlwZSA9IHR5cGUuY29udGV4dFR5cGU7XG5cbiAgICB7XG4gICAgICBpZiAoJ2NvbnRleHRUeXBlJyBpbiB0eXBlKSB7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gLy8gQWxsb3cgbnVsbCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25cbiAgICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyh0eXBlKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQodHlwZSk7XG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcgKyAnVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gJyArICdUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnICsgJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gPENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0VHlwZSwgdGhyZWFkSUQpO1xuICAgICAgcmV0dXJuIGNvbnRleHRUeXBlW3RocmVhZElEXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbWFza2VkQ29udGV4dCA9IG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIGNoZWNrQ29udGV4dFR5cGVzKHR5cGUuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB2YXIgX21hc2tlZENvbnRleHQgPSBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICBjaGVja0NvbnRleHRUeXBlcyh0eXBlLmNvbnRleHRUeXBlcywgX21hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9tYXNrZWRDb250ZXh0O1xuICAgIH1cbiAgfVxufVxuXG52YXIgbmV4dEF2YWlsYWJsZVRocmVhZElEcyA9IG5ldyBVaW50MTZBcnJheSgxNik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW2ldID0gaSArIDE7XG59XG5cbm5leHRBdmFpbGFibGVUaHJlYWRJRHNbMTVdID0gMDtcblxuZnVuY3Rpb24gZ3Jvd1RocmVhZENvdW50QW5kUmV0dXJuTmV4dEF2YWlsYWJsZSgpIHtcbiAgdmFyIG9sZEFycmF5ID0gbmV4dEF2YWlsYWJsZVRocmVhZElEcztcbiAgdmFyIG9sZFNpemUgPSBvbGRBcnJheS5sZW5ndGg7XG4gIHZhciBuZXdTaXplID0gb2xkU2l6ZSAqIDI7XG5cbiAgaWYgKCEobmV3U2l6ZSA8PSAweDEwMDAwKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIk1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgUmVhY3QgcmVuZGVyZXJzIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBub3QgcHJvcGVybHkgZGVzdHJveWluZyB0aGUgUmVhZGFibGUgcHJvdmlkZWQgYnkgUmVhY3QuIEVuc3VyZSB0aGF0IHlvdSBjYWxsIC5kZXN0cm95KCkgb24gaXQgaWYgeW91IG5vIGxvbmdlciB3YW50IHRvIHJlYWQgZnJvbSBpdCwgYW5kIGRpZCBub3QgcmVhZCB0byB0aGUgZW5kLiBJZiB5b3UgdXNlIC5waXBlKCkgdGhpcyBzaG91bGQgYmUgYXV0b21hdGljLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQxNkFycmF5KG5ld1NpemUpO1xuICBuZXdBcnJheS5zZXQob2xkQXJyYXkpO1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzID0gbmV3QXJyYXk7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBvbGRTaXplICsgMTtcblxuICBmb3IgKHZhciBfaSA9IG9sZFNpemU7IF9pIDwgbmV3U2l6ZSAtIDE7IF9pKyspIHtcbiAgICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW19pXSA9IF9pICsgMTtcbiAgfVxuXG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbbmV3U2l6ZSAtIDFdID0gMDtcbiAgcmV0dXJuIG9sZFNpemU7XG59XG5cbmZ1bmN0aW9uIGFsbG9jVGhyZWFkSUQoKSB7XG4gIHZhciBuZXh0SUQgPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdO1xuXG4gIGlmIChuZXh0SUQgPT09IDApIHtcbiAgICByZXR1cm4gZ3Jvd1RocmVhZENvdW50QW5kUmV0dXJuTmV4dEF2YWlsYWJsZSgpO1xuICB9XG5cbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbbmV4dElEXTtcbiAgcmV0dXJuIG5leHRJRDtcbn1cbmZ1bmN0aW9uIGZyZWVUaHJlYWRJRChpZCkge1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW2lkXSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF07XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBpZDtcbn1cblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwOyAvLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgZmlsdGVyIGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cblxudmFyIFNUUklORyA9IDE7IC8vIEEgc3RyaW5nIGF0dHJpYnV0ZSB0aGF0IGFjY2VwdHMgYm9vbGVhbnMgaW4gUmVhY3QuIEluIEhUTUwsIHRoZXNlIGFyZSBjYWxsZWRcbi8vIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgd2l0aCBcInRydWVcIiBhbmQgXCJmYWxzZVwiIGFzIHBvc3NpYmxlIHZhbHVlcy5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwidHJ1ZVwiIHN0cmluZy5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcImZhbHNlXCIgc3RyaW5nLlxuXG52YXIgQk9PTEVBTklTSF9TVFJJTkcgPSAyOyAvLyBBIHJlYWwgYm9vbGVhbiBhdHRyaWJ1dGUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cblxudmFyIEJPT0xFQU4gPSAzOyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cblxudmFyIE9WRVJMT0FERURfQk9PTEVBTiA9IDQ7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIE5VTUVSSUMgPSA1OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG52YXIgUk9PVF9BVFRSSUJVVEVfTkFNRSA9ICdkYXRhLXJlYWN0cm9vdCc7XG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuXG4gIHtcbiAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQ7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6IC8vICRGbG93SXNzdWUgc3ltYm9sIGlzIHBlcmZlY3RseSB2YWxpZCBoZXJlXG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAhcHJvcGVydHlJbmZvLmFjY2VwdHNCb29sZWFucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgIHJldHVybiBwcmVmaXggIT09ICdkYXRhLScgJiYgcHJlZml4ICE9PSAnYXJpYS0nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcblxuICAgIHN3aXRjaCAocHJvcGVydHlJbmZvLnR5cGUpIHtcbiAgICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcblxuICAgICAgY2FzZSBPVkVSTE9BREVEX0JPT0xFQU46XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG5cbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKTtcblxuICAgICAgY2FzZSBQT1NJVElWRV9OVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSkge1xuICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgdHlwZSwgbXVzdFVzZVByb3BlcnR5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVOYW1lc3BhY2UsIHNhbml0aXplVVJMLCByZW1vdmVFbXB0eVN0cmluZykge1xuICB0aGlzLmFjY2VwdHNCb29sZWFucyA9IHR5cGUgPT09IEJPT0xFQU5JU0hfU1RSSU5HIHx8IHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICB0aGlzLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgdGhpcy5tdXN0VXNlUHJvcGVydHkgPSBtdXN0VXNlUHJvcGVydHk7XG4gIHRoaXMucHJvcGVydHlOYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zYW5pdGl6ZVVSTCA9IHNhbml0aXplVVJMO1xuICB0aGlzLnJlbW92ZUVtcHR5U3RyaW5nID0gcmVtb3ZlRW1wdHlTdHJpbmc7XG59IC8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbi8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4vLyBuYW1lIHdhcm5pbmdzLlxuXG5cbnZhciBwcm9wZXJ0aWVzID0ge307IC8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuXG52YXIgcmVzZXJ2ZWRQcm9wcyA9IFsnY2hpbGRyZW4nLCAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLCAvLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnLCAnaW5uZXJIVE1MJywgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLCAnc3R5bGUnXTtcbnJlc2VydmVkUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuXG5bWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnY2xhc3NOYW1lJywgJ2NsYXNzJ10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmWzFdO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblxuWydhdXRvUmV2ZXJzZScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZvY3VzYWJsZScsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcy5cblxuWydhbGxvd0Z1bGxTY3JlZW4nLCAnYXN5bmMnLCAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywgJ2F1dG9QbGF5JywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLCAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJywgJ2Zvcm1Ob1ZhbGlkYXRlJywgJ2hpZGRlbicsICdsb29wJywgJ25vTW9kdWxlJywgJ25vVmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c0lubGluZScsICdyZWFkT25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzY29wZWQnLCAnc2VhbWxlc3MnLCAvLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuXG5bJ2NoZWNrZWQnLCAvLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywgJ211dGVkJywgJ3NlbGVjdGVkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCB0cnVlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblxuWydjYXB0dXJlJywgJ2Rvd25sb2FkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBPVkVSTE9BREVEX0JPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuXG5bJ2NvbHMnLCAncm93cycsICdzaXplJywgJ3NwYW4nIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFBPU0lUSVZFX05VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuXG5bJ3Jvd1NwYW4nLCAnc3RhcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE5VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7XG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG5cbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xufTsgLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZywgbmFtZXNwYWNpbmcsXG4vLyBvciBib29sZWFuIHZhbHVlIGFzc2lnbm1lbnQuIFJlZ3VsYXIgYXR0cmlidXRlcyB0aGF0IGp1c3QgYWNjZXB0IHN0cmluZ3Ncbi8vIGFuZCBoYXZlIHRoZSBzYW1lIG5hbWVzIGFyZSBvbWl0dGVkLCBqdXN0IGxpa2UgaW4gdGhlIEhUTUwgYXR0cmlidXRlIGZpbHRlci5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwaW5nIHRoZSBNRE4gZG9jdW1lbnRhdGlvbi5cblxuXG5bJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3htbG5zOnhsaW5rJywgJ3gtaGVpZ2h0JyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuXG5bJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXR0cmlidXRlIGV4aXN0cyBib3RoIGluIEhUTUwgYW5kIFNWRy5cbi8vIFRoZSBhdHRyaWJ1dGUgbmFtZSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBTVkcgc28gd2UgY2FuJ3QganVzdCB1c2Vcbi8vIHRoZSBSZWFjdCBuYW1lIGxpa2Ugd2UgZG8gZm9yIGF0dHJpYnV0ZXMgdGhhdCBleGlzdCBvbmx5IGluIEhUTUwuXG5cblsndGFiSW5kZXgnLCAnY3Jvc3NPcmlnaW4nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXR0cmlidXRlcyBhY2NlcHQgVVJMcy4gVGhlc2UgbXVzdCBub3QgYWxsb3cgamF2YXNjcmlwdDogVVJMUy5cbi8vIFRoZXNlIHdpbGwgYWxzbyBuZWVkIHRvIGFjY2VwdCBUcnVzdGVkIFR5cGVzIG9iamVjdCBpbiB0aGUgZnV0dXJlLlxuXG52YXIgeGxpbmtIcmVmID0gJ3hsaW5rSHJlZic7XG5wcm9wZXJ0aWVzW3hsaW5rSHJlZl0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd4bGlua0hyZWYnLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbid4bGluazpocmVmJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO1xuWydzcmMnLCAnaHJlZicsICdhY3Rpb24nLCAnZm9ybUFjdGlvbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbiAgdHJ1ZSk7XG59KTtcblxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm4gJiYgaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdCh1cmwpKSB7XG4gICAgICBkaWRXYXJuID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHVybCkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbWF0Y2hIdG1sUmVnRXhwID0gL1tcIicmPD5dLztcbi8qKlxuICogRXNjYXBlcyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIEhUTUwgZW50aXRpZXMgaW4gYSBnaXZlbiBodG1sIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBIVE1MIHN0cmluZyB0byBlc2NhcGUgZm9yIGxhdGVyIGluc2VydGlvblxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM5OlxuICAgICAgICAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yUm9vdCgpIHtcbiAgcmV0dXJuIFJPT1RfQVRUUklCVVRFX05BTUUgKyAnPVwiXCInO1xufVxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5zYW5pdGl6ZVVSTCkge1xuICAgICAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIHNhbml0aXplVVJMKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xudmFyIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2sgaXMgYSByZS1yZW5kZXJlZCBob29rXG5cbnZhciBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgZHVyaW5nIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHJlbmRlciBwYXNzLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBMYXppbHkgY3JlYXRlZCBtYXAgb2YgcmVuZGVyLXBoYXNlIHVwZGF0ZXNcblxudmFyIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7IC8vIENvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cblxudmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTtcbnZhciBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldjtcblxuZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpIHtcbiAgaWYgKCEoY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPiAwKSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXJcIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBpZiAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IGNvbXBvbmVudElkZW50aXR5O1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG59XG5mdW5jdGlvbiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgcmVmT3JDb250ZXh0KSB7XG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgZnVuY3Rpb24gY29tcG9uZW50IHRvIHByZXZlbnQgaG9va3MgZnJvbVxuICAvLyBiZWluZyB1c2VkIGluIGNsYXNzZXMuXG4gIHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVXBkYXRlcyB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhleSBhcmUgc3RvcmVkIGluXG4gICAgLy8gdGhlIGByZW5kZXJQaGFzZVVwZGF0ZXNgIG1hcC4gQ2FsbCB0aGUgY29tcG9uZW50IGFnYWluLCByZXVzaW5nIHRoZVxuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9va3MgYW5kIGFwcGx5aW5nIHRoZSBhZGRpdGlvbmFsIHVwZGF0ZXMgb24gdG9wLiBLZWVwXG4gICAgLy8gcmVzdGFydGluZyB1bnRpbCBubyBtb3JlIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZC5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTsgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIH1cblxuICByZXNldEhvb2tzU3RhdGUoKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufSAvLyBSZXNldCB0aGUgaW50ZXJuYWwgaG9va3Mgc3RhdGUgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHJlbmRlcmluZyBhIGNvbXBvbmVudFxuXG5mdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB2YXIgdGhyZWFkSUQgPSBjdXJyZW50UGFydGlhbFJlbmRlcmVyLnRocmVhZElEO1xuICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuXG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbnRleHRbdGhyZWFkSURdO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gIH1cblxuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHZhciB0aHJlYWRJRCA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIudGhyZWFkSUQ7XG4gIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG4gIHJldHVybiBjb250ZXh0W3RocmVhZElEXTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIsIC8vIHVzZVJlZHVjZXIgaGFzIGEgc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgbGF6eSB1c2VTdGF0ZSBpbml0aWFsaXplcnNcbiAgaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB7XG4gICAgaWYgKHJlZHVjZXIgIT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgICAvLyBjdXJyZW50IGhvb2suXG4gICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlO1xuICAgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXJlIHN0b3JlZCBpbiBhIG1hcCBvZiBxdWV1ZSAtPiBsaW5rZWQgbGlzdFxuICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGB1c2VTdGF0ZWAuXG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgdmFyIF9xdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX2Rpc3BhdGNoID0gX3F1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsIF9xdWV1ZSk7XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBfZGlzcGF0Y2hdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuXG4gICAge1xuICAgICAgT2JqZWN0LnNlYWwocmVmKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG5cbiAgICBlcnJvcigndXNlTGF5b3V0RWZmZWN0IGRvZXMgbm90aGluZyBvbiB0aGUgc2VydmVyLCBiZWNhdXNlIGl0cyBlZmZlY3QgY2Fubm90ICcgKyBcImJlIGVuY29kZWQgaW50byB0aGUgc2VydmVyIHJlbmRlcmVyJ3Mgb3V0cHV0IGZvcm1hdC4gVGhpcyB3aWxsIGxlYWQgXCIgKyAndG8gYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBpbml0aWFsLCBub24taHlkcmF0ZWQgVUkgYW5kIHRoZSBpbnRlbmRlZCAnICsgJ1VJLiBUbyBhdm9pZCB0aGlzLCB1c2VMYXlvdXRFZmZlY3Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiAnICsgJ2NvbXBvbmVudHMgdGhhdCByZW5kZXIgZXhjbHVzaXZlbHkgb24gdGhlIGNsaWVudC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3VzZWxheW91dGVmZmVjdC1zc3IgZm9yIGNvbW1vbiBmaXhlcy4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAoIShudW1iZXJPZlJlUmVuZGVycyA8IFJFX1JFTkRFUl9MSU1JVCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuc2V0KHF1ZXVlLCB1cGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgIHdoaWxlIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICAgIH1cblxuICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH0sIGRlcHMpO1xufSAvLyBUT0RPIERlY2lkZSBvbiBob3cgdG8gaW1wbGVtZW50IHRoaXMgaG9vayBmb3Igc2VydmVyIHJlbmRlcmluZy5cbi8vIElmIGEgbXV0YXRpb24gb2NjdXJzIGR1cmluZyByZW5kZXIsIGNvbnNpZGVyIHRyaWdnZXJpbmcgYSBTdXNwZW5zZSBib3VuZGFyeVxuLy8gYW5kIGZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlxuXG5mdW5jdGlvbiB1c2VNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcblxuICB2YXIgc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcblxuICByZXR1cm4gW3N0YXJ0VHJhbnNpdGlvbiwgZmFsc2VdO1xufVxuXG5mdW5jdGlvbiB1c2VPcGFxdWVJZGVudGlmaWVyKCkge1xuICByZXR1cm4gKGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIuaWRlbnRpZmllclByZWZpeCB8fCAnJykgKyAnUjonICsgKGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIudW5pcXVlSUQrKykudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFBhcnRpYWxSZW5kZXJlcihyZW5kZXJlcikge1xuICBjdXJyZW50UGFydGlhbFJlbmRlcmVyID0gcmVuZGVyZXI7XG59XG52YXIgRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDb250ZXh0OiB1c2VDb250ZXh0LFxuICB1c2VNZW1vOiB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICB1c2VSZWY6IHVzZVJlZixcbiAgdXNlU3RhdGU6IHVzZVN0YXRlLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVzZUxheW91dEVmZmVjdCxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICAvLyB1c2VJbXBlcmF0aXZlSGFuZGxlIGlzIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wLFxuICAvLyBFZmZlY3RzIGFyZSBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZUVmZmVjdDogbm9vcCxcbiAgLy8gRGVidWdnaW5nIGVmZmVjdFxuICB1c2VEZWJ1Z1ZhbHVlOiBub29wLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB1c2VEZWZlcnJlZFZhbHVlLFxuICB1c2VUcmFuc2l0aW9uOiB1c2VUcmFuc2l0aW9uLFxuICB1c2VPcGFxdWVJZGVudGlmaWVyOiB1c2VPcGFxdWVJZGVudGlmaWVyLFxuICAvLyBTdWJzY3JpcHRpb25zIGFyZSBub3Qgc2V0dXAgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2Vcbn07XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59OyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cblxuICAgIGlmICghKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmNoZWNrZWQgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cblxufTtcblxuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cblxuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIHRhZyArIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG5cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbiAgdmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nOyAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgY2FtZWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAgICAvLyAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gICAgLy8gaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgJ21zLScpKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkRm9ySW5maW5pdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9O1xuXG4gIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlJDEgPSB3YXJuVmFsaWRTdHlsZTtcblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkMS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgY29ycmVjdE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1hcmlhLXByb3BzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICBlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG5cblxuICAgIGlmIChldmVudFJlZ2lzdHJ5ICE9IG51bGwpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0gZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEOyAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuXG5cbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuXG5cbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbnZhciB0b0FycmF5ID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheTsgLy8gVGhpcyBpcyBvbmx5IHVzZWQgaW4gREVWLlxuLy8gRWFjaCBlbnRyeSBpcyBgdGhpcy5zdGFja2AgZnJvbSBhIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyZXIgaW5zdGFuY2UuXG4vLyAoVGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgYmVjYXVzZSBSZWFjdERPTVNlcnZlciBpcyByZWVudHJhbnQpLlxuLy8gRWFjaCBzdGFjayBpcyBhbiBhcnJheSBvZiBmcmFtZXMgd2hpY2ggbWF5IGNvbnRhaW4gbmVzdGVkIHN0YWNrcyBvZiBlbGVtZW50cy5cblxudmFyIGN1cnJlbnREZWJ1Z1N0YWNrcyA9IFtdO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxO1xudmFyIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gbnVsbDtcblxudmFyIGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnJztcbn07XG5cbnZhciBkZXNjcmliZVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICByZXR1cm4gJyc7XG59O1xuXG52YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge307XG5cbnZhciBwdXNoQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHt9O1xuXG52YXIgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2sgPSBmdW5jdGlvbiAoZWxlbWVudCkge307XG5cbnZhciBwb3BDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gZmFsc2U7XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIG51bGwpO1xuICB9O1xuXG4gIGRlc2NyaWJlU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgbnVsbCk7XG4gIH07XG5cbiAgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgY3VycmVudERlYnVnU3RhY2tzLnB1c2goc3RhY2spO1xuXG4gICAgaWYgKGN1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFdlIGFyZSBlbnRlcmluZyBhIHNlcnZlciByZW5kZXJlci5cbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBwcmV2aW91cyAoZS5nLiBjbGllbnQpIGdsb2JhbCBzdGFjayBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjaztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsO1xuICAgIH1cbiAgfTtcblxuICBwdXNoRWxlbWVudFRvRGVidWdTdGFjayA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gRm9yIHRoZSBpbm5lcm1vc3QgZXhlY3V0aW5nIFJlYWN0RE9NU2VydmVyIGNhbGwsXG4gICAgdmFyIHN0YWNrID0gY3VycmVudERlYnVnU3RhY2tzW2N1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggLSAxXTsgLy8gVGFrZSB0aGUgaW5uZXJtb3N0IGV4ZWN1dGluZyBmcmFtZSAoZS5nLiA8Rm9vPiksXG5cbiAgICB2YXIgZnJhbWUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTsgLy8gYW5kIHJlY29yZCB0aGF0IGl0IGhhcyBvbmUgbW9yZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBpdC5cblxuICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrLnB1c2goZWxlbWVudCk7IC8vIFdlIG9ubHkgbmVlZCB0aGlzIGJlY2F1c2Ugd2UgdGFpbC1vcHRpbWl6ZSBzaW5nbGUtZWxlbWVudFxuICAgIC8vIGNoaWxkcmVuIGFuZCBkaXJlY3RseSBoYW5kbGUgdGhlbSBpbiBhbiBpbm5lciBsb29wIGluc3RlYWQgb2ZcbiAgICAvLyBjcmVhdGluZyBzZXBhcmF0ZSBmcmFtZXMgZm9yIHRoZW0uXG4gIH07XG5cbiAgcG9wQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudERlYnVnU3RhY2tzLnBvcCgpO1xuXG4gICAgaWYgKGN1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFdlIGFyZSBleGl0aW5nIHRoZSBzZXJ2ZXIgcmVuZGVyZXIuXG4gICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyAoZS5nLiBjbGllbnQpIGdsb2JhbCBzdGFjayBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcbiAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gUmVhY3RET01TZXJ2ZXIgaXMgcmVlbnRyYW50IHNvIHRoZXJlIG1heSBiZSBtdWx0aXBsZSBjYWxscyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIFRha2UgdGhlIGZyYW1lcyBmcm9tIHRoZSBpbm5lcm1vc3QgY2FsbCB3aGljaCBpcyB0aGUgbGFzdCBpbiB0aGUgYXJyYXkuXG5cblxuICAgIHZhciBmcmFtZXMgPSBjdXJyZW50RGVidWdTdGFja3NbY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGZyYW1lIGluIHRoZSBzdGFjayBmcm9tIHRoZSBpbm5lcm1vc3Qgb25lLlxuXG4gICAgZm9yICh2YXIgaSA9IGZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldOyAvLyBFdmVyeSBmcmFtZSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgZGVidWcgZWxlbWVudCBzdGFjayBlbnRyeSBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugc2luZ2xlLWNoaWxkIG5lc3RpbmcgZG9lc24ndCBjcmVhdGUgbWF0ZXJpYWxpemVkIGZyYW1lcy5cbiAgICAgIC8vIEluc3RlYWQgaXQgd291bGQgcHVzaCB0aGVtIHRocm91Z2ggYHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrKClgLlxuXG4gICAgICB2YXIgZGVidWdFbGVtZW50U3RhY2sgPSBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjaztcblxuICAgICAgZm9yICh2YXIgaWkgPSBkZWJ1Z0VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIHN0YWNrICs9IGRlc2NyaWJlU3RhY2tGcmFtZShkZWJ1Z0VsZW1lbnRTdGFja1tpaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxudmFyIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSB7fTtcbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gIGxpc3Rpbmc6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWVcbn07IC8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG5cbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCF2YWxpZGF0ZWRUYWdDYWNoZS5oYXNPd25Qcm9wZXJ0eSh0YWcpKSB7XG4gICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgdGFnOiBcIiArIHRhZyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbnZhciBzdHlsZU5hbWVDYWNoZSA9IHt9O1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgaWYgKHN0eWxlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICByZXR1cm4gc3R5bGVOYW1lQ2FjaGVbc3R5bGVOYW1lXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbiAgc3R5bGVOYW1lQ2FjaGVbc3R5bGVOYW1lXSA9IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclN0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgdmFyIGRlbGltaXRlciA9ICcnO1xuXG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG5cbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgKGlzQ3VzdG9tUHJvcGVydHkgPyBzdHlsZU5hbWUgOiBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkpICsgJzonO1xuICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiBnZXRDb21wb25lbnROYW1lKF9jb25zdHJ1Y3RvcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKCclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICByZXR1cm4gQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldE5vbkNoaWxkcmVuSW5uZXJNYXJrdXAocHJvcHMpIHtcbiAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG4gIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBpbm5lckhUTUwuX19odG1sO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGVudCA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblRvcExldmVsQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICByZXR1cm4gdG9BcnJheShjaGlsZHJlbik7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNoaWxkcmVuO1xuXG4gIGlmIChlbGVtZW50LnR5cGUgIT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICByZXR1cm4gW2VsZW1lbnRdO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50Q2hpbGRyZW4gPSBlbGVtZW50LnByb3BzLmNoaWxkcmVuO1xuXG4gIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZnJhZ21lbnRDaGlsZHJlbikpIHtcbiAgICByZXR1cm4gdG9BcnJheShmcmFnbWVudENoaWxkcmVuKTtcbiAgfVxuXG4gIHZhciBmcmFnbWVudENoaWxkRWxlbWVudCA9IGZyYWdtZW50Q2hpbGRyZW47XG4gIHJldHVybiBbZnJhZ21lbnRDaGlsZEVsZW1lbnRdO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgY29udGVudCA9ICcnOyAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gJiYgdHlwZW9mIGNoaWxkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29udGVudDtcbn1cblxudmFyIGhhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGwsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogbnVsbFxufTtcblxuZnVuY3Rpb24gY3JlYXRlT3BlblRhZ01hcmt1cCh0YWdWZXJiYXRpbSwgdGFnTG93ZXJjYXNlLCBwcm9wcywgbmFtZXNwYWNlLCBtYWtlU3RhdGljTWFya3VwLCBpc1Jvb3RFbGVtZW50KSB7XG4gIHZhciByZXQgPSAnPCcgKyB0YWdWZXJiYXRpbTtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50JDEgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWdMb3dlcmNhc2UsIHByb3BzKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSQyLmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgcHJvcFZhbHVlID0gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cCA9IG51bGw7XG5cbiAgICBpZiAoaXNDdXN0b21Db21wb25lbnQkMSkge1xuICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBtYXJrdXAgPSBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAobWFya3VwKSB7XG4gICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgIH1cbiAgfSAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgLy8gYnl0ZXMuXG5cblxuICBpZiAobWFrZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoaXNSb290RWxlbWVudCkge1xuICAgIHJldCArPSAnICcgKyBjcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgdHlwZSkge1xuICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnKSArIFwiKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShjaGlsZCwgY29udGV4dCwgdGhyZWFkSUQpIHtcbiAgd2hpbGUgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgIC8vIFNhZmUgYmVjYXVzZSB3ZSBqdXN0IGNoZWNrZWQgaXQncyBhbiBlbGVtZW50LlxuICAgIHZhciBlbGVtZW50ID0gY2hpbGQ7XG4gICAgdmFyIENvbXBvbmVudCA9IGVsZW1lbnQudHlwZTtcblxuICAgIHtcbiAgICAgIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcm9jZXNzQ2hpbGQoZWxlbWVudCwgQ29tcG9uZW50KTtcbiAgfSAvLyBFeHRyYSBjbG9zdXJlIHNvIHF1ZXVlIGFuZCByZXBsYWNlIGNhbiBiZSBjYXB0dXJlZCBwcm9wZXJseVxuXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0NoaWxkKGVsZW1lbnQsIENvbXBvbmVudCkge1xuICAgIHZhciBpc0NsYXNzID0gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KTtcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHByb2Nlc3NDb250ZXh0KENvbXBvbmVudCwgY29udGV4dCwgdGhyZWFkSUQsIGlzQ2xhc3MpO1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciByZXBsYWNlID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgICAgIHJlcGxhY2UgPSB0cnVlO1xuICAgICAgICBxdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY3VycmVudFBhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5wdXNoKGN1cnJlbnRQYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGluc3Q7XG5cbiAgICBpZiAoaXNDbGFzcykge1xuICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQoZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlcik7XG5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGluc3Quc3RhdGUgPT09IG51bGwgfHwgaW5zdC5zdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICcgKyAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArICdhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJyArICdUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuJywgY29tcG9uZW50TmFtZSwgaW5zdC5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLmNhbGwobnVsbCwgZWxlbWVudC5wcm9wcywgaW5zdC5zdGF0ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGVbX2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgIGVycm9yKCclcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuICcgKyAnWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGVbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICBpbnN0LnN0YXRlID0gX2Fzc2lnbih7fSwgaW5zdC5zdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW19jb21wb25lbnROYW1lMl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgICAgIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgIGluc3QgPSBDb21wb25lbnQoZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlcik7XG4gICAgICBpbnN0ID0gZmluaXNoSG9va3MoQ29tcG9uZW50LCBlbGVtZW50LnByb3BzLCBpbnN0LCBwdWJsaWNDb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICAvLyBTdXBwb3J0IGZvciBtb2R1bGUgY29tcG9uZW50cyBpcyBkZXByZWNhdGVkIGFuZCBpcyByZW1vdmVkIGJlaGluZCBhIGZsYWcuXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuICAgICAgICBpZiAoaW5zdCAhPSBudWxsICYmIGluc3QucmVuZGVyICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZTMsIF9jb21wb25lbnROYW1lMywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgdGhlIGZsYWcgaXMgb24sIGV2ZXJ5dGhpbmcgaXMgYXNzdW1lZCB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UgYWxzbyBkbyB0aGUgdW5mb3J0dW5hdGUgZHluYW1pYyBjaGVja3MuXG5cblxuICAgICAgaWYgKCBpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBjaGlsZCA9IGluc3Q7XG4gICAgICAgIHZhbGlkYXRlUmVuZGVyUmVzdWx0KGNoaWxkLCBDb21wb25lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5wcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuXG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICggaW5zdC5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtfY29tcG9uZW50TmFtZTRdKSB7XG4gICAgICAgICAgICAgIHdhcm4oIC8vIGtlZXAgdGhpcyB3YXJuaW5nIGluIHN5bmMgd2l0aCBSZWFjdFN0cmljdE1vZGVXYXJuaW5nLmpzXG4gICAgICAgICAgICAgICdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgZnJvbSBjb21wb25lbnRXaWxsTW91bnQgdG8gY29tcG9uZW50RGlkTW91bnQgKHByZWZlcnJlZCBpbiBtb3N0IGNhc2VzKSAnICsgJ29yIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtfY29tcG9uZW50TmFtZTRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgYW55IGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgZ0RTRlAuXG5cblxuICAgICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgICAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGFueSBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGdEU0ZQLlxuICAgICAgICBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdmFyIG9sZFJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICAgIHJlcGxhY2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAob2xkUmVwbGFjZSAmJiBvbGRRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpbnN0LnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3Quc3RhdGU7XG4gICAgICAgICAgdmFyIGRvbnRNdXRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IG9sZFJlcGxhY2UgPyAxIDogMDsgaSA8IG9sZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldO1xuXG4gICAgICAgICAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCkgOiBwYXJ0aWFsO1xuXG4gICAgICAgICAgICBpZiAoX3BhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChkb250TXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgZG9udE11dGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIG5leHRTdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2Fzc2lnbihuZXh0U3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gaW5zdC5yZW5kZXIoKTtcblxuICAgIHtcbiAgICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICBjaGlsZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIENvbXBvbmVudCk7XG4gICAgdmFyIGNoaWxkQ29udGV4dDtcblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdC5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9jaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgICAgICBpZiAodHlwZW9mIF9jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gX2NoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBfYXNzaWduKHt9LCBjb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2hpbGQ6IGNoaWxkLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbn1cblxudmFyIFJlYWN0RE9NU2VydmVyUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiB0eXBlIHRoaXMgbW9yZSBzdHJpY3RseTpcbiAgLy8gREVWLW9ubHlcbiAgZnVuY3Rpb24gUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihjaGlsZHJlbiwgbWFrZVN0YXRpY01hcmt1cCwgb3B0aW9ucykge1xuICAgIHZhciBmbGF0Q2hpbGRyZW4gPSBmbGF0dGVuVG9wTGV2ZWxDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgdmFyIHRvcEZyYW1lID0ge1xuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIC8vIEFzc3VtZSBhbGwgdHJlZXMgc3RhcnQgaW4gdGhlIEhUTUwgbmFtZXNwYWNlIChub3QgdG90YWxseSB0cnVlLCBidXRcbiAgICAgIC8vIHRoaXMgaXMgd2hhdCB3ZSBkaWQgaGlzdG9yaWNhbGx5KVxuICAgICAgZG9tTmFtZXNwYWNlOiBOYW1lc3BhY2VzLmh0bWwsXG4gICAgICBjaGlsZHJlbjogZmxhdENoaWxkcmVuLFxuICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgIGNvbnRleHQ6IGVtcHR5T2JqZWN0LFxuICAgICAgZm9vdGVyOiAnJ1xuICAgIH07XG5cbiAgICB7XG4gICAgICB0b3BGcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMudGhyZWFkSUQgPSBhbGxvY1RocmVhZElEKCk7XG4gICAgdGhpcy5zdGFjayA9IFt0b3BGcmFtZV07XG4gICAgdGhpcy5leGhhdXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgdGhpcy5tYWtlU3RhdGljTWFya3VwID0gbWFrZVN0YXRpY01hcmt1cDtcbiAgICB0aGlzLnN1c3BlbnNlRGVwdGggPSAwOyAvLyBDb250ZXh0IChuZXcgQVBJKVxuXG4gICAgdGhpcy5jb250ZXh0SW5kZXggPSAtMTtcbiAgICB0aGlzLmNvbnRleHRTdGFjayA9IFtdO1xuICAgIHRoaXMuY29udGV4dFZhbHVlU3RhY2sgPSBbXTsgLy8gdXNlT3BhcXVlSWRlbnRpZmllciBJRFxuXG4gICAgdGhpcy51bmlxdWVJRCA9IDA7XG4gICAgdGhpcy5pZGVudGlmaWVyUHJlZml4ID0gb3B0aW9ucyAmJiBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXggfHwgJyc7XG5cbiAgICB7XG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrID0gW107XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuZXhoYXVzdGVkKSB7XG4gICAgICB0aGlzLmV4aGF1c3RlZCA9IHRydWU7XG4gICAgICB0aGlzLmNsZWFyUHJvdmlkZXJzKCk7XG4gICAgICBmcmVlVGhyZWFkSUQodGhpcy50aHJlYWRJRCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOb3RlOiBXZSB1c2UganVzdCB0d28gc3RhY2tzIHJlZ2FyZGxlc3Mgb2YgaG93IG1hbnkgY29udGV4dCBwcm92aWRlcnMgeW91IGhhdmUuXG4gICAqIFByb3ZpZGVycyBhcmUgYWx3YXlzIHBvcHBlZCBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0byBob3cgdGhleSB3ZXJlIHB1c2hlZFxuICAgKiBzbyB3ZSBhbHdheXMga25vdyBvbiB0aGUgd2F5IGRvd24gd2hpY2ggcHJvdmlkZXIgeW91J2xsIGVuY291bnRlciBuZXh0IG9uIHRoZSB3YXkgdXAuXG4gICAqIE9uIHRoZSB3YXkgZG93biwgd2UgcHVzaCB0aGUgY3VycmVudCBwcm92aWRlciwgYW5kIGl0cyBjb250ZXh0IHZhbHVlICpiZWZvcmUqXG4gICAqIHdlIG11dGF0ZWQgaXQsIG9udG8gdGhlIHN0YWNrcy4gVGhlcmVmb3JlLCBvbiB0aGUgd2F5IHVwLCB3ZSBhbHdheXMga25vdyB3aGljaFxuICAgKiBwcm92aWRlciBuZWVkcyB0byBiZSBcInJlc3RvcmVkXCIgdG8gd2hpY2ggdmFsdWUuXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEyOTg1I2lzc3VlY29tbWVudC0zOTYzMDEyNDhcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHVzaFByb3ZpZGVyID0gZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gKyt0aGlzLmNvbnRleHRJbmRleDtcbiAgICB2YXIgY29udGV4dCA9IHByb3ZpZGVyLnR5cGUuX2NvbnRleHQ7XG4gICAgdmFyIHRocmVhZElEID0gdGhpcy50aHJlYWRJRDtcbiAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gY29udGV4dFt0aHJlYWRJRF07IC8vIFJlbWVtYmVyIHdoaWNoIHZhbHVlIHRvIHJlc3RvcmUgdGhpcyBjb250ZXh0IHRvIG9uIG91ciB3YXkgdXAuXG5cbiAgICB0aGlzLmNvbnRleHRTdGFja1tpbmRleF0gPSBjb250ZXh0O1xuICAgIHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdID0gcHJldmlvdXNWYWx1ZTtcblxuICAgIHtcbiAgICAgIC8vIE9ubHkgdXNlZCBmb3IgcHVzaC9wb3AgbWlzbWF0Y2ggd2FybmluZ3MuXG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSA9IHByb3ZpZGVyO1xuICAgIH0gLy8gTXV0YXRlIHRoZSBjdXJyZW50IHZhbHVlLlxuXG5cbiAgICBjb250ZXh0W3RocmVhZElEXSA9IHByb3ZpZGVyLnByb3BzLnZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5wb3BQcm92aWRlciA9IGZ1bmN0aW9uIHBvcFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0SW5kZXg7XG5cbiAgICB7XG4gICAgICBpZiAoaW5kZXggPCAwIHx8IHByb3ZpZGVyICE9PSB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSkge1xuICAgICAgICBlcnJvcignVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRTdGFja1tpbmRleF07XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XTsgLy8gXCJIaWRlXCIgdGhlc2UgbnVsbCBhc3NpZ25tZW50cyBmcm9tIEZsb3cgYnkgdXNpbmcgYGFueWBcbiAgICAvLyBiZWNhdXNlIGNvbmNlcHR1YWxseSB0aGV5IGFyZSBkZWxldGlvbnMtLWFzIGxvbmcgYXMgd2VcbiAgICAvLyBwcm9taXNlIHRvIG5ldmVyIGFjY2VzcyB2YWx1ZXMgYmV5b25kIGB0aGlzLmNvbnRleHRJbmRleGAuXG5cbiAgICB0aGlzLmNvbnRleHRTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHRJbmRleC0tOyAvLyBSZXN0b3JlIHRvIHRoZSBwcmV2aW91cyB2YWx1ZSB3ZSBzdG9yZWQgYXMgd2Ugd2VyZSB3YWxraW5nIGRvd24uXG4gICAgLy8gV2UndmUgYWxyZWFkeSB2ZXJpZmllZCB0aGF0IHRoaXMgY29udGV4dCBoYXMgYmVlbiBleHBhbmRlZCB0byBhY2NvbW1vZGF0ZVxuICAgIC8vIHRoaXMgdGhyZWFkIGlkLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGl0IGFnYWluLlxuXG4gICAgY29udGV4dFt0aGlzLnRocmVhZElEXSA9IHByZXZpb3VzVmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyUHJvdmlkZXJzID0gZnVuY3Rpb24gY2xlYXJQcm92aWRlcnMoKSB7XG4gICAgLy8gUmVzdG9yZSBhbnkgcmVtYWluaW5nIHByb3ZpZGVycyBvbiB0aGUgc3RhY2sgdG8gcHJldmlvdXMgdmFsdWVzXG4gICAgZm9yICh2YXIgaW5kZXggPSB0aGlzLmNvbnRleHRJbmRleDsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRTdGFja1tpbmRleF07XG4gICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdO1xuICAgICAgY29udGV4dFt0aGlzLnRocmVhZElEXSA9IHByZXZpb3VzVmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZWFkID0gZnVuY3Rpb24gcmVhZChieXRlcykge1xuICAgIGlmICh0aGlzLmV4aGF1c3RlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHByZXZQYXJ0aWFsUmVuZGVyZXIgPSBjdXJyZW50UGFydGlhbFJlbmRlcmVyO1xuICAgIHNldEN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIodGhpcyk7XG4gICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBEaXNwYXRjaGVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIE1hcmt1cCBnZW5lcmF0ZWQgd2l0aGluIDxTdXNwZW5zZT4gZW5kcyB1cCBidWZmZXJlZCB1bnRpbCB3ZSBrbm93XG4gICAgICAvLyBub3RoaW5nIGluIHRoYXQgYm91bmRhcnkgc3VzcGVuZGVkXG4gICAgICB2YXIgb3V0ID0gWycnXTtcbiAgICAgIHZhciBzdXNwZW5kZWQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKG91dFswXS5sZW5ndGggPCBieXRlcykge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmV4aGF1c3RlZCA9IHRydWU7XG4gICAgICAgICAgZnJlZVRocmVhZElEKHRoaXMudGhyZWFkSUQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChzdXNwZW5kZWQgfHwgZnJhbWUuY2hpbGRJbmRleCA+PSBmcmFtZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZm9vdGVyID0gZnJhbWUuZm9vdGVyO1xuXG4gICAgICAgICAgaWYgKGZvb3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgIT0gbnVsbCAmJiBmcmFtZS50eXBlLnR5cGUgIT0gbnVsbCAmJiBmcmFtZS50eXBlLnR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGZyYW1lLnR5cGU7XG4gICAgICAgICAgICB0aGlzLnBvcFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuc2VEZXB0aC0tO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkID0gb3V0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoc3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbmRlZCA9IGZhbHNlOyAvLyBJZiByZW5kZXJpbmcgd2FzIHN1c3BlbmRlZCBhdCB0aGlzIGJvdW5kYXJ5LCByZW5kZXIgdGhlIGZhbGxiYWNrRnJhbWVcblxuICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tGcmFtZSA9IGZyYW1lLmZhbGxiYWNrRnJhbWU7XG5cbiAgICAgICAgICAgICAgaWYgKCFmYWxsYmFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodHJ1ZSA/IFwiUmVhY3RET01TZXJ2ZXIgZGlkIG5vdCBmaW5kIGFuIGludGVybmFsIGZhbGxiYWNrIGZyYW1lIGZvciBTdXNwZW5zZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgOiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwMykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmYWxsYmFja0ZyYW1lKTtcbiAgICAgICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gJzwhLS0kIS0tPic7IC8vIFNraXAgZmx1c2hpbmcgb3V0cHV0IHNpbmNlIHdlJ3JlIHN3aXRjaGluZyB0byB0aGUgZmFsbGJhY2tcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IGJ1ZmZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gRmx1c2ggb3V0cHV0XG5cblxuICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IGZvb3RlcjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IGZyYW1lLmNoaWxkcmVuW2ZyYW1lLmNoaWxkSW5kZXgrK107XG4gICAgICAgIHZhciBvdXRCdWZmZXIgPSAnJztcblxuICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgIHB1c2hDdXJyZW50RGVidWdTdGFjayh0aGlzLnN0YWNrKTsgLy8gV2UncmUgc3RhcnRpbmcgd29yayBvbiB0aGlzIGZyYW1lLCBzbyByZXNldCBpdHMgaW5uZXIgc3RhY2suXG5cbiAgICAgICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvdXRCdWZmZXIgKz0gdGhpcy5yZW5kZXIoY2hpbGQsIGZyYW1lLmNvbnRleHQsIGZyYW1lLmRvbU5hbWVzcGFjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCAmJiB0eXBlb2YgZXJyLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgIGlmICghKHRoaXMuc3VzcGVuc2VEZXB0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodHJ1ZSA/IFwiQSBSZWFjdCBjb21wb25lbnQgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuXFxuQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byBwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS5cIiA6IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBTdXNwZW5zZS5cIiA6IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjk0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgIHBvcEN1cnJlbnREZWJ1Z1N0YWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dC5sZW5ndGggPD0gdGhpcy5zdXNwZW5zZURlcHRoKSB7XG4gICAgICAgICAgb3V0LnB1c2goJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gb3V0QnVmZmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0WzBdO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgc2V0Q3VycmVudFBhcnRpYWxSZW5kZXJlcihwcmV2UGFydGlhbFJlbmRlcmVyKTtcbiAgICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNoaWxkLCBjb250ZXh0LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgdGV4dCA9ICcnICsgY2hpbGQ7XG5cbiAgICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1ha2VTdGF0aWNNYXJrdXApIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmV2aW91c1dhc1RleHROb2RlKSB7XG4gICAgICAgIHJldHVybiAnPCEtLSAtLT4nICsgZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IHRydWU7XG4gICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0Q2hpbGQ7XG5cbiAgICAgIHZhciBfcmVzb2x2ZSA9IHJlc29sdmUoY2hpbGQsIGNvbnRleHQsIHRoaXMudGhyZWFkSUQpO1xuXG4gICAgICBuZXh0Q2hpbGQgPSBfcmVzb2x2ZS5jaGlsZDtcbiAgICAgIGNvbnRleHQgPSBfcmVzb2x2ZS5jb250ZXh0O1xuXG4gICAgICBpZiAobmV4dENoaWxkID09PSBudWxsIHx8IG5leHRDaGlsZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV4dENoaWxkKSkge1xuICAgICAgICBpZiAobmV4dENoaWxkICE9IG51bGwgJiYgbmV4dENoaWxkLiQkdHlwZW9mICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDYXRjaCB1bmV4cGVjdGVkIHNwZWNpYWwgdHlwZXMgZWFybHkuXG4gICAgICAgICAgdmFyICQkdHlwZW9mID0gbmV4dENoaWxkLiQkdHlwZW9mO1xuXG4gICAgICAgICAgaWYgKCEoJCR0eXBlb2YgIT09IFJFQUNUX1BPUlRBTF9UWVBFKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiBSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2F0Y2gtYWxsIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBpZiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KCkgc3VwcG9ydHMgc29tZSBuZXcgdHlwZS5cblxuXG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIGVsZW1lbnQtbGlrZSBvYmplY3QgdHlwZTogXCIgKyAkJHR5cGVvZi50b1N0cmluZygpICsgXCIuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0b0FycmF5KG5leHRDaGlsZCk7XG4gICAgICAgIHZhciBmcmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgfTtcblxuICAgICAgICB7XG4gICAgICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChmcmFtZSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gLy8gU2FmZSBiZWNhdXNlIHdlIGp1c3QgY2hlY2tlZCBpdCdzIGFuIGVsZW1lbnQuXG5cblxuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkO1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbmV4dEVsZW1lbnQudHlwZTtcblxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRE9NKG5leHRFbGVtZW50LCBjb250ZXh0LCBwYXJlbnROYW1lc3BhY2UpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGVsZW1lbnRUeXBlKSB7XG4gICAgICAgIC8vIFRPRE86IExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3Jrc1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGN1cnJlbnRseSBhc3N1bWUgdGhhdCBldmVyeSBpbnN0YW5jZSBvZiBMZWdhY3lIaWRkZW4gaXNcbiAgICAgICAgLy8gYWNjb21wYW5pZWQgYnkgYSBob3N0IGNvbXBvbmVudCB3cmFwcGVyLiBJbiB0aGUgaGlkZGVuIG1vZGUsIHRoZSBob3N0XG4gICAgICAgIC8vIGNvbXBvbmVudCBpcyBnaXZlbiBhIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZVxuICAgICAgICAvLyBpbml0aWFsIEhUTUwgaXMgbm90IHZpc2libGUuIFRvIHN1cHBvcnQgdGhlIHVzZSBvZiBMZWdhY3lIaWRkZW4gYXMgYVxuICAgICAgICAvLyB0cnVlIGZyYWdtZW50LCB3aXRob3V0IGFuIGV4dHJhIERPTSBub2RlLCB3ZSB3b3VsZCBoYXZlIHRvIGhpZGUgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgSFRNTCBpbiBzb21lIG90aGVyIHdheS5cbiAgICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuID0gdG9BcnJheShuZXh0Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICB2YXIgX2ZyYW1lID0ge1xuICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2ZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgU3VzcGVuc2UuXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50VHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBuZXh0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW41O1xuXG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICAgICAgICAgICAgICBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSk7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW41ID0gZWxlbWVudFR5cGUucmVuZGVyKGVsZW1lbnQucHJvcHMsIGVsZW1lbnQucmVmKTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSBmaW5pc2hIb29rcyhlbGVtZW50VHlwZS5yZW5kZXIsIGVsZW1lbnQucHJvcHMsIF9uZXh0Q2hpbGRyZW41LCBlbGVtZW50LnJlZik7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW41ID0gdG9BcnJheShfbmV4dENoaWxkcmVuNSk7XG4gICAgICAgICAgICAgIHZhciBfZnJhbWU1ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW41LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU1KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZWxlbWVudCA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW42ID0gW1JlYWN0LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUudHlwZSwgX2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgcmVmOiBfZWxlbWVudC5yZWZcbiAgICAgICAgICAgICAgfSwgX2VsZW1lbnQucHJvcHMpKV07XG4gICAgICAgICAgICAgIHZhciBfZnJhbWU2ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW42LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTYuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU2KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSBwcm92aWRlci5wcm9wcztcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjcgPSB0b0FycmF5KG5leHRQcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTcgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW43LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTcuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMucHVzaFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTcpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWN0Q29udGV4dCA9IG5leHRDaGlsZC50eXBlOyAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbiAgICAgICAgICAgICAgLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbiAgICAgICAgICAgICAgLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4gICAgICAgICAgICAgIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4gICAgICAgICAgICAgIC8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4gICAgICAgICAgICAgIC8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuICAgICAgICAgICAgICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChyZWFjdENvbnRleHQuX2NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4gICAgICAgICAgICAgICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG4gICAgICAgICAgICAgICAgICBpZiAocmVhY3RDb250ZXh0ICE9PSByZWFjdENvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWFjdENvbnRleHQgPSByZWFjdENvbnRleHQuX2NvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0UHJvcHMgPSBuZXh0Q2hpbGQucHJvcHM7XG4gICAgICAgICAgICAgIHZhciB0aHJlYWRJRCA9IHRoaXMudGhyZWFkSUQ7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhyZWFjdENvbnRleHQsIHRocmVhZElEKTtcbiAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHJlYWN0Q29udGV4dFt0aHJlYWRJRF07XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW44ID0gdG9BcnJheShfbmV4dFByb3BzLmNoaWxkcmVuKG5leHRWYWx1ZSkpO1xuXG4gICAgICAgICAgICAgIHZhciBfZnJhbWU4ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG5leHRDaGlsZCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjgsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lOC5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTgpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEU6XG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHRoZSBmdW5kYW1lbnRhbCBBUEkuXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX2VsZW1lbnQyID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IG5leHRDaGlsZC50eXBlOyAvLyBBdHRlbXB0IHRvIGluaXRpYWxpemUgbGF6eSBjb21wb25lbnQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZVxuICAgICAgICAgICAgICAvLyBzdXNwZW5zZSBzZXJ2ZXItc2lkZSByZW5kZXJlciBpcyBlbmFibGVkIHNvIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgLy8gcmVzb2x2ZWQgY29uc3RydWN0b3JzIGFyZSBzdXBwb3J0ZWQuXG5cbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbml0KHBheWxvYWQpO1xuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjEwID0gW1JlYWN0LmNyZWF0ZUVsZW1lbnQocmVzdWx0LCBfYXNzaWduKHtcbiAgICAgICAgICAgICAgICByZWY6IF9lbGVtZW50Mi5yZWZcbiAgICAgICAgICAgICAgfSwgX2VsZW1lbnQyLnByb3BzKSldO1xuICAgICAgICAgICAgICB2YXIgX2ZyYW1lMTAgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjEwLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTEwLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lMTApO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAge1xuICAgICAgICB2YXIgb3duZXIgPSBuZXh0RWxlbWVudC5fb3duZXI7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlbGVtZW50VHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuXG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArIChlbGVtZW50VHlwZSA9PSBudWxsID8gZWxlbWVudFR5cGUgOiB0eXBlb2YgZWxlbWVudFR5cGUpICsgXCIuXCIgKyBpbmZvICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlckRPTSA9IGZ1bmN0aW9uIHJlbmRlckRPTShlbGVtZW50LCBjb250ZXh0LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgICB2YXIgdGFnID0gZWxlbWVudC50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IE5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgbmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgICBpZiAodGFnICE9PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIGVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICAgIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ2lucHV0JywgcHJvcHMpO1xuXG4gICAgICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRDaGVja2VkKSB7XG4gICAgICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICAgIH0sIHByb3BzLCB7XG4gICAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICB2YWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBjaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUpIHtcbiAgICAgICAgICBlcnJvcignVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAgICAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7IC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG5cbiAgICAgICAgdmFyIHRleHRhcmVhQ2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICBpZiAodGV4dGFyZWFDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0YXJlYUNoaWxkcmVuKSkge1xuICAgICAgICAgICAgaWYgKCEodGV4dGFyZWFDaGlsZHJlbi5sZW5ndGggPD0gMSkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIjx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRhcmVhQ2hpbGRyZW4gPSB0ZXh0YXJlYUNoaWxkcmVuWzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgdGV4dGFyZWFDaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGNoaWxkcmVuOiAnJyArIGluaXRpYWxWYWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3NlbGVjdCcsIHByb3BzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuXG4gICAgICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLicsIHByb3BOYW1lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4nLCBwcm9wTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUpIHtcbiAgICAgICAgICBlcnJvcignU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnb3B0aW9uJykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICAgIHZhciBzZWxlY3RWYWx1ZSA9IHRoaXMuY3VycmVudFNlbGVjdFZhbHVlO1xuICAgICAgdmFyIG9wdGlvbkNoaWxkcmVuID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gb3B0aW9uQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbal0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgICAgICB9LCBwcm9wcywge1xuICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICBjaGlsZHJlbjogb3B0aW9uQ2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHByb3BzKTtcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpO1xuICAgIHZhciBvdXQgPSBjcmVhdGVPcGVuVGFnTWFya3VwKGVsZW1lbnQudHlwZSwgdGFnLCBwcm9wcywgbmFtZXNwYWNlLCB0aGlzLm1ha2VTdGF0aWNNYXJrdXAsIHRoaXMuc3RhY2subGVuZ3RoID09PSAxKTtcbiAgICB2YXIgZm9vdGVyID0gJyc7XG5cbiAgICBpZiAob21pdHRlZENsb3NlVGFncy5oYXNPd25Qcm9wZXJ0eSh0YWcpKSB7XG4gICAgICBvdXQgKz0gJy8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICc+JztcbiAgICAgIGZvb3RlciA9ICc8LycgKyBlbGVtZW50LnR5cGUgKyAnPic7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuO1xuICAgIHZhciBpbm5lck1hcmt1cCA9IGdldE5vbkNoaWxkcmVuSW5uZXJNYXJrdXAocHJvcHMpO1xuXG4gICAgaWYgKGlubmVyTWFya3VwICE9IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuID0gW107XG5cbiAgICAgIGlmIChuZXdsaW5lRWF0aW5nVGFncy5oYXNPd25Qcm9wZXJ0eSh0YWcpICYmIGlubmVyTWFya3VwLmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgICAgb3V0ICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICBvdXQgKz0gaW5uZXJNYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuID0gdG9BcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lID0ge1xuICAgICAgZG9tTmFtZXNwYWNlOiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIGVsZW1lbnQudHlwZSksXG4gICAgICB0eXBlOiB0YWcsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGZvb3RlcjogZm9vdGVyXG4gICAgfTtcblxuICAgIHtcbiAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKGZyYW1lKTtcbiAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHJldHVybiBSZWFjdERPTVNlcnZlclJlbmRlcmVyO1xufSgpO1xuXG4vKipcbiAqIFJlbmRlciBhIFJlYWN0RWxlbWVudCB0byBpdHMgaW5pdGlhbCBIVE1MLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gdGhlXG4gKiBzZXJ2ZXIuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0cmluZ1xuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgZmFsc2UsIG9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgdmFyIG1hcmt1cCA9IHJlbmRlcmVyLnJlYWQoSW5maW5pdHkpO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH0gZmluYWxseSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICB9XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gcmVuZGVyVG9TdHJpbmcsIGV4Y2VwdCB0aGlzIGRvZXNuJ3QgY3JlYXRlIGV4dHJhIERPTSBhdHRyaWJ1dGVzXG4gKiBzdWNoIGFzIGRhdGEtcmVhY3QtaWQgdGhhdCBSZWFjdCB1c2VzIGludGVybmFsbHkuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0YXRpY21hcmt1cFxuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbWFya3VwID0gcmVuZGVyZXIucmVhZChJbmZpbml0eSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSBmaW5hbGx5IHtcbiAgICByZW5kZXJlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWRhYmxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0sIF9SZWFkYWJsZSk7XG5cbiAgZnVuY3Rpb24gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCBtYWtlU3RhdGljTWFya3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgLy8gQ2FsbHMgdGhlIHN0cmVhbS5SZWFkYWJsZShvcHRpb25zKSBjb25zdHJ1Y3Rvci4gQ29uc2lkZXIgZXhwb3NpbmcgYnVpbHQtaW5cbiAgICAvLyBmZWF0dXJlcyBsaWtlIGhpZ2hXYXRlck1hcmsgaW4gdGhlIGZ1dHVyZS5cbiAgICBfdGhpcyA9IF9SZWFkYWJsZS5jYWxsKHRoaXMsIHt9KSB8fCB0aGlzO1xuICAgIF90aGlzLnBhcnRpYWxSZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIG1ha2VTdGF0aWNNYXJrdXAsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wYXJ0aWFsUmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG5cbiAgX3Byb3RvLl9yZWFkID0gZnVuY3Rpb24gX3JlYWQoc2l6ZSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5wYXJ0aWFsUmVuZGVyZXIucmVhZChzaXplKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW07XG59KHN0cmVhbS5SZWFkYWJsZSk7XG4vKipcbiAqIFJlbmRlciBhIFJlYWN0RWxlbWVudCB0byBpdHMgaW5pdGlhbCBIVE1MLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gdGhlXG4gKiBzZXJ2ZXIuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b25vZGVzdHJlYW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmRlclRvTm9kZVN0cmVhbShlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCBmYWxzZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gcmVuZGVyVG9Ob2RlU3RyZWFtLCBleGNlcHQgdGhpcyBkb2Vzbid0IGNyZWF0ZSBleHRyYSBET00gYXR0cmlidXRlc1xuICogc3VjaCBhcyBkYXRhLXJlYWN0LWlkIHRoYXQgUmVhY3QgdXNlcyBpbnRlcm5hbGx5LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdGF0aWNub2Rlc3RyZWFtXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIHRydWUsIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnJlbmRlclRvTm9kZVN0cmVhbSA9IHJlbmRlclRvTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtID0gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IHJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLm5vZGUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2VydmVyLm5vZGUnKTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlciB9IGZyb20gXCJAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXNcIjtcbmltcG9ydCAqIGFzIGJ1aWxkIGZyb20gXCJAcmVtaXgtcnVuL3NlcnZlci1idWlsZFwiO1xuY29uc3QgaGFuZGxlUmVxdWVzdCA9IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyKHsgYnVpbGQsIG1vZGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WIH0pO1xuZXhwb3J0IGZ1bmN0aW9uIG9uUmVxdWVzdChjb250ZXh0KSB7XG4gIHJldHVybiBoYW5kbGVSZXF1ZXN0KGNvbnRleHQpO1xufSIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4xLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgaW5zdGFsbEdsb2JhbHMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuZXhwb3J0IHsgY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICcuL3Nlc3Npb25zL2Nsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyLCBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vd29ya2VyLmpzJztcblxuaW5zdGFsbEdsb2JhbHMoKTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4xLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgc2lnbiwgdW5zaWduIH0gZnJvbSAnLi9jb29raWVTaWduaW5nLmpzJztcblxuZnVuY3Rpb24gaW5zdGFsbEdsb2JhbHMoKSB7XG4gIHNlbGYuc2lnbiA9IHNpZ247XG4gIHNlbGYudW5zaWduID0gdW5zaWduO1xufVxuXG5leHBvcnQgeyBpbnN0YWxsR2xvYmFscyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjEuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5hc3luYyBmdW5jdGlvbiBzaWduKHZhbHVlLCBzZWNyZXQpIHtcbiAgbGV0IGtleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGVuY29kZXIuZW5jb2RlKHNlY3JldCksIHtcbiAgICBuYW1lOiBcIkhNQUNcIixcbiAgICBoYXNoOiBcIlNIQS0yNTZcIlxuICB9LCBmYWxzZSwgW1wic2lnblwiXSk7XG4gIGxldCBkYXRhID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQgc2lnbmF0dXJlID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKFwiSE1BQ1wiLCBrZXksIGRhdGEpO1xuICBsZXQgaGFzaCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSkucmVwbGFjZSgvPSskLywgXCJcIik7XG4gIHJldHVybiB2YWx1ZSArIFwiLlwiICsgaGFzaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVuc2lnbihjb29raWUsIHNlY3JldCkge1xuICBsZXQga2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSwge1xuICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgIGhhc2g6IFwiU0hBLTI1NlwiXG4gIH0sIGZhbHNlLCBbXCJ2ZXJpZnlcIl0pO1xuICBsZXQgdmFsdWUgPSBjb29raWUuc2xpY2UoMCwgY29va2llLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gIGxldCBoYXNoID0gY29va2llLnNsaWNlKGNvb2tpZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBzaWduYXR1cmUgPSBieXRlU3RyaW5nVG9VaW50OEFycmF5KGF0b2IoaGFzaCkpO1xuICBsZXQgdmFsaWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShcIkhNQUNcIiwga2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICByZXR1cm4gdmFsaWQgPyB2YWx1ZSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBieXRlU3RyaW5nVG9VaW50OEFycmF5KGJ5dGVTdHJpbmcpIHtcbiAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgeyBzaWduLCB1bnNpZ24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4xLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY3JlYXRlU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICdAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgU2Vzc2lvblN0b3JhZ2UgdGhhdCBzdG9yZXMgc2Vzc2lvbiBkYXRhIGluIHRoZSBDbG91bGRmbGFyZSBLViBTdG9yZS5cbiAqXG4gKiBUaGUgYWR2YW50YWdlIG9mIHVzaW5nIHRoaXMgaW5zdGVhZCBvZiBjb29raWUgc2Vzc2lvbiBzdG9yYWdlIGlzIHRoYXRcbiAqIEtWIFN0b3JlIG1heSBjb250YWluIG11Y2ggbW9yZSBkYXRhIHRoYW4gY29va2llcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2Uoe1xuICBjb29raWUsXG4gIGt2XG59KSB7XG4gIHJldHVybiBjcmVhdGVTZXNzaW9uU3RvcmFnZSh7XG4gICAgY29va2llLFxuXG4gICAgYXN5bmMgY3JlYXRlRGF0YShkYXRhLCBleHBpcmVzKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgcmFuZG9tQnl0ZXMgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CeXRlcyk7IC8vIFRoaXMgc3RvcmFnZSBtYW5hZ2VzIGFuIGlkIHNwYWNlIG9mIDJeNjQgaWRzLCB3aGljaCBpcyBmYXIgZ3JlYXRlclxuICAgICAgICAvLyB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBmaWxlcyBhbGxvd2VkIG9uIGFuIE5URlMgb3IgZXh0NCB2b2x1bWVcbiAgICAgICAgLy8gKDJeMzIpLiBIb3dldmVyLCB0aGUgbGFyZ2VyIGlkIHNwYWNlIHNob3VsZCBoZWxwIHRvIGF2b2lkIGNvbGxpc2lvbnNcbiAgICAgICAgLy8gd2l0aCBleGlzdGluZyBpZHMgd2hlbiBjcmVhdGluZyBuZXcgc2Vzc2lvbnMsIHdoaWNoIHNwZWVkcyB0aGluZ3MgdXAuXG5cbiAgICAgICAgbGV0IGlkID0gWy4uLnJhbmRvbUJ5dGVzXS5tYXAoeCA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG5cbiAgICAgICAgaWYgKGF3YWl0IGt2LmdldChpZCwgXCJqc29uXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBrdi5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgICAgICAgZXhwaXJhdGlvbjogZXhwaXJlcyA/IE1hdGgucm91bmQoZXhwaXJlcy5nZXRUaW1lKCkgLyAxMDAwKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyByZWFkRGF0YShpZCkge1xuICAgICAgbGV0IHNlc3Npb24gPSBhd2FpdCBrdi5nZXQoaWQpO1xuXG4gICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlc3Npb24pO1xuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGVEYXRhKGlkLCBkYXRhLCBleHBpcmVzKSB7XG4gICAgICBhd2FpdCBrdi5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgICAgIGV4cGlyYXRpb246IGV4cGlyZXMgPyBNYXRoLnJvdW5kKGV4cGlyZXMuZ2V0VGltZSgpIC8gMTAwMCkgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyBkZWxldGVEYXRhKGlkKSB7XG4gICAgICBhd2FpdCBrdi5kZWxldGUoaWQpO1xuICAgIH1cblxuICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMS4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IGNyZWF0ZUNvb2tpZSwgaXNDb29raWUgfSBmcm9tICcuL2Nvb2tpZXMuanMnO1xuZXhwb3J0IHsganNvbiwgcmVkaXJlY3QgfSBmcm9tICcuL3Jlc3BvbnNlcy5qcyc7XG5leHBvcnQgeyBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vc2VydmVyLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVNlc3Npb25TdG9yYWdlLCBpc1Nlc3Npb24gfSBmcm9tICcuL3Nlc3Npb25zLmpzJztcbmV4cG9ydCB7IGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlIH0gZnJvbSAnLi9zZXNzaW9ucy9jb29raWVTdG9yYWdlLmpzJztcbmV4cG9ydCB7IGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlIH0gZnJvbSAnLi9zZXNzaW9ucy9tZW1vcnlTdG9yYWdlLmpzJztcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMS4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogQSBKU09OIHJlc3BvbnNlLiBDb252ZXJ0cyBgZGF0YWAgdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5mdW5jdGlvbiBqc29uKGRhdGEsIGluaXQgPSB7fSkge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcblxuICBpZiAodHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7XG4gICAgICBzdGF0dXM6IGluaXRcbiAgICB9O1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG5cbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSksIHsgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UuIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxuICovXG5cbmZ1bmN0aW9uIHJlZGlyZWN0KHVybCwgaW5pdCA9IDMwMikge1xuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcblxuICBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgIHN0YXR1czogcmVzcG9uc2VJbml0XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0LnN0YXR1cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJlc3BvbnNlSW5pdC5zdGF0dXMgPSAzMDI7XG4gIH1cblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgLi4ucmVzcG9uc2VJbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5jb25zdCByZWRpcmVjdFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdKTtcbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVkaXJlY3RTdGF0dXNDb2Rlcy5oYXMocmVzcG9uc2Uuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzQ2F0Y2hSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LUNhdGNoXCIpICE9IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzQ2F0Y2hSZXNwb25zZSwgaXNSZWRpcmVjdFJlc3BvbnNlLCBpc1Jlc3BvbnNlLCBqc29uLCByZWRpcmVjdCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4xLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY2FsbFJvdXRlQWN0aW9uLCBjYWxsUm91dGVMb2FkZXIsIGV4dHJhY3REYXRhIH0gZnJvbSAnLi9kYXRhLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzLCBjcmVhdGVFbnRyeU1hdGNoZXMgfSBmcm9tICcuL2VudHJ5LmpzJztcbmltcG9ydCB7IHNlcmlhbGl6ZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnRIZWFkZXJzIH0gZnJvbSAnLi9oZWFkZXJzLmpzJztcbmltcG9ydCB7IG1hdGNoU2VydmVyUm91dGVzIH0gZnJvbSAnLi9yb3V0ZU1hdGNoaW5nLmpzJztcbmltcG9ydCB7IGlzU2VydmVyTW9kZSwgU2VydmVyTW9kZSB9IGZyb20gJy4vbW9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXMgfSBmcm9tICcuL3JvdXRlcy5qcyc7XG5pbXBvcnQgeyBpc1JlZGlyZWN0UmVzcG9uc2UsIGlzQ2F0Y2hSZXNwb25zZSwganNvbiB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcgfSBmcm9tICcuL3NlcnZlckhhbmRvZmYuanMnO1xuXG4vKipcbiAqIFRoZSBtYWluIHJlcXVlc3QgaGFuZGxlciBmb3IgYSBSZW1peCBzZXJ2ZXIuIFRoaXMgaGFuZGxlciBydW5zIGluIHRoZSBjb250ZXh0XG4gKiBvZiBhIGNsb3VkIHByb3ZpZGVyJ3Mgc2VydmVyIChlLmcuIEV4cHJlc3Mgb24gRmlyZWJhc2UpIG9yIGxvY2FsbHkgdmlhIHRoZWlyXG4gKiBkZXYgdG9vbHMuXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBzZXJ2ZXMgSFRUUCByZXF1ZXN0cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEhhbmRsZXIoYnVpbGQsIHBsYXRmb3JtLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IHNlcnZlck1vZGUgPSBpc1NlcnZlck1vZGUobW9kZSkgPyBtb2RlIDogU2VydmVyTW9kZS5Qcm9kdWN0aW9uO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgbG9hZENvbnRleHQpIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHVybC5wYXRobmFtZSk7XG4gICAgbGV0IHJlcXVlc3RUeXBlID0gZ2V0UmVxdWVzdFR5cGUodXJsLCBtYXRjaGVzKTtcbiAgICBsZXQgcmVzcG9uc2U7XG5cbiAgICBzd2l0Y2ggKHJlcXVlc3RUeXBlKSB7XG4gICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZURhdGFSZXF1ZXN0KHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgICAgaGFuZGxlRGF0YVJlcXVlc3Q6IGJ1aWxkLmVudHJ5Lm1vZHVsZS5oYW5kbGVEYXRhUmVxdWVzdCxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImRvY3VtZW50XCI6XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVuZGVyRG9jdW1lbnRSZXF1ZXN0KHtcbiAgICAgICAgICBidWlsZCxcbiAgICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcm91dGVzLFxuICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicmVzb3VyY2VcIjpcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoe1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJoZWFkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVEYXRhUmVxdWVzdCh7XG4gIGhhbmRsZURhdGFSZXF1ZXN0LFxuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgc2VydmVyTW9kZVxufSkge1xuICBpZiAoIWlzVmFsaWRSZXF1ZXN0TWV0aG9kKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke3JlcXVlc3QubWV0aG9kfVwiYCksIDQwNSk7XG4gIH1cblxuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYE5vIHJvdXRlIG1hdGNoZXMgVVJMIFwiJHt1cmwucGF0aG5hbWV9XCJgKSwgNDA0KTtcbiAgfVxuXG4gIGxldCByZXNwb25zZTtcbiAgbGV0IG1hdGNoO1xuXG4gIHRyeSB7XG4gICAgaWYgKGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgbWF0Y2ggPSBnZXRBY3Rpb25SZXF1ZXN0TWF0Y2godXJsLCBtYXRjaGVzKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJvdXRlSWQgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcIl9kYXRhXCIpO1xuXG4gICAgICBpZiAoIXJvdXRlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYE1pc3Npbmcgcm91dGUgaWQgaW4gP19kYXRhYCksIDQwMyk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZW1wTWF0Y2ggPSBtYXRjaGVzLmZpbmQobWF0Y2ggPT4gbWF0Y2gucm91dGUuaWQgPT09IHJvdXRlSWQpO1xuXG4gICAgICBpZiAoIXRlbXBNYXRjaCkge1xuICAgICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihgUm91dGUgXCIke3JvdXRlSWR9XCIgZG9lcyBub3QgbWF0Y2ggVVJMIFwiJHt1cmwucGF0aG5hbWV9XCJgKSwgNDAzKTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxSb3V0ZUxvYWRlcih7XG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55IHdheSB0byBwcmV2ZW50IGEgZmV0Y2ggcmVxdWVzdCBmcm9tIGZvbGxvd2luZ1xuICAgICAgLy8gcmVkaXJlY3RzLiBTbyB3ZSB1c2UgdGhlIGBYLVJlbWl4LVJlZGlyZWN0YCBoZWFkZXIgdG8gaW5kaWNhdGUgdGhlXG4gICAgICAvLyBuZXh0IFVSTCwgYW5kIHRoZW4gXCJmb2xsb3dcIiB0aGUgcmVkaXJlY3QgbWFudWFsbHkgb24gdGhlIGNsaWVudC5cbiAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLnNldChcIlgtUmVtaXgtUmVkaXJlY3RcIiwgaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKSk7XG4gICAgICBoZWFkZXJzLmRlbGV0ZShcIkxvY2F0aW9uXCIpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRGF0YVJlcXVlc3QpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlRGF0YVJlcXVlc3QocmVzcG9uc2UuY2xvbmUoKSwge1xuICAgICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QuY2xvbmUoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJNb2RlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50KSB7XG4gICAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKGVycm9yLCA1MDApO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIiksIDUwMCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyRG9jdW1lbnRSZXF1ZXN0KHtcbiAgYnVpbGQsXG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaGVzLFxuICByZXF1ZXN0LFxuICByb3V0ZXMsXG4gIHNlcnZlck1vZGVcbn0pIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgYXBwU3RhdGUgPSB7XG4gICAgdHJhY2tCb3VuZGFyaWVzOiB0cnVlLFxuICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiB0cnVlLFxuICAgIGNhdGNoQm91bmRhcnlSb3V0ZUlkOiBudWxsLFxuICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICBsb2FkZXJCb3VuZGFyeVJvdXRlSWQ6IG51bGwsXG4gICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICBjYXRjaDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSkge1xuICAgIG1hdGNoZXMgPSBudWxsO1xuICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgc3RhdHVzOiA0MDUsXG4gICAgICBzdGF0dXNUZXh0OiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiXG4gICAgfTtcbiAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgfTtcbiAgfVxuXG4gIGxldCBhY3Rpb25TdGF0dXM7XG4gIGxldCBhY3Rpb25EYXRhO1xuICBsZXQgYWN0aW9uTWF0Y2g7XG4gIGxldCBhY3Rpb25SZXNwb25zZTtcblxuICBpZiAobWF0Y2hlcyAmJiBpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICBhY3Rpb25NYXRjaCA9IGdldEFjdGlvblJlcXVlc3RNYXRjaCh1cmwsIG1hdGNoZXMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGFjdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIG1hdGNoOiBhY3Rpb25NYXRjaCxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UoYWN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb25SZXNwb25zZTtcbiAgICAgIH1cblxuICAgICAgYWN0aW9uU3RhdHVzID0ge1xuICAgICAgICBzdGF0dXM6IGFjdGlvblJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogYWN0aW9uUmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgfTtcblxuICAgICAgaWYgKGlzQ2F0Y2hSZXNwb25zZShhY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBcIkNhdGNoQm91bmRhcnlcIik7XG4gICAgICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICAgIGFwcFN0YXRlLmNhdGNoID0geyAuLi5hY3Rpb25TdGF0dXMsXG4gICAgICAgICAgZGF0YTogYXdhaXQgZXh0cmFjdERhdGEoYWN0aW9uUmVzcG9uc2UpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25EYXRhID0ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IGF3YWl0IGV4dHJhY3REYXRhKGFjdGlvblJlc3BvbnNlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBcIkVycm9yQm91bmRhcnlcIik7XG4gICAgICBhcHBTdGF0ZS50cmFja0JvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgIGFwcFN0YXRlLmVycm9yID0gYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuXG4gICAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZXJlIHdhcyBhbiBlcnJvciBydW5uaW5nIHRoZSBhY3Rpb24gZm9yIHJvdXRlICR7YWN0aW9uTWF0Y2gucm91dGUuaWR9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHJvdXRlTW9kdWxlcyA9IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKGJ1aWxkLnJvdXRlcyk7XG4gIGxldCBtYXRjaGVzVG9Mb2FkID0gbWF0Y2hlcyB8fCBbXTtcblxuICBpZiAoYXBwU3RhdGUuY2F0Y2gpIHtcbiAgICBtYXRjaGVzVG9Mb2FkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkoIC8vIGdldCByaWQgb2YgdGhlIGFjdGlvbiwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIGl0J3MgbG9hZGVyIGVpdGhlclxuICAgIC8vIGJlY2F1c2Ugd2UnbGwgYmUgcmVuZGVyaW5nIHRoZSBjYXRjaCBib3VuZGFyeSwgaWYgeW91IGNhbiBnZXQgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGxvYWRlciBkYXRhIGluIHRoZSBjYXRjaCBib3VuZGFyeSB0aGVuIGhvdyB0aGUgaGVjayBpcyBpdFxuICAgIC8vIHN1cHBvc2VkIHRvIGRlYWwgd2l0aCB0aHJvd24gcmVzcG9uc2VzP1xuICAgIG1hdGNoZXNUb0xvYWQuc2xpY2UoMCwgLTEpLCBcIkNhdGNoQm91bmRhcnlcIik7XG4gIH0gZWxzZSBpZiAoYXBwU3RhdGUuZXJyb3IpIHtcbiAgICBtYXRjaGVzVG9Mb2FkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkoIC8vIGdldCByaWQgb2YgdGhlIGFjdGlvbiwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIGl0J3MgbG9hZGVyIGVpdGhlclxuICAgIC8vIGJlY2F1c2Ugd2UnbGwgYmUgcmVuZGVyaW5nIHRoZSBlcnJvciBib3VuZGFyeSwgaWYgeW91IGNhbiBnZXQgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGxvYWRlciBkYXRhIGluIHRoZSBlcnJvciBib3VuZGFyeSB0aGVuIGhvdyB0aGUgaGVjayBpcyBpdFxuICAgIC8vIHN1cHBvc2VkIHRvIGRlYWwgd2l0aCBlcnJvcnMgaW4gdGhlIGxvYWRlciwgdG9vP1xuICAgIG1hdGNoZXNUb0xvYWQuc2xpY2UoMCwgLTEpLCBcIkVycm9yQm91bmRhcnlcIik7XG4gIH1cblxuICBsZXQgcm91dGVMb2FkZXJSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKG1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IG1hdGNoLnJvdXRlLm1vZHVsZS5sb2FkZXIgPyBjYWxsUm91dGVMb2FkZXIoe1xuICAgIGxvYWRDb250ZXh0LFxuICAgIG1hdGNoLFxuICAgIHJlcXVlc3RcbiAgfSkgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSkpOyAvLyBTdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGFjdGlvbi4gV2Ugd2lsbCB1c2UgdGhpcyB0byBkZXRlcm1pbmUgbGF0ZXJcbiAgLy8gd2hhdCBjYXRjaCBvciBlcnJvciBib3VuZGFyeSBzaG91bGQgYmUgcmVuZGVyZWQgdW5kZXIgY2FzZXMgd2hlcmVcbiAgLy8gYWN0aW9ucyBkb24ndCB0aHJvdyBidXQgbG9hZGVycyBkbywgYWN0aW9ucyB0aHJvdyBhbmQgcGFyZW50IGxvYWRlcnNcbiAgLy8gYWxzbyB0aHJvdywgZXRjLlxuXG4gIGxldCBhY3Rpb25DYXRjaCA9IGFwcFN0YXRlLmNhdGNoO1xuICBsZXQgYWN0aW9uRXJyb3IgPSBhcHBTdGF0ZS5lcnJvcjtcbiAgbGV0IGFjdGlvbkNhdGNoQm91bmRhcnlSb3V0ZUlkID0gYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQ7XG4gIGxldCBhY3Rpb25Mb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQ7IC8vIFJlc2V0IHRoZSBhcHAgZXJyb3IgYW5kIGNhdGNoIHN0YXRlIHRvIHByb3BvZ2F0ZSB0aGUgbG9hZGVyIHN0YXRlc1xuICAvLyBmcm9tIHRoZSByZXN1bHRzIGludG8gdGhlIGFwcCBzdGF0ZS5cblxuICBhcHBTdGF0ZS5jYXRjaCA9IHVuZGVmaW5lZDtcbiAgYXBwU3RhdGUuZXJyb3IgPSB1bmRlZmluZWQ7XG4gIGxldCByb3V0ZUxvYWRlclJlc3BvbnNlcyA9IFtdO1xuICBsZXQgbG9hZGVyU3RhdHVzQ29kZXMgPSBbXTtcbiAgbGV0IHJvdXRlRGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXRjaGVzVG9Mb2FkLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCBtYXRjaCA9IG1hdGNoZXNUb0xvYWRbaW5kZXhdO1xuICAgIGxldCByZXN1bHQgPSByb3V0ZUxvYWRlclJlc3VsdHNbaW5kZXhdO1xuICAgIGxldCBlcnJvciA9IHJlc3VsdC5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIiA/IHJlc3VsdC5yZWFzb24gOiB1bmRlZmluZWQ7XG4gICAgbGV0IHJlc3BvbnNlID0gcmVzdWx0LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiA/IHJlc3VsdC52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgaXNSZWRpcmVjdCA9IHJlc3BvbnNlID8gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSA6IGZhbHNlO1xuICAgIGxldCBpc0NhdGNoID0gcmVzcG9uc2UgPyBpc0NhdGNoUmVzcG9uc2UocmVzcG9uc2UpIDogZmFsc2U7IC8vIElmIGEgcGFyZW50IGxvYWRlciBoYXMgYWxyZWFkeSBjYXVnaHQgb3IgZXJyb3InZCwgYmFpbCBiZWNhdXNlXG4gICAgLy8gd2UgZG9uJ3QgbmVlZCBhbnkgbW9yZSBjaGlsZCBkYXRhLlxuXG4gICAgaWYgKGFwcFN0YXRlLmNhdGNoIHx8IGFwcFN0YXRlLmVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIHRoZXJlIGlzIGEgcmVzcG9uc2UgYW5kIGl0J3MgYSByZWRpcmVjdCwgZG8gaXQgdW5sZXNzIHRoZXJlXG4gICAgLy8gaXMgYW4gYWN0aW9uIGVycm9yIG9yIGNhdGNoIHN0YXRlLCB0aG9zZSBhY3Rpb24gYm91bmRhcnkgc3RhdGVzXG4gICAgLy8gdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9hZGVyIHNhdGVzLCB0aGlzIG1lYW5zIGlmIGEgbG9hZGVyIHJlZGlyZWN0c1xuICAgIC8vIGFmdGVyIGFuIGFjdGlvbiBjYXRjaGVzIG9yIGVycm9ycyB3ZSB3b24ndCBmb2xsb3cgaXQsIGFuZCBpbnN0ZWFkXG4gICAgLy8gcmVuZGVyIHRoZSBib3VuZGFyeSBjYXVzZWQgYnkgdGhlIGFjdGlvbi5cblxuXG4gICAgaWYgKCFhY3Rpb25DYXRjaCAmJiAhYWN0aW9uRXJyb3IgJiYgcmVzcG9uc2UgJiYgaXNSZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0gLy8gVHJhY2sgdGhlIGJvdW5kYXJ5IElEJ3MgZm9yIHRoZSBsb2FkZXJzXG5cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5tb2R1bGUuQ2F0Y2hCb3VuZGFyeSkge1xuICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gucm91dGUubW9kdWxlLkVycm9yQm91bmRhcnkpIHtcbiAgICAgIGFwcFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH1cblxuICAgIGlmIChlcnJvcikge1xuICAgICAgbG9hZGVyU3RhdHVzQ29kZXMucHVzaCg1MDApO1xuICAgICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICBhcHBTdGF0ZS5lcnJvciA9IGF3YWl0IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcblxuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3IgcnVubmluZyB0aGUgZGF0YSBsb2FkZXIgZm9yIHJvdXRlICR7bWF0Y2gucm91dGUuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHJvdXRlTG9hZGVyUmVzcG9uc2VzLnB1c2gocmVzcG9uc2UpO1xuICAgICAgbG9hZGVyU3RhdHVzQ29kZXMucHVzaChyZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgICBpZiAoaXNDYXRjaCkge1xuICAgICAgICAvLyBJZiBpdCdzIGEgY2F0Y2ggcmVzcG9uc2UsIHN0b3JlIGl0IGluIGFwcCBzdGF0ZSwgYW5kIGJhaWxcbiAgICAgICAgYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgICAgICAgYXBwU3RhdGUuY2F0Y2ggPSB7XG4gICAgICAgICAgZGF0YTogYXdhaXQgZXh0cmFjdERhdGEocmVzcG9uc2UpLFxuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeHRyYWN0IGFuZCBzdG9yZSB0aGUgbG9hZGVyIGRhdGFcbiAgICAgICAgcm91dGVEYXRhW21hdGNoLnJvdXRlLmlkXSA9IGF3YWl0IGV4dHJhY3REYXRhKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gSWYgdGhlcmUgd2FzIG5vdCBhIGxvYWRlciBjYXRjaCBvciBlcnJvciBzdGF0ZSB0cmlnZ2VyZWQgcmVzZXQgdGhlXG4gIC8vIGJvdW5kYXJpZXMgYXMgdGhleSBhcmUgcHJvYmFibHkgZGVlcGVyIGluIHRoZSB0cmVlIGlmIHRoZSBhY3Rpb25cbiAgLy8gaW5pdGlhbGx5IHRyaWdnZXJlZCBhIGJvdW5kYXJ5IGFzIHRoYXQgbWF0Y2ggd291bGQgbm90IGV4aXN0IGluIHRoZVxuICAvLyBtYXRjaGVzIHRvIGxvYWQuXG5cblxuICBpZiAoIWFwcFN0YXRlLmNhdGNoKSB7XG4gICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBhY3Rpb25DYXRjaEJvdW5kYXJ5Um91dGVJZDtcbiAgfVxuXG4gIGlmICghYXBwU3RhdGUuZXJyb3IpIHtcbiAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBhY3Rpb25Mb2FkZXJCb3VuZGFyeVJvdXRlSWQ7XG4gIH0gLy8gSWYgdGhlcmUgd2FzIGFuIGFjdGlvbiBlcnJvciBvciBjYXRjaCwgd2Ugd2lsbCByZXNldCB0aGUgc3RhdGUgdG8gdGhlXG4gIC8vIGluaXRpYWwgdmFsdWVzLCBvdGhlcndpc2Ugd2Ugd2lsbCB1c2Ugd2hhdGV2ZXIgY2FtZSBvdXQgb2YgdGhlIGxvYWRlcnMuXG5cblxuICBhcHBTdGF0ZS5jYXRjaCA9IGFjdGlvbkNhdGNoIHx8IGFwcFN0YXRlLmNhdGNoO1xuICBhcHBTdGF0ZS5lcnJvciA9IGFjdGlvbkVycm9yIHx8IGFwcFN0YXRlLmVycm9yO1xuICBsZXQgcmVuZGVyYWJsZU1hdGNoZXMgPSBnZXRSZW5kZXJhYmxlTWF0Y2hlcyhtYXRjaGVzLCBhcHBTdGF0ZSk7XG5cbiAgaWYgKCFyZW5kZXJhYmxlTWF0Y2hlcykge1xuICAgIHJlbmRlcmFibGVNYXRjaGVzID0gW107XG4gICAgbGV0IHJvb3QgPSByb3V0ZXNbMF07XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCAmJiByb290ICE9PSB2b2lkIDAgJiYgcm9vdC5tb2R1bGUuQ2F0Y2hCb3VuZGFyeSkge1xuICAgICAgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPSBcInJvb3RcIjtcbiAgICAgIHJlbmRlcmFibGVNYXRjaGVzLnB1c2goe1xuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgICAgcm91dGU6IHJvdXRlc1swXVxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIEhhbmRsZSByZXNwb25zZXMgd2l0aCBhIG5vbi0yMDAgc3RhdHVzIGNvZGUuIFRoZSBmaXJzdCBsb2FkZXIgd2l0aCBhXG4gIC8vIG5vbi0yMDAgc3RhdHVzIGNvZGUgZGV0ZXJtaW5lcyB0aGUgc3RhdHVzIGNvZGUgZm9yIHRoZSB3aG9sZSByZXNwb25zZS5cblxuXG4gIGxldCBub3RPa1Jlc3BvbnNlID0gYWN0aW9uU3RhdHVzICYmIGFjdGlvblN0YXR1cy5zdGF0dXMgIT09IDIwMCA/IGFjdGlvblN0YXR1cy5zdGF0dXMgOiBsb2FkZXJTdGF0dXNDb2Rlcy5maW5kKHN0YXR1cyA9PiBzdGF0dXMgIT09IDIwMCk7XG4gIGxldCByZXNwb25zZVN0YXR1c0NvZGUgPSBhcHBTdGF0ZS5lcnJvciA/IDUwMCA6IHR5cGVvZiBub3RPa1Jlc3BvbnNlID09PSBcIm51bWJlclwiID8gbm90T2tSZXNwb25zZSA6IGFwcFN0YXRlLmNhdGNoID8gYXBwU3RhdGUuY2F0Y2guc3RhdHVzIDogMjAwO1xuICBsZXQgcmVzcG9uc2VIZWFkZXJzID0gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCByZW5kZXJhYmxlTWF0Y2hlcywgcm91dGVMb2FkZXJSZXNwb25zZXMsIGFjdGlvblJlc3BvbnNlKTtcbiAgbGV0IGVudHJ5TWF0Y2hlcyA9IGNyZWF0ZUVudHJ5TWF0Y2hlcyhyZW5kZXJhYmxlTWF0Y2hlcywgYnVpbGQuYXNzZXRzLnJvdXRlcyk7XG4gIGxldCBzZXJ2ZXJIYW5kb2ZmID0ge1xuICAgIGFjdGlvbkRhdGEsXG4gICAgYXBwU3RhdGU6IGFwcFN0YXRlLFxuICAgIG1hdGNoZXM6IGVudHJ5TWF0Y2hlcyxcbiAgICByb3V0ZURhdGFcbiAgfTtcbiAgbGV0IGVudHJ5Q29udGV4dCA9IHsgLi4uc2VydmVySGFuZG9mZixcbiAgICBtYW5pZmVzdDogYnVpbGQuYXNzZXRzLFxuICAgIHJvdXRlTW9kdWxlcyxcbiAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpXG4gIH07XG4gIGxldCBoYW5kbGVEb2N1bWVudFJlcXVlc3QgPSBidWlsZC5lbnRyeS5tb2R1bGUuZGVmYXVsdDtcblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QocmVxdWVzdC5jbG9uZSgpLCByZXNwb25zZVN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgZW50cnlDb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXNwb25zZVN0YXR1c0NvZGUgPSA1MDA7IC8vIEdvIGFnYWluLCB0aGlzIHRpbWUgd2l0aCB0aGUgY29tcG9uZW50RGlkQ2F0Y2ggZW11bGF0aW9uLiBBcyBpdCByZW5kZXJlZFxuICAgIC8vIGxhc3QgdGltZSB3ZSBtdXRhdGVkIGBjb21wb25lbnREaWRDYXRjaC5yb3V0ZUlkYCBmb3IgdGhlIGxhc3QgcmVuZGVyZWRcbiAgICAvLyByb3V0ZSwgbm93IHdlIGtub3cgd2hlcmUgdG8gcmVuZGVyIHRoZSBlcnJvciBib3VuZGFyeSAoZmVlbHMgYSBsaXR0bGVcbiAgICAvLyBoYWNreSBidXQgdGhhdCdzIGhvdyBob29rcyB3b3JrKS4gVGhpcyB0ZWxscyB0aGUgZW11bGF0b3IgdG8gc3RvcFxuICAgIC8vIHRyYWNraW5nIHRoZSBgcm91dGVJZGAgYXMgd2UgcmVuZGVyIGJlY2F1c2Ugd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yIHRvXG4gICAgLy8gcmVuZGVyLlxuXG4gICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgYXBwU3RhdGUuZXJyb3IgPSBhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvcik7XG4gICAgZW50cnlDb250ZXh0LnNlcnZlckhhbmRvZmZTdHJpbmcgPSBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QocmVxdWVzdC5jbG9uZSgpLCByZXNwb25zZVN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgZW50cnlDb250ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCI7XG5cbiAgICAgIGlmIChzZXJ2ZXJNb2RlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50KSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7U3RyaW5nKGVycm9yKX1gO1xuICAgICAgfSAvLyBHb29kIGdyaWVmIGZvbGtzLCBnZXQgeW91ciBhY3QgdG9nZXRoZXIgXHVEODNEXHVERTAyIVxuXG5cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobWVzc2FnZSwge1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNvdXJjZVJlcXVlc3Qoe1xuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgc2VydmVyTW9kZVxufSkge1xuICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcblxuICB0cnkge1xuICAgIGlmIChpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsUm91dGVBY3Rpb24oe1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbFJvdXRlTG9hZGVyKHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgbGV0IG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCI7XG5cbiAgICBpZiAoc2VydmVyTW9kZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCkge1xuICAgICAgbWVzc2FnZSArPSBgXFxuXFxuJHtTdHJpbmcoZXJyb3IpfWA7XG4gICAgfSAvLyBHb29kIGdyaWVmIGZvbGtzLCBnZXQgeW91ciBhY3QgdG9nZXRoZXIgXHVEODNEXHVERTAyIVxuXG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICAgIHN0YXR1czogNTAwLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RUeXBlKHVybCwgbWF0Y2hlcykge1xuICBpZiAodXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJfZGF0YVwiKSkge1xuICAgIHJldHVybiBcImRhdGFcIjtcbiAgfVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBcImRvY3VtZW50XCI7XG4gIH1cblxuICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcblxuICBpZiAoIW1hdGNoLnJvdXRlLm1vZHVsZS5kZWZhdWx0KSB7XG4gICAgcmV0dXJuIFwicmVzb3VyY2VcIjtcbiAgfVxuXG4gIHJldHVybiBcImRvY3VtZW50XCI7XG59XG5cbmZ1bmN0aW9uIGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KSB7XG4gIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbWV0aG9kID09PSBcInBvc3RcIiB8fCBtZXRob2QgPT09IFwicHV0XCIgfHwgbWV0aG9kID09PSBcInBhdGNoXCIgfHwgbWV0aG9kID09PSBcImRlbGV0ZVwiO1xufVxuXG5mdW5jdGlvbiBpc0hlYWRSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiaGVhZFwiO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiIHx8IGlzSGVhZFJlcXVlc3QocmVxdWVzdCkgfHwgaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlcnJvckJvdW5kYXJ5RXJyb3IoZXJyb3IsIHN0YXR1cykge1xuICByZXR1cm4ganNvbihhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvciksIHtcbiAgICBzdGF0dXMsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJYLVJlbWl4LUVycm9yXCI6IFwieWVzXCJcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0luZGV4UmVxdWVzdFVybCh1cmwpIHtcbiAgbGV0IGluZGV4UmVxdWVzdCA9IGZhbHNlO1xuXG4gIGZvciAobGV0IHBhcmFtIG9mIHVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIikpIHtcbiAgICBpZiAoIXBhcmFtKSB7XG4gICAgICBpbmRleFJlcXVlc3QgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleFJlcXVlc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvblJlcXVlc3RNYXRjaCh1cmwsIG1hdGNoZXMpIHtcbiAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG5cbiAgaWYgKCFpc0luZGV4UmVxdWVzdFVybCh1cmwpICYmIG1hdGNoLnJvdXRlLmlkLmVuZHNXaXRoKFwiL2luZGV4XCIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoLTIpWzBdO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG5mdW5jdGlvbiBnZXREZWVwZXN0Um91dGVJZFdpdGhCb3VuZGFyeShtYXRjaGVzLCBrZXkpIHtcbiAgbGV0IG1hdGNoZWQgPSBnZXRNYXRjaGVzVXBUb0RlZXBlc3RCb3VuZGFyeShtYXRjaGVzLCBrZXkpLnNsaWNlKC0xKVswXTtcbiAgcmV0dXJuIG1hdGNoZWQgPyBtYXRjaGVkLnJvdXRlLmlkIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkobWF0Y2hlcywga2V5KSB7XG4gIGxldCBkZWVwZXN0Qm91bmRhcnlJbmRleCA9IC0xO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5tb2R1bGVba2V5XSkge1xuICAgICAgZGVlcGVzdEJvdW5kYXJ5SW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkZWVwZXN0Qm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAvLyBubyByb3V0ZSBlcnJvciBib3VuZGFyaWVzLCBkb24ndCBuZWVkIHRvIGNhbGwgYW55IGxvYWRlcnNcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBkZWVwZXN0Qm91bmRhcnlJbmRleCArIDEpO1xufSAvLyBUaGlzIHByZXZlbnRzIGA8T3V0bGV0Lz5gIGZyb20gcmVuZGVyaW5nIGFueXRoaW5nIGJlbG93IHdoZXJlIHRoZSBlcnJvciB0aHJld1xuLy8gVE9ETzogbWF5YmUgZG8gdGhpcyBpbiA8UmVtaXhFcnJvckJvdW5kYXJ5ICsgY29udGV4dD5cblxuXG5mdW5jdGlvbiBnZXRSZW5kZXJhYmxlTWF0Y2hlcyhtYXRjaGVzLCBhcHBTdGF0ZSkge1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBubyBlcnJvciwgbm8gd29ycmllc1xuXG5cbiAgaWYgKCFhcHBTdGF0ZS5jYXRjaCAmJiAhYXBwU3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuXG4gIGxldCBsYXN0UmVuZGVyYWJsZUluZGV4ID0gLTE7XG4gIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG5cbiAgICBpZiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkIHx8IGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBpZCkge1xuICAgICAgbGFzdFJlbmRlcmFibGVJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIGxhc3RSZW5kZXJhYmxlSW5kZXggKyAxKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUmVxdWVzdEhhbmRsZXIgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMS4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGlzUmVzcG9uc2UsIGlzUmVkaXJlY3RSZXNwb25zZSwganNvbiB9IGZyb20gJy4vcmVzcG9uc2VzLmpzJztcblxuLyoqXG4gKiBBbiBvYmplY3Qgb2YgYXJiaXRyYXJ5IGZvciByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHByb3ZpZGVkIGJ5IHRoZVxuICogc2VydmVyJ3MgYGdldExvYWRDb250ZXh0KClgIGZ1bmN0aW9uLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxSb3V0ZUFjdGlvbih7XG4gIGxvYWRDb250ZXh0LFxuICBtYXRjaCxcbiAgcmVxdWVzdFxufSkge1xuICBsZXQgYWN0aW9uID0gbWF0Y2gucm91dGUubW9kdWxlLmFjdGlvbjtcblxuICBpZiAoIWFjdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG1hZGUgYSAke3JlcXVlc3QubWV0aG9kfSByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGJ1dCBkaWQgbm90IHByb3ZpZGUgYCArIGBhbiBcXGBhY3Rpb25cXGAgZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgYCArIGByZXF1ZXN0LmApO1xuICB9XG5cbiAgbGV0IHJlc3VsdDtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGFjdGlvbih7XG4gICAgICByZXF1ZXN0OiBzdHJpcERhdGFQYXJhbShzdHJpcEluZGV4UGFyYW0ocmVxdWVzdC5jbG9uZSgpKSksXG4gICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1JlZGlyZWN0UmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBlcnJvci5oZWFkZXJzLnNldChcIlgtUmVtaXgtQ2F0Y2hcIiwgXCJ5ZXNcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gZXJyb3I7XG4gIH1cblxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBkZWZpbmVkIGFuIGFjdGlvbiBmb3Igcm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGAgKyBgYW55dGhpbmcgZnJvbSB5b3VyIFxcYGFjdGlvblxcYCBmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIFxcYG51bGxcXGAuYCk7XG4gIH1cblxuICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0IDoganNvbihyZXN1bHQpO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbFJvdXRlTG9hZGVyKHtcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoLFxuICByZXF1ZXN0XG59KSB7XG4gIGxldCBsb2FkZXIgPSBtYXRjaC5yb3V0ZS5tb2R1bGUubG9hZGVyO1xuXG4gIGlmICghbG9hZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbWFkZSBhICR7cmVxdWVzdC5tZXRob2R9IHJlcXVlc3QgdG8gJHtyZXF1ZXN0LnVybH0gYnV0IGRpZCBub3QgcHJvdmlkZSBgICsgYGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIGAgKyBgcmVxdWVzdC5gKTtcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBsb2FkZXIoe1xuICAgICAgcmVxdWVzdDogc3RyaXBEYXRhUGFyYW0oc3RyaXBJbmRleFBhcmFtKHJlcXVlc3QuY2xvbmUoKSkpLFxuICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtc1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghaXNSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmICghaXNSZWRpcmVjdFJlc3BvbnNlKGVycm9yKSkge1xuICAgICAgZXJyb3IuaGVhZGVycy5zZXQoXCJYLVJlbWl4LUNhdGNoXCIsIFwieWVzXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGVycm9yO1xuICB9XG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgZGVmaW5lZCBhbiBhY3Rpb24gZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBidXQgZGlkbid0IHJldHVybiBgICsgYGFueXRoaW5nIGZyb20geW91ciBcXGBhY3Rpb25cXGAgZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBcXGBudWxsXFxgLmApO1xuICB9XG5cbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IGpzb24ocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcblxuICBmb3IgKGxldCBpbmRleFZhbHVlIG9mIGluZGV4VmFsdWVzKSB7XG4gICAgaWYgKGluZGV4VmFsdWUpIHtcbiAgICAgIGluZGV4VmFsdWVzVG9LZWVwLnB1c2goaW5kZXhWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgdG9LZWVwIG9mIGluZGV4VmFsdWVzVG9LZWVwKSB7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB0b0tlZXApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCByZXF1ZXN0KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBEYXRhUGFyYW0ocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiX2RhdGFcIik7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgcmVxdWVzdCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3BvbnNlKSB7XG4gIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuXG4gIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0gLy8gV2hhdCBvdGhlciBkYXRhIHR5cGVzIGRvIHdlIG5lZWQgdG8gaGFuZGxlIGhlcmU/IFdoYXQgb3RoZXIga2luZHMgb2ZcbiAgLy8gcmVzcG9uc2VzIGFyZSBwZW9wbGUgZ29pbmcgdG8gYmUgcmV0dXJuaW5nIGZyb20gdGhlaXIgbG9hZGVycz9cbiAgLy8gLSBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgP1xuICAvLyAtIG11bHRpcGFydC9mb3JtLWRhdGEgP1xuICAvLyAtIGJpbmFyeSAoYXVkaW8vdmlkZW8pID9cblxuXG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmV4cG9ydCB7IGNhbGxSb3V0ZUFjdGlvbiwgY2FsbFJvdXRlTG9hZGVyLCBleHRyYWN0RGF0YSB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4xLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW50cnlNYXRjaGVzKG1hdGNoZXMsIHJvdXRlcykge1xuICByZXR1cm4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IHJvdXRlc1ttYXRjaC5yb3V0ZS5pZF1cbiAgfSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMobWFuaWZlc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5yZWR1Y2UoKG1lbW8sIHJvdXRlSWQpID0+IHtcbiAgICBtZW1vW3JvdXRlSWRdID0gbWFuaWZlc3Rbcm91dGVJZF0ubW9kdWxlO1xuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUVudHJ5TWF0Y2hlcywgY3JlYXRlRW50cnlSb3V0ZU1vZHVsZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMS4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogVGhpcyB0aGluZyBwcm9iYWJseSB3YXJyYW50cyBzb21lIGV4cGxhbmF0aW9uLlxuICpcbiAqIFRoZSB3aG9sZSBwb2ludCBoZXJlIGlzIHRvIGVtdWxhdGUgY29tcG9uZW50RGlkQ2F0Y2ggZm9yIHNlcnZlciByZW5kZXJpbmcgYW5kXG4gKiBkYXRhIGxvYWRpbmcuIEl0IGNhbiBnZXQgdHJpY2t5LiBSZWFjdCBjYW4gZG8gdGhpcyBvbiBjb21wb25lbnQgYm91bmRhcmllc1xuICogYnV0IGRvZXNuJ3Qgc3VwcG9ydCBpdCBmb3Igc2VydmVyIHJlbmRlcmluZyBvciBkYXRhIGxvYWRpbmcuIFdlIGtub3cgZW5vdWdoXG4gKiB3aXRoIG5lc3RlZCByb3V0ZXMgdG8gYmUgYWJsZSB0byBlbXVsYXRlIHRoZSBiZWhhdmlvciAoYmVjYXVzZSB3ZSBrbm93IHRoZW1cbiAqIHN0YXRpY2FsbHkgYmVmb3JlIHJlbmRlcmluZy4pXG4gKlxuICogRWFjaCByb3V0ZSBjYW4gZXhwb3J0IGFuIGBFcnJvckJvdW5kYXJ5YC5cbiAqXG4gKiAtIFdoZW4gcmVuZGVyaW5nIHRocm93cyBhbiBlcnJvciwgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgd2lsbCByZW5kZXJcbiAqICAgKG5vcm1hbCByZWFjdCBjb21wb25lbnREaWRDYXRjaCkuIFRoaXMgd2lsbCBiZSB0aGUgcm91dGUncyBvd24gYm91bmRhcnksIGJ1dFxuICogICBpZiBub25lIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJ1YmJsZSB1cCB0byB0aGUgcGFyZW50cy5cbiAqIC0gV2hlbiBkYXRhIGxvYWRpbmcgdGhyb3dzIGFuIGVycm9yLCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSB3aWxsIHJlbmRlclxuICogLSBXaGVuIHBlcmZvcm1pbmcgYW4gYWN0aW9uLCB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSBmb3IgdGhlIGFjdGlvbidzXG4gKiAgIHJvdXRlIHRyZWUgd2lsbCByZW5kZXIgKG5vIHJlZGlyZWN0IGhhcHBlbnMpXG4gKlxuICogRHVyaW5nIG5vcm1hbCByZWFjdCByZW5kZXJpbmcsIHdlIGRvIG5vdGhpbmcgc3BlY2lhbCwganVzdCBub3JtYWxcbiAqIGNvbXBvbmVudERpZENhdGNoLlxuICpcbiAqIEZvciBzZXJ2ZXIgcmVuZGVyaW5nLCB3ZSBtdXRhdGUgYHJlbmRlckJvdW5kYXJ5Um91dGVJZGAgdG8ga25vdyB0aGUgbGFzdFxuICogbGF5b3V0IHRoYXQgaGFzIGFuIGVycm9yIGJvdW5kYXJ5IHRoYXQgdHJpZWQgdG8gcmVuZGVyLiBUaGlzIGVtdWxhdGVzIHdoaWNoXG4gKiBsYXlvdXQgd291bGQgY2F0Y2ggYSB0aHJvd24gZXJyb3IuIElmIHRoZSByZW5kZXJpbmcgZmFpbHMsIHdlIGNhdGNoIHRoZSBlcnJvclxuICogb24gdGhlIHNlcnZlciwgYW5kIGdvIGFnYWluIGEgc2Vjb25kIHRpbWUgd2l0aCB0aGUgZW11bGF0b3IgaG9sZGluZyBvbiB0byB0aGVcbiAqIGluZm9ybWF0aW9uIGl0IG5lZWRzIHRvIHJlbmRlciB0aGUgc2FtZSBlcnJvciBib3VuZGFyeSBhcyBhIGR5bmFtaWNhbGx5XG4gKiB0aHJvd24gcmVuZGVyIGVycm9yLlxuICpcbiAqIFdoZW4gZGF0YSBsb2FkaW5nLCBzZXJ2ZXIgb3IgY2xpZW50IHNpZGUsIHdlIHVzZSB0aGUgZW11bGF0b3IgdG8gbGlrZXdpc2VcbiAqIGhhbmcgb24gdG8gdGhlIGVycm9yIGFuZCByZS1yZW5kZXIgYXQgdGhlIGFwcHJvcHJpYXRlIGxheW91dCAod2hlcmUgYSB0aHJvd25cbiAqIGVycm9yIHdvdWxkIGhhdmUgYmVlbiBjYXVnaHQgYnkgY0RDKS5cbiAqXG4gKiBXaGVuIGFjdGlvbnMgdGhyb3csIGl0IGFsbCB3b3JrcyB0aGUgc2FtZS4gVGhlcmUncyBhbiBlZGdlIGNhc2UgdG8gYmUgYXdhcmVcbiAqIG9mIHRob3VnaC4gQWN0aW9ucyBub3JtYWxseSBhcmUgcmVxdWlyZWQgdG8gcmVkaXJlY3QsIGJ1dCBpbiB0aGUgY2FzZSBvZlxuICogZXJyb3JzLCB3ZSByZW5kZXIgdGhlIGFjdGlvbidzIHJvdXRlIHdpdGggdGhlIGVtdWxhdG9yIGhvbGRpbmcgb24gdG8gdGhlXG4gKiBlcnJvci4gSWYgZHVyaW5nIHRoaXMgcmVuZGVyIGEgcGFyZW50IHJvdXRlL2xvYWRlciB0aHJvd3Mgd2UgaWdub3JlIHRoYXQgbmV3XG4gKiBlcnJvciBhbmQgcmVuZGVyIHRoZSBhY3Rpb24ncyBvcmlnaW5hbCBlcnJvciBhcyBkZWVwbHkgYXMgcG9zc2libGUuIEluIG90aGVyXG4gKiB3b3Jkcywgd2Ugc2ltcGx5IGlnbm9yZSB0aGUgbmV3IGVycm9yIGFuZCB1c2UgdGhlIGFjdGlvbidzIGVycm9yIGluIHBsYWNlXG4gKiBiZWNhdXNlIGl0IGNhbWUgZmlyc3QsIGFuZCB0aGF0IGp1c3Qgd291bGRuJ3QgYmUgZmFpciB0byBsZXQgZXJyb3JzIGN1dCBpblxuICogbGluZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICB9O1xufVxuXG5leHBvcnQgeyBzZXJpYWxpemVFcnJvciB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4xLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgc3BsaXRDb29raWVzU3RyaW5nIH0gZnJvbSAnc2V0LWNvb2tpZS1wYXJzZXInO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIG1hdGNoZXMsIHJvdXRlTG9hZGVyUmVzcG9uc2VzLCBhY3Rpb25SZXNwb25zZSkge1xuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoKHBhcmVudEhlYWRlcnMsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IGJ1aWxkLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlO1xuICAgIGxldCBsb2FkZXJIZWFkZXJzID0gcm91dGVMb2FkZXJSZXNwb25zZXNbaW5kZXhdID8gcm91dGVMb2FkZXJSZXNwb25zZXNbaW5kZXhdLmhlYWRlcnMgOiBuZXcgSGVhZGVycygpO1xuICAgIGxldCBhY3Rpb25IZWFkZXJzID0gYWN0aW9uUmVzcG9uc2UgPyBhY3Rpb25SZXNwb25zZS5oZWFkZXJzIDogbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJvdXRlTW9kdWxlLmhlYWRlcnMgPyB0eXBlb2Ygcm91dGVNb2R1bGUuaGVhZGVycyA9PT0gXCJmdW5jdGlvblwiID8gcm91dGVNb2R1bGUuaGVhZGVycyh7XG4gICAgICBsb2FkZXJIZWFkZXJzLFxuICAgICAgcGFyZW50SGVhZGVycyxcbiAgICAgIGFjdGlvbkhlYWRlcnNcbiAgICB9KSA6IHJvdXRlTW9kdWxlLmhlYWRlcnMgOiB1bmRlZmluZWQpOyAvLyBBdXRvbWF0aWNhbGx5IHByZXNlcnZlIFNldC1Db29raWUgaGVhZGVycyB0aGF0IHdlcmUgc2V0IGVpdGhlciBieSB0aGVcbiAgICAvLyBsb2FkZXIgb3IgYnkgYSBwYXJlbnQgcm91dGUuXG5cbiAgICBwcmVwZW5kQ29va2llcyhhY3Rpb25IZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhsb2FkZXJIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGNoaWxkSGVhZGVycykge1xuICBsZXQgcGFyZW50U2V0Q29va2llU3RyaW5nID0gcGFyZW50SGVhZGVycy5nZXQoXCJTZXQtQ29va2llXCIpO1xuXG4gIGlmIChwYXJlbnRTZXRDb29raWVTdHJpbmcpIHtcbiAgICBsZXQgY29va2llcyA9IHNwbGl0Q29va2llc1N0cmluZyhwYXJlbnRTZXRDb29raWVTdHJpbmcpO1xuICAgIGNvb2tpZXMuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgY2hpbGRIZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXREb2N1bWVudEhlYWRlcnMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMS4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IG1hdGNoUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbi8vIFRPRE86IGV4cG9ydC9pbXBvcnQgZnJvbSByZWFjdC1yb3V0ZXItZG9tXG5mdW5jdGlvbiBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCBwYXRobmFtZSk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBtYXRjaFNlcnZlclJvdXRlcyB9O1xuIiwgImltcG9ydCBfZXh0ZW5kcyBmcm9tJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO3ZhciByLEI9cnx8KHI9e30pO0IuUG9wPVwiUE9QXCI7Qi5QdXNoPVwiUFVTSFwiO0IuUmVwbGFjZT1cIlJFUExBQ0VcIjt2YXIgQz1cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP2Z1bmN0aW9uKGIpe3JldHVybiBPYmplY3QuZnJlZXplKGIpfTpmdW5jdGlvbihiKXtyZXR1cm4gYn07ZnVuY3Rpb24gRChiLGgpe2lmKCFiKXtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUud2FybihoKTt0cnl7dGhyb3cgRXJyb3IoaCk7fWNhdGNoKGUpe319fWZ1bmN0aW9uIEUoYil7Yi5wcmV2ZW50RGVmYXVsdCgpO2IucmV0dXJuVmFsdWU9XCJcIn1cbmZ1bmN0aW9uIEYoKXt2YXIgYj1bXTtyZXR1cm57Z2V0IGxlbmd0aCgpe3JldHVybiBiLmxlbmd0aH0scHVzaDpmdW5jdGlvbihoKXtiLnB1c2goaCk7cmV0dXJuIGZ1bmN0aW9uKCl7Yj1iLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSE9PWh9KX19LGNhbGw6ZnVuY3Rpb24oaCl7Yi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlKGgpfSl9fX1mdW5jdGlvbiBIKCl7cmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLDgpfWZ1bmN0aW9uIEkoYil7dmFyIGg9Yi5wYXRobmFtZTtoPXZvaWQgMD09PWg/XCIvXCI6aDt2YXIgZT1iLnNlYXJjaDtlPXZvaWQgMD09PWU/XCJcIjplO2I9Yi5oYXNoO2I9dm9pZCAwPT09Yj9cIlwiOmI7ZSYmXCI/XCIhPT1lJiYoaCs9XCI/XCI9PT1lLmNoYXJBdCgwKT9lOlwiP1wiK2UpO2ImJlwiI1wiIT09YiYmKGgrPVwiI1wiPT09Yi5jaGFyQXQoMCk/YjpcIiNcIitiKTtyZXR1cm4gaH1cbmZ1bmN0aW9uIEooYil7dmFyIGg9e307aWYoYil7dmFyIGU9Yi5pbmRleE9mKFwiI1wiKTswPD1lJiYoaC5oYXNoPWIuc3Vic3RyKGUpLGI9Yi5zdWJzdHIoMCxlKSk7ZT1iLmluZGV4T2YoXCI/XCIpOzA8PWUmJihoLnNlYXJjaD1iLnN1YnN0cihlKSxiPWIuc3Vic3RyKDAsZSkpO2ImJihoLnBhdGhuYW1lPWIpfXJldHVybiBofVxuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoYil7ZnVuY3Rpb24gaCgpe3ZhciBjPXAubG9jYXRpb24sYT1tLnN0YXRlfHx7fTtyZXR1cm5bYS5pZHgsQyh7cGF0aG5hbWU6Yy5wYXRobmFtZSxzZWFyY2g6Yy5zZWFyY2gsaGFzaDpjLmhhc2gsc3RhdGU6YS51c3J8fG51bGwsa2V5OmEua2V5fHxcImRlZmF1bHRcIn0pXX1mdW5jdGlvbiBlKGMpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYz9jOkkoYyl9ZnVuY3Rpb24geChjLGEpe3ZvaWQgMD09PWEmJihhPW51bGwpO3JldHVybiBDKF9leHRlbmRzKHtwYXRobmFtZTpxLnBhdGhuYW1lLGhhc2g6XCJcIixzZWFyY2g6XCJcIn0sXCJzdHJpbmdcIj09PXR5cGVvZiBjP0ooYyk6Yyx7c3RhdGU6YSxrZXk6SCgpfSkpfWZ1bmN0aW9uIHooYyl7dD1jO2M9aCgpO3Y9Y1swXTtxPWNbMV07ZC5jYWxsKHthY3Rpb246dCxsb2NhdGlvbjpxfSl9ZnVuY3Rpb24gQShjLGEpe2Z1bmN0aW9uIGYoKXtBKGMsYSl9dmFyIGw9ci5QdXNoLGs9eChjLFxuYSk7aWYoIWcubGVuZ3RofHwoZy5jYWxsKHthY3Rpb246bCxsb2NhdGlvbjprLHJldHJ5OmZ9KSwhMSkpe3ZhciBuPVt7dXNyOmsuc3RhdGUsa2V5Omsua2V5LGlkeDp2KzF9LGUoayldO2s9blswXTtuPW5bMV07dHJ5e20ucHVzaFN0YXRlKGssXCJcIixuKX1jYXRjaChHKXtwLmxvY2F0aW9uLmFzc2lnbihuKX16KGwpfX1mdW5jdGlvbiB5KGMsYSl7ZnVuY3Rpb24gZigpe3koYyxhKX12YXIgbD1yLlJlcGxhY2Usaz14KGMsYSk7Zy5sZW5ndGgmJihnLmNhbGwoe2FjdGlvbjpsLGxvY2F0aW9uOmsscmV0cnk6Zn0pLDEpfHwoaz1be3VzcjprLnN0YXRlLGtleTprLmtleSxpZHg6dn0sZShrKV0sbS5yZXBsYWNlU3RhdGUoa1swXSxcIlwiLGtbMV0pLHoobCkpfWZ1bmN0aW9uIHcoYyl7bS5nbyhjKX12b2lkIDA9PT1iJiYoYj17fSk7Yj1iLndpbmRvdzt2YXIgcD12b2lkIDA9PT1iP2RvY3VtZW50LmRlZmF1bHRWaWV3OmIsbT1wLmhpc3RvcnksdT1udWxsO3AuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsXG5mdW5jdGlvbigpe2lmKHUpZy5jYWxsKHUpLHU9bnVsbDtlbHNle3ZhciBjPXIuUG9wLGE9aCgpLGY9YVswXTthPWFbMV07aWYoZy5sZW5ndGgpaWYobnVsbCE9Zil7dmFyIGw9di1mO2wmJih1PXthY3Rpb246Yyxsb2NhdGlvbjphLHJldHJ5OmZ1bmN0aW9uKCl7dygtMSpsKX19LHcobCkpfWVsc2VcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoITEsXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLCBidXQgaW4gZ2VuZXJhbCB5b3Ugc2hvdWxkIGRvIGFsbCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIHRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKTpcbnZvaWQgMDtlbHNlIHooYyl9fSk7dmFyIHQ9ci5Qb3A7Yj1oKCk7dmFyIHY9YlswXSxxPWJbMV0sZD1GKCksZz1GKCk7bnVsbD09diYmKHY9MCxtLnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSxtLnN0YXRlLHtpZHg6dn0pLFwiXCIpKTtyZXR1cm57Z2V0IGFjdGlvbigpe3JldHVybiB0fSxnZXQgbG9jYXRpb24oKXtyZXR1cm4gcX0sY3JlYXRlSHJlZjplLHB1c2g6QSxyZXBsYWNlOnksZ286dyxiYWNrOmZ1bmN0aW9uKCl7dygtMSl9LGZvcndhcmQ6ZnVuY3Rpb24oKXt3KDEpfSxsaXN0ZW46ZnVuY3Rpb24oYyl7cmV0dXJuIGQucHVzaChjKX0sYmxvY2s6ZnVuY3Rpb24oYyl7dmFyIGE9Zy5wdXNoKGMpOzE9PT1nLmxlbmd0aCYmcC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsRSk7cmV0dXJuIGZ1bmN0aW9uKCl7YSgpO2cubGVuZ3RofHxwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIixFKX19fX07XG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShiKXtmdW5jdGlvbiBoKCl7dmFyIGE9SihtLmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKSxmPWEucGF0aG5hbWUsbD1hLnNlYXJjaDthPWEuaGFzaDt2YXIgaz11LnN0YXRlfHx7fTtyZXR1cm5bay5pZHgsQyh7cGF0aG5hbWU6dm9pZCAwPT09Zj9cIi9cIjpmLHNlYXJjaDp2b2lkIDA9PT1sP1wiXCI6bCxoYXNoOnZvaWQgMD09PWE/XCJcIjphLHN0YXRlOmsudXNyfHxudWxsLGtleTprLmtleXx8XCJkZWZhdWx0XCJ9KV19ZnVuY3Rpb24gZSgpe2lmKHQpYy5jYWxsKHQpLHQ9bnVsbDtlbHNle3ZhciBhPXIuUG9wLGY9aCgpLGw9ZlswXTtmPWZbMV07aWYoYy5sZW5ndGgpaWYobnVsbCE9bCl7dmFyIGs9cS1sO2smJih0PXthY3Rpb246YSxsb2NhdGlvbjpmLHJldHJ5OmZ1bmN0aW9uKCl7cCgtMSprKX19LHAoaykpfWVsc2VcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP0QoITEsXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLCBidXQgaW4gZ2VuZXJhbCB5b3Ugc2hvdWxkIGRvIGFsbCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIHRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKTpcbnZvaWQgMDtlbHNlIEEoYSl9fWZ1bmN0aW9uIHgoYSl7dmFyIGY9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIiksbD1cIlwiO2YmJmYuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSYmKGY9bS5sb2NhdGlvbi5ocmVmLGw9Zi5pbmRleE9mKFwiI1wiKSxsPS0xPT09bD9mOmYuc2xpY2UoMCxsKSk7cmV0dXJuIGwrXCIjXCIrKFwic3RyaW5nXCI9PT10eXBlb2YgYT9hOkkoYSkpfWZ1bmN0aW9uIHooYSxmKXt2b2lkIDA9PT1mJiYoZj1udWxsKTtyZXR1cm4gQyhfZXh0ZW5kcyh7cGF0aG5hbWU6ZC5wYXRobmFtZSxoYXNoOlwiXCIsc2VhcmNoOlwiXCJ9LFwic3RyaW5nXCI9PT10eXBlb2YgYT9KKGEpOmEse3N0YXRlOmYsa2V5OkgoKX0pKX1mdW5jdGlvbiBBKGEpe3Y9YTthPWgoKTtxPWFbMF07ZD1hWzFdO2cuY2FsbCh7YWN0aW9uOnYsbG9jYXRpb246ZH0pfWZ1bmN0aW9uIHkoYSxmKXtmdW5jdGlvbiBsKCl7eShhLGYpfXZhciBrPXIuUHVzaCxuPXooYSxmKTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP1xuRChcIi9cIj09PW4ucGF0aG5hbWUuY2hhckF0KDApLFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKFwiK0pTT04uc3RyaW5naWZ5KGEpK1wiKVwiKTp2b2lkIDA7aWYoIWMubGVuZ3RofHwoYy5jYWxsKHthY3Rpb246ayxsb2NhdGlvbjpuLHJldHJ5Omx9KSwhMSkpe3ZhciBHPVt7dXNyOm4uc3RhdGUsa2V5Om4ua2V5LGlkeDpxKzF9LHgobildO249R1swXTtHPUdbMV07dHJ5e3UucHVzaFN0YXRlKG4sXCJcIixHKX1jYXRjaChLKXttLmxvY2F0aW9uLmFzc2lnbihHKX1BKGspfX1mdW5jdGlvbiB3KGEsZil7ZnVuY3Rpb24gbCgpe3coYSxmKX12YXIgaz1yLlJlcGxhY2Usbj16KGEsZik7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKFwiL1wiPT09bi5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnJlcGxhY2UoXCIrSlNPTi5zdHJpbmdpZnkoYSkrXG5cIilcIik6dm9pZCAwO2MubGVuZ3RoJiYoYy5jYWxsKHthY3Rpb246ayxsb2NhdGlvbjpuLHJldHJ5Omx9KSwxKXx8KG49W3t1c3I6bi5zdGF0ZSxrZXk6bi5rZXksaWR4OnF9LHgobildLHUucmVwbGFjZVN0YXRlKG5bMF0sXCJcIixuWzFdKSxBKGspKX1mdW5jdGlvbiBwKGEpe3UuZ28oYSl9dm9pZCAwPT09YiYmKGI9e30pO2I9Yi53aW5kb3c7dmFyIG09dm9pZCAwPT09Yj9kb2N1bWVudC5kZWZhdWx0VmlldzpiLHU9bS5oaXN0b3J5LHQ9bnVsbDttLmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLGUpO20uYWRkRXZlbnRMaXN0ZW5lcihcImhhc2hjaGFuZ2VcIixmdW5jdGlvbigpe3ZhciBhPWgoKVsxXTtJKGEpIT09SShkKSYmZSgpfSk7dmFyIHY9ci5Qb3A7Yj1oKCk7dmFyIHE9YlswXSxkPWJbMV0sZz1GKCksYz1GKCk7bnVsbD09cSYmKHE9MCx1LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSx1LnN0YXRlLHtpZHg6cX0pLFwiXCIpKTtyZXR1cm57Z2V0IGFjdGlvbigpe3JldHVybiB2fSxnZXQgbG9jYXRpb24oKXtyZXR1cm4gZH0sXG5jcmVhdGVIcmVmOngscHVzaDp5LHJlcGxhY2U6dyxnbzpwLGJhY2s6ZnVuY3Rpb24oKXtwKC0xKX0sZm9yd2FyZDpmdW5jdGlvbigpe3AoMSl9LGxpc3RlbjpmdW5jdGlvbihhKXtyZXR1cm4gZy5wdXNoKGEpfSxibG9jazpmdW5jdGlvbihhKXt2YXIgZj1jLnB1c2goYSk7MT09PWMubGVuZ3RoJiZtLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIixFKTtyZXR1cm4gZnVuY3Rpb24oKXtmKCk7Yy5sZW5ndGh8fG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLEUpfX19fTtcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoYil7ZnVuY3Rpb24gaChkLGcpe3ZvaWQgMD09PWcmJihnPW51bGwpO3JldHVybiBDKF9leHRlbmRzKHtwYXRobmFtZTp0LnBhdGhuYW1lLHNlYXJjaDpcIlwiLGhhc2g6XCJcIn0sXCJzdHJpbmdcIj09PXR5cGVvZiBkP0ooZCk6ZCx7c3RhdGU6ZyxrZXk6SCgpfSkpfWZ1bmN0aW9uIGUoZCxnLGMpe3JldHVybiFxLmxlbmd0aHx8KHEuY2FsbCh7YWN0aW9uOmQsbG9jYXRpb246ZyxyZXRyeTpjfSksITEpfWZ1bmN0aW9uIHgoZCxnKXt1PWQ7dD1nO3YuY2FsbCh7YWN0aW9uOnUsbG9jYXRpb246dH0pfWZ1bmN0aW9uIHooZCxnKXt2YXIgYz1yLlB1c2gsYT1oKGQsZyk7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKFwiL1wiPT09dC5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucHVzaChcIitKU09OLnN0cmluZ2lmeShkKStcIilcIik6XG52b2lkIDA7ZShjLGEsZnVuY3Rpb24oKXt6KGQsZyl9KSYmKG0rPTEscC5zcGxpY2UobSxwLmxlbmd0aCxhKSx4KGMsYSkpfWZ1bmN0aW9uIEEoZCxnKXt2YXIgYz1yLlJlcGxhY2UsYT1oKGQsZyk7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9EKFwiL1wiPT09dC5wYXRobmFtZS5jaGFyQXQoMCksXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucmVwbGFjZShcIitKU09OLnN0cmluZ2lmeShkKStcIilcIik6dm9pZCAwO2UoYyxhLGZ1bmN0aW9uKCl7QShkLGcpfSkmJihwW21dPWEseChjLGEpKX1mdW5jdGlvbiB5KGQpe3ZhciBnPU1hdGgubWluKE1hdGgubWF4KG0rZCwwKSxwLmxlbmd0aC0xKSxjPXIuUG9wLGE9cFtnXTtlKGMsYSxmdW5jdGlvbigpe3koZCl9KSYmKG09Zyx4KGMsYSkpfXZvaWQgMD09PWImJihiPXt9KTt2YXIgdz1iO2I9dy5pbml0aWFsRW50cmllczt3PXcuaW5pdGlhbEluZGV4O3ZhciBwPSh2b2lkIDA9PT1cbmI/W1wiL1wiXTpiKS5tYXAoZnVuY3Rpb24oZCl7dmFyIGc9QyhfZXh0ZW5kcyh7cGF0aG5hbWU6XCIvXCIsc2VhcmNoOlwiXCIsaGFzaDpcIlwiLHN0YXRlOm51bGwsa2V5OkgoKX0sXCJzdHJpbmdcIj09PXR5cGVvZiBkP0ooZCk6ZCkpO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/RChcIi9cIj09PWcucGF0aG5hbWUuY2hhckF0KDApLFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNyZWF0ZU1lbW9yeUhpc3RvcnkoeyBpbml0aWFsRW50cmllcyB9KSAoaW52YWxpZCBlbnRyeTogXCIrSlNPTi5zdHJpbmdpZnkoZCkrXCIpXCIpOnZvaWQgMDtyZXR1cm4gZ30pLG09TWF0aC5taW4oTWF0aC5tYXgobnVsbD09dz9wLmxlbmd0aC0xOncsMCkscC5sZW5ndGgtMSksdT1yLlBvcCx0PXBbbV0sdj1GKCkscT1GKCk7cmV0dXJue2dldCBpbmRleCgpe3JldHVybiBtfSxnZXQgYWN0aW9uKCl7cmV0dXJuIHV9LGdldCBsb2NhdGlvbigpe3JldHVybiB0fSxjcmVhdGVIcmVmOmZ1bmN0aW9uKGQpe3JldHVyblwic3RyaW5nXCI9PT1cbnR5cGVvZiBkP2Q6SShkKX0scHVzaDp6LHJlcGxhY2U6QSxnbzp5LGJhY2s6ZnVuY3Rpb24oKXt5KC0xKX0sZm9yd2FyZDpmdW5jdGlvbigpe3koMSl9LGxpc3RlbjpmdW5jdGlvbihkKXtyZXR1cm4gdi5wdXNoKGQpfSxibG9jazpmdW5jdGlvbihkKXtyZXR1cm4gcS5wdXNoKGQpfX19O2V4cG9ydHtyIGFzIEFjdGlvbixjcmVhdGVCcm93c2VySGlzdG9yeSxjcmVhdGVIYXNoSGlzdG9yeSxjcmVhdGVNZW1vcnlIaXN0b3J5LEkgYXMgY3JlYXRlUGF0aCxKIGFzIHBhcnNlUGF0aH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBIaXN0b3J5LFxuICBJbml0aWFsRW50cnksXG4gIExvY2F0aW9uLFxuICBNZW1vcnlIaXN0b3J5LFxuICBQYXRoLFxuICBUb1xufSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBjcmVhdGVNZW1vcnlIaXN0b3J5LFxuICBwYXJzZVBhdGhcbn0gZnJvbSBcImhpc3RvcnlcIjtcblxuZXhwb3J0IHR5cGUgeyBMb2NhdGlvbiwgUGF0aCwgVG8sIE5hdmlnYXRpb25UeXBlIH07XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZyk6IGFzc2VydHMgY29uZCB7XG4gIGlmICghY29uZCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGFueSwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbmNvbnN0IGFscmVhZHlXYXJuZWQ6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG5mdW5jdGlvbiB3YXJuaW5nT25jZShrZXk6IHN0cmluZywgY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCAmJiAhYWxyZWFkeVdhcm5lZFtrZXldKSB7XG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDT05URVhUXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIDxSb3V0ZXI+IEFQSVxuICogd2hlcmUgYm90aCB0aGUgbG9jYXRpb24gYW5kIGEgbmF2aWdhdG9yIG11c3QgYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBpbiBvcmRlclxuICogdG8gYXZvaWQgXCJ0ZWFyaW5nXCIgdGhhdCBtYXkgb2NjdXIgaW4gYSBzdXNwZW5zZS1lbmFibGVkIGFwcCBpZiB0aGUgYWN0aW9uXG4gKiBhbmQvb3IgbG9jYXRpb24gd2VyZSB0byBiZSByZWFkIGRpcmVjdGx5IGZyb20gdGhlIGhpc3RvcnkgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRvciA9IFBpY2s8SGlzdG9yeSwgXCJnb1wiIHwgXCJwdXNoXCIgfCBcInJlcGxhY2VcIiB8IFwiY3JlYXRlSHJlZlwiPjtcblxuaW50ZXJmYWNlIE5hdmlnYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgYmFzZW5hbWU6IHN0cmluZztcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYzogYm9vbGVhbjtcbn1cblxuY29uc3QgTmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5hdmlnYXRpb25Db250ZXh0T2JqZWN0PihudWxsISk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIE5hdmlnYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJOYXZpZ2F0aW9uXCI7XG59XG5cbmludGVyZmFjZSBMb2NhdGlvbkNvbnRleHRPYmplY3Qge1xuICBsb2NhdGlvbjogTG9jYXRpb247XG4gIG5hdmlnYXRpb25UeXBlOiBOYXZpZ2F0aW9uVHlwZTtcbn1cblxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxMb2NhdGlvbkNvbnRleHRPYmplY3Q+KG51bGwhKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xufVxuXG5pbnRlcmZhY2UgUm91dGVDb250ZXh0T2JqZWN0IHtcbiAgb3V0bGV0OiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsO1xuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW107XG59XG5cbmNvbnN0IFJvdXRlQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8Um91dGVDb250ZXh0T2JqZWN0Pih7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW11cbn0pO1xuXG5pZiAoX19ERVZfXykge1xuICBSb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENPTVBPTkVOVFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWVtb3J5cm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXhcbn06IE1lbW9yeVJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8TWVtb3J5SGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7IGluaXRpYWxFbnRyaWVzLCBpbml0aWFsSW5kZXggfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0ZVByb3BzIHtcbiAgdG86IFRvO1xuICByZXBsYWNlPzogYm9vbGVhbjtcbiAgc3RhdGU/OiBhbnk7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBOb3RlOiBUaGlzIEFQSSBpcyBtb3N0bHkgdXNlZnVsIGluIFJlYWN0LkNvbXBvbmVudCBzdWJjbGFzc2VzIHRoYXQgYXJlIG5vdFxuICogYWJsZSB0byB1c2UgaG9va3MuIEluIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgd2UgcmVjb21tZW5kIHlvdSB1c2UgdGhlXG4gKiBgdXNlTmF2aWdhdGVgIGhvb2sgaW5zdGVhZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI25hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBOYXZpZ2F0ZSh7IHRvLCByZXBsYWNlLCBzdGF0ZSB9OiBOYXZpZ2F0ZVByb3BzKTogbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYDxOYXZpZ2F0ZT4gbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgd2FybmluZyhcbiAgICAhUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljLFxuICAgIGA8TmF2aWdhdGU+IG11c3Qgbm90IGJlIHVzZWQgb24gdGhlIGluaXRpYWwgcmVuZGVyIGluIGEgPFN0YXRpY1JvdXRlcj4uIGAgK1xuICAgICAgYFRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBgICtcbiAgICAgIGBvbmx5IGV2ZXIgcmVuZGVyZWQgaW4gcmVzcG9uc2UgdG8gc29tZSB1c2VyIGludGVyYWN0aW9uIG9yIHN0YXRlIGNoYW5nZS5gXG4gICk7XG5cbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0bGV0UHJvcHMge1xuICBjb250ZXh0PzogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI291dGxldFxuICovXG5leHBvcnQgZnVuY3Rpb24gT3V0bGV0KHByb3BzOiBPdXRsZXRQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlUHJvcHMge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBpbmRleD86IGJvb2xlYW47XG4gIHBhdGg/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFJvdXRlUHJvcHMge1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBpbmRleD86IGZhbHNlO1xuICBwYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5b3V0Um91dGVQcm9wcyB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmRleFJvdXRlUHJvcHMge1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgaW5kZXg6IHRydWU7XG59XG5cbi8qKlxuICogRGVjbGFyZXMgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBhdCBhIGNlcnRhaW4gVVJMIHBhdGguXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGUoXG4gIF9wcm9wczogUGF0aFJvdXRlUHJvcHMgfCBMYXlvdXRSb3V0ZVByb3BzIHwgSW5kZXhSb3V0ZVByb3BzXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIGZhbHNlLFxuICAgIGBBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIGAgK1xuICAgICAgYG5ldmVyIHJlbmRlcmVkIGRpcmVjdGx5LiBQbGVhc2Ugd3JhcCB5b3VyIDxSb3V0ZT4gaW4gYSA8Um91dGVzPi5gXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbiAgbmF2aWdhdGlvblR5cGU/OiBOYXZpZ2F0aW9uVHlwZTtcbiAgbmF2aWdhdG9yOiBOYXZpZ2F0b3I7XG4gIHN0YXRpYz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAqXG4gKiBOb3RlOiBZb3UgdXN1YWxseSB3b24ndCByZW5kZXIgYSA8Um91dGVyPiBkaXJlY3RseS4gSW5zdGVhZCwgeW91J2xsIHJlbmRlciBhXG4gKiByb3V0ZXIgdGhhdCBpcyBtb3JlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQgc3VjaCBhcyBhIDxCcm93c2VyUm91dGVyPlxuICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgPFN0YXRpY1JvdXRlcj4gZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcih7XG4gIGJhc2VuYW1lOiBiYXNlbmFtZVByb3AgPSBcIi9cIixcbiAgY2hpbGRyZW4gPSBudWxsLFxuICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICBuYXZpZ2F0aW9uVHlwZSA9IE5hdmlnYXRpb25UeXBlLlBvcCxcbiAgbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufTogUm91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5gICtcbiAgICAgIGAgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuXG4gIGxldCBiYXNlbmFtZSA9IG5vcm1hbGl6ZVBhdGhuYW1lKGJhc2VuYW1lUHJvcCk7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHsgYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljOiBzdGF0aWNQcm9wIH0pLFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXVxuICApO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cblxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCJcbiAgfSA9IGxvY2F0aW9uUHJvcDtcblxuICBsZXQgbG9jYXRpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleV0pO1xuXG4gIHdhcm5pbmcoXG4gICAgbG9jYXRpb24gIT0gbnVsbCxcbiAgICBgPFJvdXRlciBiYXNlbmFtZT1cIiR7YmFzZW5hbWV9XCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgYCArXG4gICAgICBgXCIke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1cIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIGAgK1xuICAgICAgYGJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLmBcbiAgKTtcblxuICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8TmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25hdmlnYXRpb25Db250ZXh0fT5cbiAgICAgIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgICB2YWx1ZT17eyBsb2NhdGlvbiwgbmF2aWdhdGlvblR5cGUgfX1cbiAgICAgIC8+XG4gICAgPC9OYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXNQcm9wcyB7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBsb2NhdGlvbj86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhIG5lc3RlZCB0cmVlIG9mIDxSb3V0ZT4gZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXMoe1xuICBjaGlsZHJlbixcbiAgbG9jYXRpb25cbn06IFJvdXRlc1Byb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VSb3V0ZXMoY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKSwgbG9jYXRpb24pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIT09LU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGJ1aWxkaW5nXG4gKiBjdXN0b20gbGlua3MgdGhhdCBhcmUgYWxzbyBhY2Nlc3NpYmxlIGFuZCBwcmVzZXJ2ZSByaWdodC1jbGljayBiZWhhdmlvci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZWhyZWZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUhyZWYodG86IFRvKTogc3RyaW5nIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlSHJlZigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IGJhc2VuYW1lLCBuYXZpZ2F0b3IgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBnZXRUb1BhdGhuYW1lKHRvKTtcbiAgICBsZXQgZW5kc1dpdGhTbGFzaCA9IHRvUGF0aG5hbWUgIT0gbnVsbCAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgICBqb2luZWRQYXRobmFtZSA9XG4gICAgICBwYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBiYXNlbmFtZSArIChlbmRzV2l0aFNsYXNoID8gXCIvXCIgOiBcIlwiKVxuICAgICAgICA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLmNyZWF0ZUhyZWYoeyBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlcj4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VpbnJvdXRlcmNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUluUm91dGVyQ29udGV4dCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KSAhPSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IFVSTCBpbiB3ZWJcbiAqIGJyb3dzZXJzLlxuICpcbiAqIE5vdGU6IElmIHlvdSdyZSB1c2luZyB0aGlzIGl0IG1heSBtZWFuIHlvdSdyZSBkb2luZyBzb21lIG9mIHlvdXIgb3duXG4gKiBcInJvdXRpbmdcIiBpbiB5b3VyIGFwcCwgYW5kIHdlJ2QgbGlrZSB0byBrbm93IHdoYXQgeW91ciB1c2UgY2FzZSBpcy4gV2UgbWF5XG4gKiBiZSBhYmxlIHRvIHByb3ZpZGUgc29tZXRoaW5nIGhpZ2hlci1sZXZlbCB0byBiZXR0ZXIgc3VpdCB5b3VyIG5lZWRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2F0aW9uKCk6IExvY2F0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuXG50eXBlIFBhcmFtUGFyc2VGYWlsZWQgPSB7IGZhaWxlZDogdHJ1ZSB9O1xuXG50eXBlIFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gQ2hlY2sgaGVyZSBpZiB0aGVyZSBleGlzdHMgYSBmb3J3YXJkIHNsYXNoIGluIHRoZSBzdHJpbmcuXG4gIFNlZ21lbnQgZXh0ZW5kcyBgJHtpbmZlciBMZWZ0U2VnbWVudH0vJHtpbmZlciBSaWdodFNlZ21lbnR9YFxuICAgID8gLy8gSWYgdGhlcmUgaXMgYSBmb3J3YXJkIHNsYXNoLCB0aGVuIGF0dGVtcHQgdG8gcGFyc2UgZWFjaCBzaWRlIG9mIHRoZVxuICAgICAgLy8gZm9yd2FyZCBzbGFzaC5cbiAgICAgIFBhcmFtUGFyc2VTZWdtZW50PExlZnRTZWdtZW50PiBleHRlbmRzIGluZmVyIExlZnRSZXN1bHRcbiAgICAgID8gUGFyYW1QYXJzZVNlZ21lbnQ8UmlnaHRTZWdtZW50PiBleHRlbmRzIGluZmVyIFJpZ2h0UmVzdWx0XG4gICAgICAgID8gTGVmdFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgID8gLy8gSWYgdGhlIGxlZnQgc2lkZSBpcyBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIGEgcGFyYW0sIHRoZW4gY2hlY2sgaWZcbiAgICAgICAgICAgIC8vIHRoZSByaWdodCBzaWRlIGNhbiBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIHdlbGwuIElmIGJvdGggc2lkZXNcbiAgICAgICAgICAgIC8vIGNhbiBiZSBwYXJzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBhIHVuaW9uIG9mIHRoZSB0d28gc2lkZXNcbiAgICAgICAgICAgIC8vIChyZWFkOiBcImZvb1wiIHwgXCJiYXJcIikuXG4gICAgICAgICAgICBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgICAgPyBMZWZ0UmVzdWx0IHwgUmlnaHRSZXN1bHRcbiAgICAgICAgICAgIDogTGVmdFJlc3VsdFxuICAgICAgICAgIDogLy8gSWYgdGhlIGxlZnQgc2lkZSBpcyBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBhcyBhIHBhcmFtLCB0aGVuIGNoZWNrXG4gICAgICAgICAgLy8gaWYgb25seSB0aGUgcmlnaHQgc2lkZSBjYW4gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFzIGEgcGFyYW0uIElmIGl0XG4gICAgICAgICAgLy8gY2FuLCB0aGVuIHRoZSByZXN1bHQgaXMganVzdCByaWdodCwgZWxzZSBpdCdzIGEgZmFpbHVyZS5cbiAgICAgICAgICBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgID8gUmlnaHRSZXN1bHRcbiAgICAgICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgICA6IC8vIElmIHRoZSBsZWZ0IHNpZGUgZGlkbid0IHBhcnNlIGludG8gYSBwYXJhbSwgdGhlbiBqdXN0IGNoZWNrIHRoZSByaWdodFxuICAgICAgLy8gc2lkZS5cbiAgICAgIFBhcmFtUGFyc2VTZWdtZW50PFJpZ2h0U2VnbWVudD4gZXh0ZW5kcyBpbmZlciBSaWdodFJlc3VsdFxuICAgICAgPyBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICA/IFJpZ2h0UmVzdWx0XG4gICAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgOiAvLyBJZiB0aGVyZSdzIG5vIGZvcndhcmQgc2xhc2gsIHRoZW4gY2hlY2sgaWYgdGhpcyBzZWdtZW50IHN0YXJ0cyB3aXRoIGFcbiAgICAvLyBjb2xvbi4gSWYgaXQgZG9lcywgdGhlbiB0aGlzIGlzIGEgZHluYW1pYyBzZWdtZW50LCBzbyB0aGUgcmVzdWx0IGlzXG4gICAgLy8ganVzdCB0aGUgcmVtYWluZGVyIG9mIHRoZSBzdHJpbmcuIE90aGVyd2lzZSwgaXQncyBhIGZhaWx1cmUuXG4gICAgU2VnbWVudCBleHRlbmRzIGA6JHtpbmZlciBSZW1haW5pbmd9YFxuICAgID8gUmVtYWluaW5nXG4gICAgOiBQYXJhbVBhcnNlRmFpbGVkO1xuXG4vLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgc2VnbWVudC4gSWYgaXQgZmFpbHMsIHRoZW4ganVzdCByZXR1cm4gdGhlXG4vLyBwbGFpbiBzdHJpbmcgdHlwZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2suIE90aGVyd2lzZSByZXR1cm4gdGhlIHVuaW9uIG9mIHRoZVxuLy8gcGFyc2VkIHN0cmluZyBsaXRlcmFscyB0aGF0IHdlcmUgcmVmZXJlbmNlZCBhcyBkeW5hbWljIHNlZ21lbnRzIGluIHRoZSByb3V0ZS5cbnR5cGUgUGFyYW1QYXJzZUtleTxTZWdtZW50IGV4dGVuZHMgc3RyaW5nPiA9XG4gIFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQ+IGV4dGVuZHMgc3RyaW5nXG4gICAgPyBQYXJhbVBhcnNlU2VnbWVudDxTZWdtZW50PlxuICAgIDogc3RyaW5nO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VuYXZpZ2F0aW9udHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKTogTmF2aWdhdGlvblR5cGUge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVVJMIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxuICogPE5hdkxpbms+LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlbWF0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hdGNoPFxuICBQYXJhbUtleSBleHRlbmRzIFBhcmFtUGFyc2VLZXk8UGF0aD4sXG4gIFBhdGggZXh0ZW5kcyBzdHJpbmdcbj4ocGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoKTogUGF0aE1hdGNoPFBhcmFtS2V5PiB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VNYXRjaCgpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIGxldCB7IHBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiBtYXRjaFBhdGg8UGFyYW1LZXksIFBhdGg+KHBhdHRlcm4sIHBhdGhuYW1lKSxcbiAgICBbcGF0aG5hbWUsIHBhdHRlcm5dXG4gICk7XG59XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSBmb3IgdGhlIG5hdmlnYXRlKCkgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbSB1c2VOYXZpZ2F0ZSgpLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlRnVuY3Rpb24ge1xuICAodG86IFRvLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZDtcbiAgKGRlbHRhOiBudW1iZXIpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlT3B0aW9ucyB7XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGltcGVyYXRpdmUgbWV0aG9kIGZvciBjaGFuZ2luZyB0aGUgbG9jYXRpb24uIFVzZWQgYnkgPExpbms+cywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VuYXZpZ2F0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTmF2aWdhdGUoKTogTmF2aWdhdGVGdW5jdGlvbiB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFxuICAgIG1hdGNoZXMubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhY3RpdmVSZWYuY3VycmVudCA9IHRydWU7XG4gIH0pO1xuXG4gIGxldCBuYXZpZ2F0ZTogTmF2aWdhdGVGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh0bzogVG8gfCBudW1iZXIsIG9wdGlvbnM6IE5hdmlnYXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBhY3RpdmVSZWYuY3VycmVudCxcbiAgICAgICAgYFlvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIGAgK1xuICAgICAgICAgIGB5b3VyIGNvbXBvbmVudCBpcyBmaXJzdCByZW5kZXJlZC5gXG4gICAgICApO1xuXG4gICAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICAgICAgdG8sXG4gICAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZVxuICAgICAgKTtcblxuICAgICAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoLnBhdGhuYW1lID0gam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICAgICAgfVxuXG4gICAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb3B0aW9ucy5zdGF0ZVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdXG4gICk7XG5cbiAgcmV0dXJuIG5hdmlnYXRlO1xufVxuXG5jb25zdCBPdXRsZXRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDx1bmtub3duPihudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VvdXRsZXRjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXRDb250ZXh0PENvbnRleHQgPSB1bmtub3duPigpOiBDb250ZXh0IHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCkgYXMgQ29udGV4dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS4gVXNlZCBpbnRlcm5hbGx5IGJ5IDxPdXRsZXQ+IHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VvdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0PzogdW5rbm93bik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgaWYgKG91dGxldCkge1xuICAgIHJldHVybiAoXG4gICAgICA8T3V0bGV0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+e291dGxldH08L091dGxldENvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXJhbXM8XG4gIFBhcmFtc09yS2V5IGV4dGVuZHMgc3RyaW5nIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHN0cmluZ1xuPigpOiBSZWFkb25seTxcbiAgW1BhcmFtc09yS2V5XSBleHRlbmRzIFtzdHJpbmddID8gUGFyYW1zPFBhcmFtc09yS2V5PiA6IFBhcnRpYWw8UGFyYW1zT3JLZXk+XG4+IHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyAocm91dGVNYXRjaC5wYXJhbXMgYXMgYW55KSA6IHt9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlcmVzb2x2ZWRwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXNvbHZlZFBhdGgodG86IFRvKTogUGF0aCB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG5cbiAgbGV0IHJvdXRlUGF0aG5hbWVzSnNvbiA9IEpTT04uc3RyaW5naWZ5KFxuICAgIG1hdGNoZXMubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSksXG4gICAgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZz86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgbWF0Y2hlczogcGFyZW50TWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIFlvdSB3b24ndCBnZXQgYSB3YXJuaW5nIGFib3V0IDIgZGlmZmVyZW50IDxSb3V0ZXM+IHVuZGVyIGEgPFJvdXRlPlxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPFJvdXRlcz5cbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2dcIiBlbGVtZW50PXs8QmxvZyAvPn0gLz5cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgIC8vIDwvUm91dGVzPlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAvLyAgIHJldHVybiAoXG4gICAgLy8gICAgIDxSb3V0ZXM+XG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIGxldCBwYXJlbnRQYXRoID0gKHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGgpIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UoXG4gICAgICBwYXJlbnRQYXRobmFtZSxcbiAgICAgICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBgICtcbiAgICAgICAgYFwiJHtwYXJlbnRQYXRobmFtZX1cIiAodW5kZXIgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+KSBidXQgdGhlIGAgK1xuICAgICAgICBgcGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFwiKlwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBgICtcbiAgICAgICAgYGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIGAgK1xuICAgICAgICBgcm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxcblxcbmAgK1xuICAgICAgICBgUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgYCArXG4gICAgICAgIGBwYXRoPVwiJHtwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogYCR7cGFyZW50UGF0aH0vKmB9XCI+LmBcbiAgICApO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID1cbiAgICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHxcbiAgICAgICAgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgYCArXG4gICAgICAgIGB0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgYCArXG4gICAgICAgIGBtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFwiJHtwYXJlbnRQYXRobmFtZUJhc2V9XCIgYCArXG4gICAgICAgIGBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcblxuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG5cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgPyBwYXRobmFtZVxuICAgICAgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHsgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lIH0pO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCxcbiAgICAgIGBObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGBcbiAgICApO1xuXG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fFxuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGRvZXMgbm90IGhhdmUgYW4gZWxlbWVudC4gYCArXG4gICAgICAgIGBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXCJlbXB0eVwiIHBhZ2UuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJlxuICAgICAgbWF0Y2hlcy5tYXAobWF0Y2ggPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICAgICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICAgICAgICBwYXRobmFtZTogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsIG1hdGNoLnBhdGhuYW1lXSksXG4gICAgICAgICAgcGF0aG5hbWVCYXNlOlxuICAgICAgICAgICAgbWF0Y2gucGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgICAgICAgICA/IHBhcmVudFBhdGhuYW1lQmFzZVxuICAgICAgICAgICAgICA6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzXG4gICk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI2NyZWF0ZXJvdXRlc2Zyb21jaGlsZHJlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4pOiBSb3V0ZU9iamVjdFtdIHtcbiAgbGV0IHJvdXRlczogUm91dGVPYmplY3RbXSA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGVsZW1lbnQgPT4ge1xuICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgIC8vIFRyYW5zcGFyZW50bHkgc3VwcG9ydCBSZWFjdC5GcmFnbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgcm91dGVzLnB1c2guYXBwbHkoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudChcbiAgICAgIGVsZW1lbnQudHlwZSA9PT0gUm91dGUsXG4gICAgICBgWyR7XG4gICAgICAgIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZVxuICAgICAgfV0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PmBcbiAgICApO1xuXG4gICAgbGV0IHJvdXRlOiBSb3V0ZU9iamVjdCA9IHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoXG4gICAgfTtcblxuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogVGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhcnNlZCBmcm9tIHRoZSBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgUGFyYW1zPEtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtrZXkgaW4gS2V5XTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBIHJvdXRlIG9iamVjdCByZXByZXNlbnRzIGEgbG9naWNhbCByb3V0ZSwgd2l0aCAob3B0aW9uYWxseSkgaXRzIGNoaWxkXG4gKiByb3V0ZXMgb3JnYW5pemVkIGluIGEgdHJlZS1saWtlIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJvdXRlT2JqZWN0W107XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGluZGV4PzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNnZW5lcmF0ZXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aChwYXRoOiBzdHJpbmcsIHBhcmFtczogUGFyYW1zID0ge30pOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aFxuICAgIC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBrZXkpID0+IHtcbiAgICAgIGludmFyaWFudChwYXJhbXNba2V5XSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgcmV0dXJuIHBhcmFtc1trZXldITtcbiAgICB9KVxuICAgIC5yZXBsYWNlKC9cXC8qXFwqJC8sIF8gPT5cbiAgICAgIHBhcmFtc1tcIipcIl0gPT0gbnVsbCA/IFwiXCIgOiBwYXJhbXNbXCIqXCJdLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpXG4gICAgKTtcbn1cblxuLyoqXG4gKiBBIFJvdXRlTWF0Y2ggY29udGFpbnMgaW5mbyBhYm91dCBob3cgYSByb3V0ZSBtYXRjaGVkIGEgVVJMLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcm91dGUgb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG8gbWF0Y2guXG4gICAqL1xuICByb3V0ZTogUm91dGVPYmplY3Q7XG59XG5cbi8qKlxuICogTWF0Y2hlcyB0aGUgZ2l2ZW4gcm91dGVzIHRvIGEgbG9jYXRpb24gYW5kIHJldHVybnMgdGhlIG1hdGNoIGRhdGEuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHJvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hSb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgbG9jYXRpb25Bcmc6IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nLFxuICBiYXNlbmFtZSA9IFwiL1wiXG4pOiBSb3V0ZU1hdGNoW10gfCBudWxsIHtcbiAgbGV0IGxvY2F0aW9uID1cbiAgICB0eXBlb2YgbG9jYXRpb25BcmcgPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb25BcmcpIDogbG9jYXRpb25Bcmc7XG5cbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuXG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgYnJhbmNoZXMgPSBmbGF0dGVuUm91dGVzKHJvdXRlcyk7XG4gIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzKTtcblxuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbWF0Y2hlcyA9IG1hdGNoUm91dGVCcmFuY2goYnJhbmNoZXNbaV0sIHBhdGhuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5pbnRlcmZhY2UgUm91dGVNZXRhIHtcbiAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIGNhc2VTZW5zaXRpdmU6IGJvb2xlYW47XG4gIGNoaWxkcmVuSW5kZXg6IG51bWJlcjtcbiAgcm91dGU6IFJvdXRlT2JqZWN0O1xufVxuXG5pbnRlcmZhY2UgUm91dGVCcmFuY2gge1xuICBwYXRoOiBzdHJpbmc7XG4gIHNjb3JlOiBudW1iZXI7XG4gIHJvdXRlc01ldGE6IFJvdXRlTWV0YVtdO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuUm91dGVzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdID0gW10sXG4gIHBhcmVudHNNZXRhOiBSb3V0ZU1ldGFbXSA9IFtdLFxuICBwYXJlbnRQYXRoID0gXCJcIlxuKTogUm91dGVCcmFuY2hbXSB7XG4gIHJvdXRlcy5mb3JFYWNoKChyb3V0ZSwgaW5kZXgpID0+IHtcbiAgICBsZXQgbWV0YTogUm91dGVNZXRhID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOiByb3V0ZS5wYXRoIHx8IFwiXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxuICAgICAgY2hpbGRyZW5JbmRleDogaW5kZXgsXG4gICAgICByb3V0ZVxuICAgIH07XG5cbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSxcbiAgICAgICAgYEFic29sdXRlIHJvdXRlIHBhdGggXCIke21ldGEucmVsYXRpdmVQYXRofVwiIG5lc3RlZCB1bmRlciBwYXRoIGAgK1xuICAgICAgICAgIGBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggYCArXG4gICAgICAgICAgYG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcblxuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG5cbiAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIGJlZm9yZSBhZGRpbmcgdGhpcyByb3V0ZSB0byB0aGUgYXJyYXkgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYCArXG4gICAgICAgICAgYGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG5cbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJhbmNoZXMucHVzaCh7IHBhdGgsIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLCByb3V0ZXNNZXRhIH0pO1xuICB9KTtcblxuICByZXR1cm4gYnJhbmNoZXM7XG59XG5cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdKTogdm9pZCB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+XG4gICAgYS5zY29yZSAhPT0gYi5zY29yZVxuICAgICAgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICAgIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICAgICAgYS5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCksXG4gICAgICAgICAgYi5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleClcbiAgICAgICAgKVxuICApO1xufVxuXG5jb25zdCBwYXJhbVJlID0gL146XFx3KyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSAoczogc3RyaW5nKSA9PiBzID09PSBcIipcIjtcblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGg6IHN0cmluZywgaW5kZXg6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG5cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xuICAgIC5maWx0ZXIocyA9PiAhaXNTcGxhdChzKSlcbiAgICAucmVkdWNlKFxuICAgICAgKHNjb3JlLCBzZWdtZW50KSA9PlxuICAgICAgICBzY29yZSArXG4gICAgICAgIChwYXJhbVJlLnRlc3Qoc2VnbWVudClcbiAgICAgICAgICA/IGR5bmFtaWNTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHNlZ21lbnQgPT09IFwiXCJcbiAgICAgICAgICA/IGVtcHR5U2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgICAgaW5pdGlhbFNjb3JlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNpYmxpbmdzID1cbiAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuXG4gIHJldHVybiBzaWJsaW5nc1xuICAgID8gLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICAgIDogLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgYnJhbmNoOiBSb3V0ZUJyYW5jaCxcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogUm91dGVNYXRjaDxQYXJhbUtleT5bXSB8IG51bGwge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG5cbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlczogUm91dGVNYXRjaFtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gcGF0aG5hbWVcbiAgICAgICAgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG5cbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuXG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pLFxuICAgICAgcm91dGVcbiAgICB9KTtcblxuICAgIGlmIChtYXRjaC5wYXRobmFtZUJhc2UgIT09IFwiL1wiKSB7XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPSBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVCYXNlXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGxcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsLFxuICBwYXJlbnRNYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXVxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBtYXRjaGVzLnJlZHVjZVJpZ2h0KChvdXRsZXQsIG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8Um91dGVDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgIGNoaWxkcmVuPXtcbiAgICAgICAgICBtYXRjaC5yb3V0ZS5lbGVtZW50ICE9PSB1bmRlZmluZWQgPyBtYXRjaC5yb3V0ZS5lbGVtZW50IDogPE91dGxldCAvPlxuICAgICAgICB9XG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgIG1hdGNoZXM6IHBhcmVudE1hdGNoZXMuY29uY2F0KG1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSlcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgKTtcbiAgfSwgbnVsbCBhcyBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsKTtcbn1cblxuLyoqXG4gKiBBIFBhdGhQYXR0ZXJuIGlzIHVzZWQgdG8gbWF0Y2ggb24gc29tZSBwb3J0aW9uIG9mIGEgVVJMIHBhdGhuYW1lLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhQYXR0ZXJuPFBhdGggZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3QgYSBVUkwgcGF0aG5hbWUuIE1heSBjb250YWluIGA6aWRgLXN0eWxlIHNlZ21lbnRzXG4gICAqIHRvIGluZGljYXRlIHBsYWNlaG9sZGVycyBmb3IgZHluYW1pYyBwYXJhbWV0ZXJzLiBNYXkgYWxzbyBlbmQgd2l0aCBgLypgIHRvXG4gICAqIGluZGljYXRlIG1hdGNoaW5nIHRoZSByZXN0IG9mIHRoZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBwYXRoOiBQYXRoO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGUgc3RhdGljIHBvcnRpb25zIG9mIHRoZSBgcGF0aGAgc2hvdWxkIGJlIG1hdGNoZWQgaW5cbiAgICogdGhlIHNhbWUgY2FzZS5cbiAgICovXG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICAvKipcbiAgICogU2hvdWxkIGJlIGB0cnVlYCBpZiB0aGlzIHBhdHRlcm4gc2hvdWxkIG1hdGNoIHRoZSBlbnRpcmUgVVJMIHBhdGhuYW1lLlxuICAgKi9cbiAgZW5kPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBIFBhdGhNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIFBhdGhQYXR0ZXJuIG1hdGNoZWQgb24gYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aE1hdGNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBhdHRlcm4gdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHBhdHRlcm46IFBhdGhQYXR0ZXJuO1xufVxuXG50eXBlIE11dGFibGU8VD4gPSB7XG4gIC1yZWFkb25seSBbUCBpbiBrZXlvZiBUXTogVFtQXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgcGF0dGVybiBtYXRjaGluZyBvbiBhIFVSTCBwYXRobmFtZSBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dFxuICogdGhlIG1hdGNoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWF0Y2hwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFBhdGg8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihcbiAgcGF0dGVybjogUGF0aFBhdHRlcm48UGF0aD4gfCBQYXRoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuXG4gIGxldCBbbWF0Y2hlciwgcGFyYW1OYW1lc10gPSBjb21waWxlUGF0aChcbiAgICBwYXR0ZXJuLnBhdGgsXG4gICAgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLFxuICAgIHBhdHRlcm4uZW5kXG4gICk7XG5cbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBtYXRjaFswXTtcbiAgbGV0IHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gIGxldCBjYXB0dXJlR3JvdXBzID0gbWF0Y2guc2xpY2UoMSk7XG4gIGxldCBwYXJhbXM6IFBhcmFtcyA9IHBhcmFtTmFtZXMucmVkdWNlPE11dGFibGU8UGFyYW1zPj4oXG4gICAgKG1lbW8sIHBhcmFtTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBwYXJhbXNbXCIqXCJdIGxhdGVyIGJlY2F1c2UgaXQgd2lsbCBiZSBkZWNvZGVkIHRoZW5cbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lXG4gICAgICAgICAgLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aClcbiAgICAgICAgICAucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuXG4gICAgICBtZW1vW3BhcmFtTmFtZV0gPSBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIGNhcHR1cmVHcm91cHNbaW5kZXhdIHx8IFwiXCIsXG4gICAgICAgIHBhcmFtTmFtZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG4gICAge31cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2hlZFBhdGhuYW1lLFxuICAgIHBhdGhuYW1lQmFzZSxcbiAgICBwYXR0ZXJuXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgZW5kID0gdHJ1ZVxuKTogW1JlZ0V4cCwgc3RyaW5nW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9XG4gICAgXCJeXCIgK1xuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAgICAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgICAgIC5yZXBsYWNlKC9bXFxcXC4qK14kP3t9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC86KFxcdyspL2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gXCIoW15cXFxcL10rKVwiO1xuICAgICAgfSk7XG5cbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgcGFyYW1OYW1lcy5wdXNoKFwiKlwiKTtcbiAgICByZWdleHBTb3VyY2UgKz1cbiAgICAgIHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIlxuICAgICAgICA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgICAgICA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7IC8vIERvbid0IGluY2x1ZGUgdGhlIC8gaW4gcGFyYW1zW1wiKlwiXVxuICB9IGVsc2Uge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBlbmRcbiAgICAgID8gXCJcXFxcLyokXCIgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgOiAvLyBPdGhlcndpc2UsIG1hdGNoIGEgd29yZCBib3VuZGFyeSBvciBhIHByb2NlZWRpbmcgLy4gVGhlIHdvcmQgYm91bmRhcnkgcmVzdHJpY3RzXG4gICAgICAgIC8vIHBhcmVudCByb3V0ZXMgdG8gbWF0Y2hpbmcgb25seSB0aGVpciBvd24gd29yZHMgYW5kIG5vdGhpbmcgbW9yZSwgZS5nLiBwYXJlbnRcbiAgICAgICAgLy8gcm91dGUgXCIvaG9tZVwiIHNob3VsZCBub3QgbWF0Y2ggXCIvaG9tZTJcIi5cbiAgICAgICAgXCIoPzpcXFxcYnxcXFxcL3wkKVwiO1xuICB9XG5cbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcblxuICByZXR1cm4gW21hdGNoZXIsIHBhcmFtTmFtZXNdO1xufVxuXG5mdW5jdGlvbiBzYWZlbHlEZWNvZGVVUklDb21wb25lbnQodmFsdWU6IHN0cmluZywgcGFyYW1OYW1lOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICBgVGhlIHZhbHVlIGZvciB0aGUgVVJMIHBhcmFtIFwiJHtwYXJhbU5hbWV9XCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlYCArXG4gICAgICAgIGAgdGhlIHN0cmluZyBcIiR7dmFsdWV9XCIgaXMgYSBtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHlgICtcbiAgICAgICAgYCBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3Jlc29sdmVwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGF0aCh0bzogVG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKTogUGF0aCB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuXG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWVcbiAgICA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgID8gdG9QYXRobmFtZVxuICAgICAgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKVxuICAgIDogZnJvbVBhdGhuYW1lO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGg6IHN0cmluZywgZnJvbVBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcblxuICByZWxhdGl2ZVNlZ21lbnRzLmZvckVhY2goc2VnbWVudCA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgLy8gS2VlcCB0aGUgcm9vdCBcIlwiIHNlZ21lbnQgc28gdGhlIHBhdGhuYW1lIHN0YXJ0cyBhdCAvXG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRvKFxuICB0b0FyZzogVG8sXG4gIHJvdXRlUGF0aG5hbWVzOiBzdHJpbmdbXSxcbiAgbG9jYXRpb25QYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoIHtcbiAgbGV0IHRvID0gdHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvQXJnKSA6IHRvQXJnO1xuICBsZXQgdG9QYXRobmFtZSA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0by5wYXRobmFtZTtcblxuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGxldCBmcm9tOiBzdHJpbmc7XG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgLy8gRWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnMgXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lXG4gICAgICAvLyBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleSBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhXG4gICAgICAvLyBtYWpvciByZWFzb24gd2UgY2FsbCB0aGlzIGEgXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCB0byB2YWx1ZSBoYWQgb25lLlxuICBpZiAoXG4gICAgdG9QYXRobmFtZSAmJlxuICAgIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmXG4gICAgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIilcbiAgKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvOiBUbyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgLyBwYXRoc1xuICByZXR1cm4gdG8gPT09IFwiXCIgfHwgKHRvIGFzIFBhdGgpLnBhdGhuYW1lID09PSBcIlwiXG4gICAgPyBcIi9cIlxuICAgIDogdHlwZW9mIHRvID09PSBcInN0cmluZ1wiXG4gICAgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lXG4gICAgOiB0by5wYXRobmFtZTtcbn1cblxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRobmFtZTogc3RyaW5nLCBiYXNlbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KGJhc2VuYW1lLmxlbmd0aCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2VuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG59XG5cbmNvbnN0IGpvaW5QYXRocyA9IChwYXRoczogc3RyaW5nW10pOiBzdHJpbmcgPT5cbiAgcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG5cbmNvbnN0IG5vcm1hbGl6ZVBhdGhuYW1lID0gKHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcblxuY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIlxuICAgID8gXCJcIlxuICAgIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpXG4gICAgPyBzZWFyY2hcbiAgICA6IFwiP1wiICsgc2VhcmNoO1xuXG5jb25zdCBub3JtYWxpemVIYXNoID0gKGhhc2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0XG59O1xuIiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUgeyBCcm93c2VySGlzdG9yeSwgSGFzaEhpc3RvcnksIEhpc3RvcnkgfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVQYXRoIH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7XG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGdlbmVyYXRlUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIG1hdGNoUGF0aCxcbiAgcmVzb2x2ZVBhdGgsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJvdXRlcyxcbiAgdXNlT3V0bGV0Q29udGV4dFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5pbXBvcnQgdHlwZSB7IFRvIH0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQ6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IFJvdXRlciFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUkUtRVhQT1JUU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gTm90ZTogS2VlcCBpbiBzeW5jIHdpdGggcmVhY3Qtcm91dGVyIGV4cG9ydHMhXG5leHBvcnQge1xuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlcyxcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBnZW5lcmF0ZVBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBtYXRjaFBhdGgsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlc29sdmVQYXRoLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZU91dGxldENvbnRleHRcbn07XG5cbmV4cG9ydCB0eXBlIHtcbiAgTG9jYXRpb24sXG4gIFBhdGgsXG4gIFRvLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdG9yLFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXRoTWF0Y2gsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBQYXRoUm91dGVQcm9wcyxcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUm91dGVzUHJvcHNcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUm91dGVDb250ZXh0XG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENPTVBPTkVOVFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJvd3NlclJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICB3aW5kb3c/OiBXaW5kb3c7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBQcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIHdpbmRvd1xufTogQnJvd3NlclJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEJyb3dzZXJIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7IHdpbmRvdyB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBIYXNoUm91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCB3aW5kb3cgfTogSGFzaFJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEhhc2hIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdyB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaGlzdG9yeTogSGlzdG9yeTtcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgdGhhdCBhY2NlcHRzIGEgcHJlLWluc3RhbnRpYXRlZCBoaXN0b3J5IG9iamVjdC4gSXQncyBpbXBvcnRhbnRcbiAqIHRvIG5vdGUgdGhhdCB1c2luZyB5b3VyIG93biBoaXN0b3J5IG9iamVjdCBpcyBoaWdobHkgZGlzY291cmFnZWQgYW5kIG1heSBhZGRcbiAqIHR3byB2ZXJzaW9ucyBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRvIHlvdXIgYnVuZGxlcyB1bmxlc3MgeW91IHVzZSB0aGUgc2FtZVxuICogdmVyc2lvbiBvZiB0aGUgaGlzdG9yeSBsaWJyYXJ5IHRoYXQgUmVhY3QgUm91dGVyIHVzZXMgaW50ZXJuYWxseS5cbiAqL1xuZnVuY3Rpb24gSGlzdG9yeVJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgaGlzdG9yeSB9OiBIaXN0b3J5Um91dGVyUHJvcHMpIHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5pZiAoX19ERVZfXykge1xuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnlSb3V0ZXIgYXMgdW5zdGFibGVfSGlzdG9yeVJvdXRlciB9O1xuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8UmVhY3QuQW5jaG9ySFRNTEF0dHJpYnV0ZXM8SFRNTEFuY2hvckVsZW1lbnQ+LCBcImhyZWZcIj4ge1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgdG86IFRvO1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuZXhwb3J0IGNvbnN0IExpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBMaW5rV2l0aFJlZihcbiAgICB7IG9uQ2xpY2ssIHJlbG9hZERvY3VtZW50LCByZXBsYWNlID0gZmFsc2UsIHN0YXRlLCB0YXJnZXQsIHRvLCAuLi5yZXN0IH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBocmVmID0gdXNlSHJlZih0byk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHsgcmVwbGFjZSwgc3RhdGUsIHRhcmdldCB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhcbiAgICAgIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxBbmNob3JFbGVtZW50LCBNb3VzZUV2ZW50PlxuICAgICkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmICFyZWxvYWREb2N1bWVudCkge1xuICAgICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICA8YVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB0YXJnZXQ9e3RhcmdldH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdkxpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8TGlua1Byb3BzLCBcImNsYXNzTmFtZVwiIHwgXCJzdHlsZVwiIHwgXCJjaGlsZHJlblwiPiB7XG4gIGNoaWxkcmVuOlxuICAgIHwgUmVhY3QuUmVhY3ROb2RlXG4gICAgfCAoKHByb3BzOiB7IGlzQWN0aXZlOiBib29sZWFuIH0pID0+IFJlYWN0LlJlYWN0Tm9kZSk7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjbGFzc05hbWU/OiBzdHJpbmcgfCAoKHByb3BzOiB7IGlzQWN0aXZlOiBib29sZWFuIH0pID0+IHN0cmluZyk7XG4gIGVuZD86IGJvb2xlYW47XG4gIHN0eWxlPzpcbiAgICB8IFJlYWN0LkNTU1Byb3BlcnRpZXNcbiAgICB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gUmVhY3QuQ1NTUHJvcGVydGllcyk7XG59XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbmV4cG9ydCBjb25zdCBOYXZMaW5rID0gUmVhY3QuZm9yd2FyZFJlZjxIVE1MQW5jaG9yRWxlbWVudCwgTmF2TGlua1Byb3BzPihcbiAgZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoXG4gICAge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgICAgZW5kID0gZmFsc2UsXG4gICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgdG8sXG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIHJlZlxuICApIHtcbiAgICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICAgIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvKTtcblxuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lO1xuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRvUGF0aG5hbWUgPSB0b1BhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzQWN0aXZlID1cbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPT09IHRvUGF0aG5hbWUgfHxcbiAgICAgICghZW5kICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJlxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdCh0b1BhdGhuYW1lLmxlbmd0aCkgPT09IFwiL1wiKTtcblxuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuXG4gICAgbGV0IGNsYXNzTmFtZTogc3RyaW5nO1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lUHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWVQcm9wKHsgaXNBY3RpdmUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjbGFzc05hbWUgcHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgd2UgdXNlIGEgZGVmYXVsdCBgYWN0aXZlYFxuICAgICAgLy8gY2xhc3MgZm9yIDxOYXZMaW5rIC8+cyB0aGF0IGFyZSBhY3RpdmUuIEluIHY1IGBhY3RpdmVgIHdhcyB0aGUgZGVmYXVsdFxuICAgICAgLy8gdmFsdWUgZm9yIGBhY3RpdmVDbGFzc05hbWVgLCBidXQgd2UgYXJlIHJlbW92aW5nIHRoYXQgQVBJIGFuZCBjYW4gc3RpbGxcbiAgICAgIC8vIHVzZSB0aGUgb2xkIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgY2xlYW5lciB1cGdyYWRlIHBhdGggYW5kIGtlZXAgdGhlXG4gICAgICAvLyBzaW1wbGUgc3R5bGluZyBydWxlcyB3b3JraW5nIGFzIHRoZXkgY3VycmVudGx5IGRvLlxuICAgICAgY2xhc3NOYW1lID0gW2NsYXNzTmFtZVByb3AsIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGxdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIGxldCBzdHlsZSA9XG4gICAgICB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AoeyBpc0FjdGl2ZSB9KSA6IHN0eWxlUHJvcDtcblxuICAgIHJldHVybiAoXG4gICAgICA8TGlua1xuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgYXJpYS1jdXJyZW50PXthcmlhQ3VycmVudH1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIHRvPXt0b31cbiAgICAgID5cbiAgICAgICAge3R5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oeyBpc0FjdGl2ZSB9KSA6IGNoaWxkcmVufVxuICAgICAgPC9MaW5rPlxuICAgICk7XG4gIH1cbik7XG5cbmlmIChfX0RFVl9fKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhPT0tTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcjxFIGV4dGVuZHMgRWxlbWVudCA9IEhUTUxBbmNob3JFbGVtZW50PihcbiAgdG86IFRvLFxuICB7XG4gICAgdGFyZ2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICAgIHN0YXRlXG4gIH06IHtcbiAgICB0YXJnZXQ/OiBSZWFjdC5IVE1MQXR0cmlidXRlQW5jaG9yVGFyZ2V0O1xuICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIHN0YXRlPzogYW55O1xuICB9ID0ge31cbik6IChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4gdm9pZCB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgICAgICAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYSBwdXNoLCBzbyBkbyB0aGUgc2FtZSBoZXJlLlxuICAgICAgICBsZXQgcmVwbGFjZSA9XG4gICAgICAgICAgISFyZXBsYWNlUHJvcCB8fCBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcblxuICAgICAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtsb2NhdGlvbiwgbmF2aWdhdGUsIHBhdGgsIHJlcGxhY2VQcm9wLCBzdGF0ZSwgdGFyZ2V0LCB0b11cbiAgKTtcbn1cblxuLyoqXG4gKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gKiBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0PzogVVJMU2VhcmNoUGFyYW1zSW5pdCkge1xuICB3YXJuaW5nKFxuICAgIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgYFlvdSBjYW5ub3QgdXNlIHRoZSBcXGB1c2VTZWFyY2hQYXJhbXNcXGAgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBgICtcbiAgICAgIGBzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IGAgK1xuICAgICAgYEV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIGAgK1xuICAgICAgYGh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtc1xcblxcbmAgK1xuICAgICAgYElmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBgICtcbiAgICAgIGBodHRwczovL3BvbHlmaWxsLmlvL3YzLyB3aGljaCBwcm92aWRlcyBzb21lIHJlY29tbWVuZGF0aW9ucyBhYm91dCBob3cgYCArXG4gICAgICBgdG8gbG9hZCBwb2x5ZmlsbHMgb25seSBmb3IgdXNlcnMgdGhhdCBuZWVkIHRoZW0sIGluc3RlYWQgb2YgZm9yIGV2ZXJ5IGAgK1xuICAgICAgYHVzZXIuYFxuICApO1xuXG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICBmb3IgKGxldCBrZXkgb2YgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50LmtleXMoKSkge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50LmdldEFsbChrZXkpLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWFyY2hQYXJhbXM7XG4gIH0sIFtsb2NhdGlvbi5zZWFyY2hdKTtcblxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgbmV4dEluaXQ6IFVSTFNlYXJjaFBhcmFtc0luaXQsXG4gICAgICBuYXZpZ2F0ZU9wdGlvbnM/OiB7IHJlcGxhY2U/OiBib29sZWFuOyBzdGF0ZT86IGFueSB9XG4gICAgKSA9PiB7XG4gICAgICBuYXZpZ2F0ZShcIj9cIiArIGNyZWF0ZVNlYXJjaFBhcmFtcyhuZXh0SW5pdCksIG5hdmlnYXRlT3B0aW9ucyk7XG4gICAgfSxcbiAgICBbbmF2aWdhdGVdXG4gICk7XG5cbiAgcmV0dXJuIFtzZWFyY2hQYXJhbXMsIHNldFNlYXJjaFBhcmFtc10gYXMgY29uc3Q7XG59XG5cbmV4cG9ydCB0eXBlIFBhcmFtS2V5VmFsdWVQYWlyID0gW3N0cmluZywgc3RyaW5nXTtcblxuZXhwb3J0IHR5cGUgVVJMU2VhcmNoUGFyYW1zSW5pdCA9XG4gIHwgc3RyaW5nXG4gIHwgUGFyYW1LZXlWYWx1ZVBhaXJbXVxuICB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPlxuICB8IFVSTFNlYXJjaFBhcmFtcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICBpbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0ID0gXCJcIlxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgdHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHxcbiAgICBBcnJheS5pc0FycmF5KGluaXQpIHx8XG4gICAgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtc1xuICAgICAgPyBpbml0XG4gICAgICA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgICAgIHJldHVybiBtZW1vLmNvbmNhdChcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV1cbiAgICAgICAgICApO1xuICAgICAgICB9LCBbXSBhcyBQYXJhbUtleVZhbHVlUGFpcltdKVxuICApO1xufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4xLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLyoqXG4gKiBUaGUgbW9kZSB0byB1c2Ugd2hlbiBydW5uaW5nIHRoZSBzZXJ2ZXIuXG4gKi9cbmxldCBTZXJ2ZXJNb2RlO1xuXG4oZnVuY3Rpb24gKFNlcnZlck1vZGUpIHtcbiAgU2VydmVyTW9kZVtcIkRldmVsb3BtZW50XCJdID0gXCJkZXZlbG9wbWVudFwiO1xuICBTZXJ2ZXJNb2RlW1wiUHJvZHVjdGlvblwiXSA9IFwicHJvZHVjdGlvblwiO1xuICBTZXJ2ZXJNb2RlW1wiVGVzdFwiXSA9IFwidGVzdFwiO1xufSkoU2VydmVyTW9kZSB8fCAoU2VydmVyTW9kZSA9IHt9KSk7XG5cbmZ1bmN0aW9uIGlzU2VydmVyTW9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IFNlcnZlck1vZGUuRGV2ZWxvcG1lbnQgfHwgdmFsdWUgPT09IFNlcnZlck1vZGUuUHJvZHVjdGlvbiB8fCB2YWx1ZSA9PT0gU2VydmVyTW9kZS5UZXN0O1xufVxuXG5leHBvcnQgeyBTZXJ2ZXJNb2RlLCBpc1NlcnZlck1vZGUgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMS4xXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8vIE5PVEU6IG1ha2Ugc3VyZSB0byBjaGFuZ2UgdGhlIFJvdXRlIGluIHJlbWl4LXJlYWN0IGlmIHlvdSBjaGFuZ2UgdGhpc1xuLy8gTk9URTogbWFrZSBzdXJlIHRvIGNoYW5nZSB0aGUgRW50cnlSb3V0ZSBpbiByZW1peC1yZWFjdCBpZiB5b3UgY2hhbmdlIHRoaXNcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcGFyZW50SWQpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hbmlmZXN0KS5maWx0ZXIoa2V5ID0+IG1hbmlmZXN0W2tleV0ucGFyZW50SWQgPT09IHBhcmVudElkKS5tYXAoaWQgPT4gKHsgLi4ubWFuaWZlc3RbaWRdLFxuICAgIGNoaWxkcmVuOiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIGlkKVxuICB9KSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJvdXRlcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4xLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IGpzZXNjIGZyb20gJ2pzZXNjJztcblxuZnVuY3Rpb24gY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKSB7XG4gIC8vIFVzZSBqc2VzYyB0byBlc2NhcGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBsb2FkZXJzLiBUaGlzIHN0cmluZyBpc1xuICAvLyBpbnNlcnRlZCBkaXJlY3RseSBpbnRvIHRoZSBIVE1MIGluIHRoZSBgPFNjcmlwdHM+YCBlbGVtZW50LlxuICByZXR1cm4ganNlc2Moc2VydmVySGFuZG9mZiwge1xuICAgIGlzU2NyaXB0Q29udGV4dDogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjEuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBjcmVhdGVSZXF1ZXN0SGFuZGxlciBhcyBjcmVhdGVSZXF1ZXN0SGFuZGxlciQxIH0gZnJvbSAnQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RIYW5kbGVyKHtcbiAgYnVpbGQsXG4gIGdldExvYWRDb250ZXh0LFxuICBtb2RlXG59KSB7XG4gIGxldCBwbGF0Zm9ybSA9IHt9O1xuICBsZXQgaGFuZGxlUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3RIYW5kbGVyJDEoYnVpbGQsIHBsYXRmb3JtLCBtb2RlKTtcbiAgcmV0dXJuIGNvbnRleHQgPT4ge1xuICAgIGxldCBsb2FkQ29udGV4dCA9IHR5cGVvZiBnZXRMb2FkQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiID8gZ2V0TG9hZENvbnRleHQoY29udGV4dCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGhhbmRsZVJlcXVlc3QoY29udGV4dC5yZXF1ZXN0LCBsb2FkQ29udGV4dCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlcih7XG4gIGJ1aWxkLFxuICBnZXRMb2FkQ29udGV4dCxcbiAgbW9kZVxufSkge1xuICBjb25zdCBoYW5kbGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdEhhbmRsZXIoe1xuICAgIGJ1aWxkLFxuICAgIGdldExvYWRDb250ZXh0LFxuICAgIG1vZGVcbiAgfSk7XG5cbiAgY29uc3QgaGFuZGxlRmV0Y2ggPSBhc3luYyBjb250ZXh0ID0+IHtcbiAgICBsZXQgcmVzcG9uc2U7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL3dyYW5nbGVyMi9pc3N1ZXMvMTE3XG5cbiAgICBjb250ZXh0LnJlcXVlc3QuaGVhZGVycy5kZWxldGUoXCJpZi1ub25lLW1hdGNoXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmVzcG9uc2U7XG5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgY29udGV4dC5lbnYuQVNTRVRTLmZldGNoKGNvbnRleHQucmVxdWVzdC51cmwsIGNvbnRleHQucmVxdWVzdC5jbG9uZSgpKTtcbiAgICAgIHJlc3BvbnNlID0gKF9yZXNwb25zZSA9IHJlc3BvbnNlKSAhPT0gbnVsbCAmJiBfcmVzcG9uc2UgIT09IHZvaWQgMCAmJiBfcmVzcG9uc2Uub2sgPyBuZXcgUmVzcG9uc2UocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpIDogdW5kZWZpbmVkO1xuICAgIH0gY2F0Y2gge31cblxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVxdWVzdChjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG5cbiAgcmV0dXJuIGFzeW5jIGNvbnRleHQgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRmV0Y2goY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiYgZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoZS5tZXNzYWdlIHx8IGUudG9TdHJpbmcoKSwge1xuICAgICAgICAgIHN0YXR1czogNTAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiSW50ZXJuYWwgRXJyb3JcIiwge1xuICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlciwgY3JlYXRlUmVxdWVzdEhhbmRsZXIgfTtcbiIsICJcbmltcG9ydCAqIGFzIGVudHJ5U2VydmVyIGZyb20gXCIvVXNlcnMvbG9nYW5tY2Fuc2gvRGV2ZWxvcGVyL2dpdGh1Yi5jb20vcmVtaXgvcmVtaXgvZGVwbG95bWVudC10ZXN0L3JlbWl4LWNmLXBhZ2VzLWFkZDhmYmZ0ZXN0L2FwcC9lbnRyeS5zZXJ2ZXIudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTAgZnJvbSBcIi9Vc2Vycy9sb2dhbm1jYW5zaC9EZXZlbG9wZXIvZ2l0aHViLmNvbS9yZW1peC9yZW1peC9kZXBsb3ltZW50LXRlc3QvcmVtaXgtY2YtcGFnZXMtYWRkOGZiZnRlc3QvYXBwL3Jvb3QudHN4XCI7XG5pbXBvcnQgKiBhcyByb3V0ZTEgZnJvbSBcIi9Vc2Vycy9sb2dhbm1jYW5zaC9EZXZlbG9wZXIvZ2l0aHViLmNvbS9yZW1peC9yZW1peC9kZXBsb3ltZW50LXRlc3QvcmVtaXgtY2YtcGFnZXMtYWRkOGZiZnRlc3QvYXBwL3JvdXRlcy9pbmRleC50c3hcIjtcbiAgZXhwb3J0IHsgZGVmYXVsdCBhcyBhc3NldHMgfSBmcm9tIFwiQHJlbWl4LXJ1bi9hc3NldHMtbWFuaWZlc3RcIjtcbiAgZXhwb3J0IGNvbnN0IGVudHJ5ID0geyBtb2R1bGU6IGVudHJ5U2VydmVyIH07XG4gIGV4cG9ydCBjb25zdCByb3V0ZXMgPSB7XG4gICAgXCJyb290XCI6IHtcbiAgICAgIGlkOiBcInJvb3RcIixcbiAgICAgIHBhcmVudElkOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiBcIlwiLFxuICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGUwXG4gICAgfSxcbiAgXCJyb3V0ZXMvaW5kZXhcIjoge1xuICAgICAgaWQ6IFwicm91dGVzL2luZGV4XCIsXG4gICAgICBwYXJlbnRJZDogXCJyb290XCIsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBpbmRleDogdHJ1ZSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHVuZGVmaW5lZCxcbiAgICAgIG1vZHVsZTogcm91dGUxXG4gICAgfVxuICB9OyIsICJpbXBvcnQgeyByZW5kZXJUb1N0cmluZyB9IGZyb20gXCJyZWFjdC1kb20vc2VydmVyXCI7XG5pbXBvcnQgeyBSZW1peFNlcnZlciB9IGZyb20gXCJyZW1peFwiO1xuaW1wb3J0IHR5cGUgeyBFbnRyeUNvbnRleHQgfSBmcm9tIFwicmVtaXhcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChcbiAgcmVxdWVzdDogUmVxdWVzdCxcbiAgcmVzcG9uc2VTdGF0dXNDb2RlOiBudW1iZXIsXG4gIHJlc3BvbnNlSGVhZGVyczogSGVhZGVycyxcbiAgcmVtaXhDb250ZXh0OiBFbnRyeUNvbnRleHRcbikge1xuICBjb25zdCBtYXJrdXAgPSByZW5kZXJUb1N0cmluZyhcbiAgICA8UmVtaXhTZXJ2ZXIgY29udGV4dD17cmVtaXhDb250ZXh0fSB1cmw9e3JlcXVlc3QudXJsfSAvPlxuICApO1xuXG4gIHJlc3BvbnNlSGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L2h0bWxcIik7XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShcIjwhRE9DVFlQRSBodG1sPlwiICsgbWFya3VwLCB7XG4gICAgc3RhdHVzOiByZXNwb25zZVN0YXR1c0NvZGUsXG4gICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gIH0pO1xufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4xLjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgRm9ybSwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIE91dGxldCwgUHJlZmV0Y2hQYWdlTGlua3MsIFJlbWl4QnJvd3NlciwgUmVtaXhTZXJ2ZXIsIFNjcmlwdHMsIFNjcm9sbFJlc3RvcmF0aW9uLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUNhdGNoLCB1c2VGZXRjaGVyLCB1c2VGZXRjaGVycywgdXNlRm9ybUFjdGlvbiwgdXNlSHJlZiwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlU2VhcmNoUGFyYW1zLCB1c2VTdWJtaXQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICdAcmVtaXgtcnVuL3JlYWN0JztcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IFJlbWl4QnJvd3NlciB9IGZyb20gJy4vYnJvd3Nlci5qcyc7XG5leHBvcnQgeyBPdXRsZXQsIHVzZUhyZWYsIHVzZUxvY2F0aW9uLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuZXhwb3J0IHsgRm9ybSwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIFByZWZldGNoUGFnZUxpbmtzLCBTY3JpcHRzLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMb2FkZXJEYXRhLCB1c2VNYXRjaGVzLCB1c2VTdWJtaXQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuZXhwb3J0IHsgdXNlQ2F0Y2ggfSBmcm9tICcuL2Vycm9yQm91bmRhcmllcy5qcyc7XG5leHBvcnQgeyBTY3JvbGxSZXN0b3JhdGlvbiB9IGZyb20gJy4vc2Nyb2xsLXJlc3RvcmF0aW9uLmpzJztcbmV4cG9ydCB7IFJlbWl4U2VydmVyIH0gZnJvbSAnLi9zZXJ2ZXIuanMnO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4xLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VIcmVmLCBOYXZMaW5rIGFzIE5hdkxpbmskMSwgTGluayBhcyBMaW5rJDEsIHVzZUxvY2F0aW9uLCB1c2VSZXNvbHZlZFBhdGgsIHVzZU5hdmlnYXRlLCBSb3V0ZXIsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgUmVtaXhFcnJvckJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSB9IGZyb20gJy4vZXJyb3JCb3VuZGFyaWVzLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuaW1wb3J0IHsgZ2V0TGlua3NGb3JNYXRjaGVzLCBpc1BhZ2VMaW5rRGVzY3JpcHRvciwgZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzLCBnZXREYXRhTGlua0hyZWZzLCBnZXRNb2R1bGVMaW5rSHJlZnMsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzIH0gZnJvbSAnLi9saW5rcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sIH0gZnJvbSAnLi9tYXJrdXAuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZXMuanMnO1xuaW1wb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcuL3RyYW5zaXRpb24uanMnO1xuXG5jb25zdCBSZW1peEVudHJ5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHVzZVJlbWl4RW50cnlDb250ZXh0KCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVtaXhFbnRyeUNvbnRleHQpO1xuICBpbnZhcmlhbnQoY29udGV4dCwgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxSZW1peD4gZWxlbWVudFwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIFJlbWl4RW50cnkoe1xuICBjb250ZXh0OiBlbnRyeUNvbnRleHQsXG4gIGFjdGlvbixcbiAgbG9jYXRpb246IGhpc3RvcnlMb2NhdGlvbixcbiAgbmF2aWdhdG9yOiBfbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBsZXQge1xuICAgIG1hbmlmZXN0LFxuICAgIHJvdXRlRGF0YTogZG9jdW1lbnRMb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZyxcbiAgICBhcHBTdGF0ZTogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yXG4gIH0gPSBlbnRyeUNvbnRleHQ7XG4gIGxldCBjbGllbnRSb3V0ZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdC5yb3V0ZXMsIHJvdXRlTW9kdWxlcywgUmVtaXhSb3V0ZSksIFttYW5pZmVzdCwgcm91dGVNb2R1bGVzXSk7XG4gIGxldCBbY2xpZW50U3RhdGUsIHNldENsaWVudFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGVudHJ5Q29tcG9uZW50RGlkQ2F0Y2hFbXVsYXRvcik7XG4gIGxldCBbdHJhbnNpdGlvbk1hbmFnZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcih7XG4gICAgICByb3V0ZXM6IGNsaWVudFJvdXRlcyxcbiAgICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGE6IGRvY3VtZW50TG9hZGVyRGF0YSxcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBjYXRjaDogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yLmNhdGNoLFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkOiBlbnRyeUNvbXBvbmVudERpZENhdGNoRW11bGF0b3IuY2F0Y2hCb3VuZGFyeVJvdXRlSWQsXG4gICAgICBvblJlZGlyZWN0OiBfbmF2aWdhdG9yLnJlcGxhY2UsXG4gICAgICBvbkNoYW5nZTogc3RhdGUgPT4ge1xuICAgICAgICBzZXRDbGllbnRTdGF0ZSh7XG4gICAgICAgICAgY2F0Y2g6IHN0YXRlLmNhdGNoLFxuICAgICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgICAgICBjYXRjaEJvdW5kYXJ5Um91dGVJZDogc3RhdGUuY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgICAgIGxvYWRlckJvdW5kYXJ5Um91dGVJZDogc3RhdGUuZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICAgICAgICB0cmFja0JvdW5kYXJpZXM6IGZhbHNlLFxuICAgICAgICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIEVuc3VyZXMgcHVzaGVzIGludGVycnVwdGluZyBwZW5kaW5nIG5hdmlnYXRpb25zIHVzZSByZXBsYWNlXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBSZWFjdCBSb3V0ZXJcblxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHB1c2ggPSAodG8sIHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKS50cmFuc2l0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IF9uYXZpZ2F0b3IucmVwbGFjZSh0bywgc3RhdGUpIDogX25hdmlnYXRvci5wdXNoKHRvLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7IC4uLl9uYXZpZ2F0b3IsXG4gICAgICBwdXNoXG4gICAgfTtcbiAgfSwgW19uYXZpZ2F0b3IsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG4gIGxldCB7XG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGFcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7IC8vIFNlbmQgbmV3IGxvY2F0aW9uIHRvIHRoZSB0cmFuc2l0aW9uIG1hbmFnZXJcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBsb2NhdGlvblxuICAgIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChoaXN0b3J5TG9jYXRpb24gPT09IGxvY2F0aW9uKSByZXR1cm47XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiBcIm5hdmlnYXRpb25cIixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBzdWJtaXNzaW9uOiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCksXG4gICAgICBhY3Rpb25cbiAgICB9KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBoaXN0b3J5TG9jYXRpb24sIGFjdGlvbl0pOyAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoZSBhcHAgdGhyZXcgYmVmb3JlIHJlbmRlcmluZyBhbnlcbiAgLy8gcm91dGVzLCBnZXQgdGhlIGVycm9yIGFuZCBwYXNzIGl0IHRvIHRoZSBFcnJvckJvdW5kYXJ5IHRvIGVtdWxhdGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYFxuXG4gIGxldCBzc3JFcnJvckJlZm9yZVJvdXRlc1JlbmRlcmVkID0gY2xpZW50U3RhdGUuZXJyb3IgJiYgY2xpZW50U3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBudWxsICYmIGNsaWVudFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9PT0gbnVsbCA/IGRlc2VyaWFsaXplRXJyb3IoY2xpZW50U3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkO1xuICBsZXQgc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZCA9IGNsaWVudFN0YXRlLmNhdGNoICYmIGNsaWVudFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBudWxsID8gY2xpZW50U3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBhcHBTdGF0ZTogY2xpZW50U3RhdGUsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgY2xpZW50Um91dGVzLFxuICAgICAgcm91dGVEYXRhOiBsb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSxcbiAgICBlcnJvcjogc3NyRXJyb3JCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peENhdGNoQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSxcbiAgICBjYXRjaDogc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVzLCBudWxsKSkpKSk7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3IoZGF0YSkge1xuICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBkYXRhLnN0YWNrO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIFJvdXRlcygpIHtcbiAgLy8gVE9ETzogQWRkIGByZW5kZXJNYXRjaGVzYCBmdW5jdGlvbiB0byBSUiB0aGF0IHdlIGNhbiB1c2UgYW5kIHRoZW4gd2UgZG9uJ3RcbiAgLy8gbmVlZCB0aGlzIGNvbXBvbmVudCwgd2UgY2FuIGp1c3QgYHJlbmRlck1hdGNoZXNgIGZyb20gUmVtaXhFbnRyeVxuICBsZXQge1xuICAgIGNsaWVudFJvdXRlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTsgLy8gZmFsbGJhY2sgdG8gdGhlIHJvb3QgaWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoXG5cbiAgbGV0IGVsZW1lbnQgPSB1c2VSb3V0ZXMoY2xpZW50Um91dGVzKSB8fCBjbGllbnRSb3V0ZXNbMF0uZWxlbWVudDtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSZW1peFJvdXRlXG5cblxuY29uc3QgUmVtaXhSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VSZW1peFJvdXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlbWl4Um91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KGNvbnRleHQsIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbiBhIHJlbWl4IHJvdXRlIGVsZW1lbnRcIik7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Um91dGVDb21wb25lbnQoe1xuICBpZFxufSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHtpZH1cIiBoYXMgbm8gY29tcG9uZW50ISBQbGVhc2UgZ28gYWRkIGEgXFxgZGVmYXVsdFxcYCBleHBvcnQgaW4gdGhlIHJvdXRlIG1vZHVsZSBmaWxlLlxcbmAgKyBcIklmIHlvdSB3ZXJlIHRyeWluZyB0byBuYXZpZ2F0ZSBvciBzdWJtaXQgdG8gYSByZXNvdXJjZSByb3V0ZSwgdXNlIGA8YT5gIGluc3RlYWQgb2YgYDxMaW5rPmAgb3IgYDxGb3JtIHJlbG9hZERvY3VtZW50PmAuXCIpO1xufVxuXG5mdW5jdGlvbiBSZW1peFJvdXRlKHtcbiAgaWRcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHtcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGFwcFN0YXRlXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtpZF07XG4gIGxldCB7XG4gICAgZGVmYXVsdDogQ29tcG9uZW50LFxuICAgIENhdGNoQm91bmRhcnksXG4gICAgRXJyb3JCb3VuZGFyeVxuICB9ID0gcm91dGVNb2R1bGVzW2lkXTtcbiAgbGV0IGVsZW1lbnQgPSBDb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFJvdXRlQ29tcG9uZW50LCB7XG4gICAgaWQ6IGlkXG4gIH0pO1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBkYXRhLFxuICAgIGlkXG4gIH07XG5cbiAgaWYgKENhdGNoQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyQ2F1Z2h0ID0gYXBwU3RhdGUuY2F0Y2ggJiYgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPT09IGlkID8gYXBwU3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7IC8vIFRoaXMgbmVlZHMgdG8gcnVuIGFmdGVyIHdlIGNoZWNrIGZvciB0aGUgZXJyb3IgZnJvbSBhIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBpbmNvcnJlY3RseSByZW5kZXIgdGhpcyBib3VuZGFyeSBmb3IgYSBsb2FkZXIgZXJyb3JcbiAgICAvLyBkZWVwZXIgaW4gdGhlIHRyZWUuXG5cbiAgICBpZiAoYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyQ2F1Z2h0ID8ge1xuICAgICAgaWQsXG5cbiAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYSBjYXRjaCBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhDYXRjaEJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IENhdGNoQm91bmRhcnksXG4gICAgICBjYXRjaDogbWF5YmVTZXJ2ZXJDYXVnaHRcbiAgICB9LCBlbGVtZW50KTtcbiAgfSAvLyBPbmx5IHdyYXAgaW4gZXJyb3IgYm91bmRhcnkgaWYgdGhlIHJvdXRlIGRlZmluZWQgb25lLCBvdGhlcndpc2UgbGV0IHRoZVxuICAvLyBlcnJvciBidWJibGUgdG8gdGhlIHBhcmVudCBib3VuZGFyeS4gV2UgY291bGQgZGVmYXVsdCB0byB1c2luZyBlcnJvclxuICAvLyBib3VuZGFyaWVzIGFyb3VuZCBldmVyeSByb3V0ZSwgYnV0IG5vdyBpZiB0aGUgYXBwIGRvZXNuJ3Qgd2FudCB1c2Vyc1xuICAvLyBzZWVpbmcgdGhlIGRlZmF1bHQgUmVtaXggRXJyb3JCb3VuZGFyeSBjb21wb25lbnQsIHRoZXkgKm11c3QqIGRlZmluZSBhblxuICAvLyBlcnJvciBib3VuZGFyeSBmb3IgKmV2ZXJ5KiByb3V0ZSBhbmQgdGhhdCB3b3VsZCBiZSBhbm5veWluZy4gTWlnaHQgYXNcbiAgLy8gd2VsbCBtYWtlIGl0IHJlcXVpcmVkIGF0IHRoYXQgcG9pbnQuXG4gIC8vXG4gIC8vIEJ5IGNvbmRpdGlvbmFsbHkgd3JhcHBpbmcgbGlrZSB0aGlzLCB3ZSBhbGxvdyBhcHBzIHRvIGRlZmluZSBhIHRvcCBsZXZlbFxuICAvLyBFcnJvckJvdW5kYXJ5IGNvbXBvbmVudCBhbmQgYmUgZG9uZSB3aXRoIGl0LiBUaGVuLCBpZiB0aGV5IHdhbnQgdG8sIHRoZXlcbiAgLy8gY2FuIGFkZCBtb3JlIHNwZWNpZmljIGJvdW5kYXJpZXMgYnkgZXhwb3J0aW5nIEVycm9yQm91bmRhcnkgY29tcG9uZW50c1xuICAvLyBmb3Igd2hpY2hldmVyIHJvdXRlcyB0aGV5IHBsZWFzZS5cbiAgLy9cbiAgLy8gTk9URTogdGhpcyBraW5kIG9mIGxvZ2ljIHdpbGwgbW92ZSBpbnRvIFJlYWN0IFJvdXRlclxuXG5cbiAgaWYgKEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPSBhcHBTdGF0ZS5lcnJvciAmJiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkKSA/IGRlc2VyaWFsaXplRXJyb3IoYXBwU3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkOyAvLyBUaGlzIG5lZWRzIHRvIHJ1biBhZnRlciB3ZSBjaGVjayBmb3IgdGhlIGVycm9yIGZyb20gYSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgaW5jb3JyZWN0bHkgcmVuZGVyIHRoaXMgYm91bmRhcnkgZm9yIGEgbG9hZGVyIGVycm9yXG4gICAgLy8gZGVlcGVyIGluIHRoZSB0cmVlLlxuXG4gICAgaWYgKGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcykge1xuICAgICAgYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPyB7XG4gICAgICBpZCxcblxuICAgICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvciBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhFcnJvckJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IEVycm9yQm91bmRhcnksXG4gICAgICBlcnJvcjogbWF5YmVTZXJ2ZXJSZW5kZXJFcnJvclxuICAgIH0sIGVsZW1lbnQpO1xuICB9IC8vIEl0J3MgaW1wb3J0YW50IGZvciB0aGUgcm91dGUgY29udGV4dCB0byBiZSBhYm92ZSB0aGUgZXJyb3IgYm91bmRhcnkgc28gdGhhdFxuICAvLyBhIGNhbGwgdG8gYHVzZUxvYWRlckRhdGFgIGRvZXNuJ3QgYWNjaWRlbnRhbGx5IGdldCB0aGUgcGFyZW50cyByb3V0ZSdzIGRhdGEuXG5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCBlbGVtZW50KTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFB1YmxpYyBBUElcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwcmVmZXRjaGluZyBiZWhhdmlvciBvZiB0aGUgbGluazpcbiAqXG4gKiAtIFwiaW50ZW50XCI6IERlZmF1bHQsIGZldGNoZWQgd2hlbiB0aGUgdXNlciBmb2N1c2VzIG9yIGhvdmVycyB0aGUgbGlua1xuICogLSBcInJlbmRlclwiOiBGZXRjaGVkIHdoZW4gdGhlIGxpbmsgaXMgcmVuZGVyZWRcbiAqIC0gXCJub25lXCI6IE5ldmVyIGZldGNoZWRcbiAqL1xuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGxldCB7XG4gICAgb25Gb2N1cyxcbiAgICBvbkJsdXIsXG4gICAgb25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnRcbiAgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICB9LCBbcHJlZmV0Y2hdKTtcblxuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJpbnRlbnRcIikge1xuICAgICAgc2V0TWF5YmVQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGNhbmNlbEludGVudCA9ICgpID0+IHtcbiAgICBpZiAocHJlZmV0Y2ggPT09IFwiaW50ZW50XCIpIHtcbiAgICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCB7XG4gICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQmx1ciwgY2FuY2VsSW50ZW50KSxcbiAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICBvblRvdWNoU3RhcnQ6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uVG91Y2hTdGFydCwgc2V0SW50ZW50KVxuICB9XTtcbn1cblxubGV0IE5hdkxpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0byxcbiAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOYXZMaW5rJDEsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB0bzogdG9cbiAgfSwgcHJlZmV0Y2hIYW5kbGVycywgcHJvcHMpKSwgc2hvdWxkUHJlZmV0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywge1xuICAgIHBhZ2U6IGhyZWZcbiAgfSkgOiBudWxsKTtcbn0pO1xubGV0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0byxcbiAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rJDEsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB0bzogdG9cbiAgfSwgcHJlZmV0Y2hIYW5kbGVycywgcHJvcHMpKSwgc2hvdWxkUHJlZmV0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywge1xuICAgIHBhZ2U6IGhyZWZcbiAgfSkgOiBudWxsKTtcbn0pO1xuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgdGhlaXJIYW5kbGVyICYmIHRoZWlySGFuZGxlcihldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgYDxsaW5rPmAgdGFncyBmb3IgdGhlIGN1cnJlbnQgcm91dGVzLlxuICovXG5cbmZ1bmN0aW9uIExpbmtzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIG1hbmlmZXN0XG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbGlua3MgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSwgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsaW5rcy5tYXAobGluayA9PiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihsaW5rKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBsaW5rLnBhZ2VcbiAgfSwgbGluaykpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGxpbmsucmVsICsgbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3Moe1xuICBwYWdlLFxuICAuLi5kYXRhTGlua1Byb3BzXG59KSB7XG4gIGxldCB7XG4gICAgY2xpZW50Um91dGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbWF0Y2hlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hDbGllbnRSb3V0ZXMoY2xpZW50Um91dGVzLCBwYWdlKSwgW2NsaWVudFJvdXRlcywgcGFnZV0pO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIGNvbnNvbGUud2FybihgVHJpZWQgdG8gcHJlZmV0Y2ggJHtwYWdlfSBidXQgbm8gcm91dGVzIG1hdGNoZWQuYCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3NJbXBsLCBfZXh0ZW5kcyh7XG4gICAgcGFnZTogcGFnZSxcbiAgICBtYXRjaGVzOiBtYXRjaGVzXG4gIH0sIGRhdGFMaW5rUHJvcHMpKTtcbn1cblxuZnVuY3Rpb24gdXNlUHJlZmV0Y2hlZFN0eWxlc2hlZXRzKG1hdGNoZXMpIHtcbiAgbGV0IHtcbiAgICByb3V0ZU1vZHVsZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBbc3R5bGVMaW5rcywgc2V0U3R5bGVMaW5rc10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGludGVycnVwdGVkID0gZmFsc2U7XG4gICAgZ2V0U3R5bGVzaGVldFByZWZldGNoTGlua3MobWF0Y2hlcywgcm91dGVNb2R1bGVzKS50aGVuKGxpbmtzID0+IHtcbiAgICAgIGlmICghaW50ZXJydXB0ZWQpIHNldFN0eWxlTGlua3MobGlua3MpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW21hdGNoZXMsIHJvdXRlTW9kdWxlc10pO1xuICByZXR1cm4gc3R5bGVMaW5rcztcbn1cblxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3NJbXBsKHtcbiAgcGFnZSxcbiAgbWF0Y2hlczogbmV4dE1hdGNoZXMsXG4gIC4uLmxpbmtQcm9wc1xufSkge1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgbWFuaWZlc3RcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBuZXdNYXRjaGVzRm9yRGF0YSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKHBhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBsb2NhdGlvbiwgXCJkYXRhXCIpLCBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uXSk7XG4gIGxldCBuZXdNYXRjaGVzRm9yQXNzZXRzID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uLCBcImFzc2V0c1wiKSwgW3BhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBsb2NhdGlvbl0pO1xuICBsZXQgZGF0YUhyZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXREYXRhTGlua0hyZWZzKHBhZ2UsIG5ld01hdGNoZXNGb3JEYXRhLCBtYW5pZmVzdCksIFtuZXdNYXRjaGVzRm9yRGF0YSwgcGFnZSwgbWFuaWZlc3RdKTtcbiAgbGV0IG1vZHVsZUhyZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXRNb2R1bGVMaW5rSHJlZnMobmV3TWF0Y2hlc0ZvckFzc2V0cywgbWFuaWZlc3QpLCBbbmV3TWF0Y2hlc0ZvckFzc2V0cywgbWFuaWZlc3RdKTsgLy8gbmVlZHMgdG8gYmUgYSBob29rIHdpdGggYXN5bmMgYmVoYXZpb3IgYmVjYXVzZSB3ZSBuZWVkIHRoZSBtb2R1bGVzLCBub3RcbiAgLy8ganVzdCB0aGUgbWFuaWZlc3QgbGlrZSB0aGUgb3RoZXIgbGlua3MgaW4gaGVyZS5cblxuICBsZXQgc3R5bGVMaW5rcyA9IHVzZVByZWZldGNoZWRTdHlsZXNoZWV0cyhuZXdNYXRjaGVzRm9yQXNzZXRzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBkYXRhSHJlZnMubWFwKGhyZWYgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGhyZWYsXG4gICAgcmVsOiBcInByZWZldGNoXCIsXG4gICAgYXM6IFwiZmV0Y2hcIixcbiAgICBocmVmOiBocmVmXG4gIH0sIGxpbmtQcm9wcykpKSwgbW9kdWxlSHJlZnMubWFwKGhyZWYgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGhyZWYsXG4gICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICBocmVmOiBocmVmXG4gIH0sIGxpbmtQcm9wcykpKSwgc3R5bGVMaW5rcy5tYXAobGluayA9PlxuICAvKiNfX1BVUkVfXyovXG4gIC8vIHRoZXNlIGRvbid0IHNwcmVhZCBgbGlua1Byb3BzYCBiZWNhdXNlIHRoZXkgYXJlIGZ1bGwgbGluayBkZXNjcmlwdG9yc1xuICAvLyBhbHJlYWR5IHdpdGggdGhlaXIgb3duIHByb3BzXG4gIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGxpbmsuaHJlZlxuICB9LCBsaW5rKSkpKTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgYDx0aXRsZT5gIGFuZCBgPG1ldGE+YCB0YWdzIGZvciB0aGUgY3VycmVudCByb3V0ZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBNZXRhKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVEYXRhLFxuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG1ldGEgPSB7fTtcbiAgbGV0IHBhcmVudHNEYXRhID0ge307XG5cbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCByb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgbGV0IGRhdGEgPSByb3V0ZURhdGFbcm91dGVJZF07XG4gICAgbGV0IHBhcmFtcyA9IG1hdGNoLnBhcmFtcztcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNbcm91dGVJZF07XG5cbiAgICBpZiAocm91dGVNb2R1bGUubWV0YSkge1xuICAgICAgbGV0IHJvdXRlTWV0YSA9IHR5cGVvZiByb3V0ZU1vZHVsZS5tZXRhID09PSBcImZ1bmN0aW9uXCIgPyByb3V0ZU1vZHVsZS5tZXRhKHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcGFyZW50c0RhdGEsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgbG9jYXRpb25cbiAgICAgIH0pIDogcm91dGVNb2R1bGUubWV0YTtcbiAgICAgIE9iamVjdC5hc3NpZ24obWV0YSwgcm91dGVNZXRhKTtcbiAgICB9XG5cbiAgICBwYXJlbnRzRGF0YVtyb3V0ZUlkXSA9IGRhdGE7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIE9iamVjdC5lbnRyaWVzKG1ldGEpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgIC8vIE9wZW4gR3JhcGggdGFncyB1c2UgdGhlIGBwcm9wZXJ0eWAgYXR0cmlidXRlLCB3aGlsZSBvdGhlciBtZXRhIHRhZ3NcbiAgICAvLyB1c2UgYG5hbWVgLiBTZWUgaHR0cHM6Ly9vZ3AubWUvXG4gICAgbGV0IGlzT3BlbkdyYXBoVGFnID0gbmFtZS5zdGFydHNXaXRoKFwib2c6XCIpO1xuICAgIHJldHVybiBuYW1lID09PSBcInRpdGxlXCIgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIHtcbiAgICAgIGtleTogXCJ0aXRsZVwiXG4gICAgfSwgdmFsdWUpIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoY29udGVudCA9PiBpc09wZW5HcmFwaFRhZyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUgKyBjb250ZW50LFxuICAgICAgcHJvcGVydHk6IG5hbWUsXG4gICAgICBjb250ZW50OiBjb250ZW50XG4gICAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBuYW1lICsgY29udGVudCxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBjb250ZW50OiBjb250ZW50XG4gICAgfSkpIDogaXNPcGVuR3JhcGhUYWcgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBuYW1lLFxuICAgICAgcHJvcGVydHk6IG5hbWUsXG4gICAgICBjb250ZW50OiB2YWx1ZVxuICAgIH0pIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogbmFtZSxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBjb250ZW50OiB2YWx1ZVxuICAgIH0pO1xuICB9KSk7XG59XG4vKipcbiAqIFRyYWNrcyB3aGV0aGVyIFJlbWl4IGhhcyBmaW5pc2hlZCBoeWRyYXRpbmcgb3Igbm90LCBzbyBzY3JpcHRzIGNhbiBiZSBza2lwcGVkXG4gKiBkdXJpbmcgY2xpZW50LXNpZGUgdXBkYXRlcy5cbiAqL1xuXG5sZXQgaXNIeWRyYXRlZCA9IGZhbHNlO1xuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGA8c2NyaXB0PmAgdGFncyBuZWVkZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci4gQnVuZGxlcyBmb3JcbiAqIGFkZGl0aW9uYWwgcm91dGVzIGFyZSBsb2FkZWQgbGF0ZXIgYXMgbmVlZGVkLlxuICpcbiAqIEBwYXJhbSBwcm9wcyBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYWRkIHRvIGVhY2ggc2NyaXB0IHRhZyB0aGF0IGlzIHJlbmRlcmVkLlxuICogSW4gYWRkaXRpb24gdG8gc2NyaXB0cywgXFw8bGluayByZWw9XCJtb2R1bGVwcmVsb2FkXCI+IHRhZ3MgcmVjZWl2ZSB0aGUgY3Jvc3NPcmlnaW5cbiAqIHByb3BlcnR5IGlmIHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBTY3JpcHRzKHByb3BzKSB7XG4gIGxldCB7XG4gICAgbWFuaWZlc3QsXG4gICAgbWF0Y2hlcyxcbiAgICBwZW5kaW5nTG9jYXRpb24sXG4gICAgY2xpZW50Um91dGVzLFxuICAgIHNlcnZlckhhbmRvZmZTdHJpbmdcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNIeWRyYXRlZCA9IHRydWU7XG4gIH0sIFtdKTtcbiAgbGV0IGluaXRpYWxTY3JpcHRzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IGNvbnRleHRTY3JpcHQgPSBzZXJ2ZXJIYW5kb2ZmU3RyaW5nID8gYHdpbmRvdy5fX3JlbWl4Q29udGV4dCA9ICR7c2VydmVySGFuZG9mZlN0cmluZ307YCA6IFwiXCI7XG4gICAgbGV0IHJvdXRlTW9kdWxlc1NjcmlwdCA9IGAke21hdGNoZXMubWFwKChtYXRjaCwgaW5kZXgpID0+IGBpbXBvcnQgKiBhcyByb3V0ZSR7aW5kZXh9IGZyb20gJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdLm1vZHVsZSl9O2ApLmpvaW4oXCJcXG5cIil9XG53aW5kb3cuX19yZW1peFJvdXRlTW9kdWxlcyA9IHske21hdGNoZXMubWFwKChtYXRjaCwgaW5kZXgpID0+IGAke0pTT04uc3RyaW5naWZ5KG1hdGNoLnJvdXRlLmlkKX06cm91dGUke2luZGV4fWApLmpvaW4oXCIsXCIpfX07YDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IGNyZWF0ZUh0bWwoY29udGV4dFNjcmlwdClcbiAgICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgc3JjOiBtYW5pZmVzdC51cmxcbiAgICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IGNyZWF0ZUh0bWwocm91dGVNb2R1bGVzU2NyaXB0KSxcbiAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgc3JjOiBtYW5pZmVzdC5lbnRyeS5tb2R1bGUsXG4gICAgICB0eXBlOiBcIm1vZHVsZVwiXG4gICAgfSkpKTsgLy8gZGlzYWJsZWQgZGVwcyBhcnJheSBiZWNhdXNlIHdlIGFyZSBwdXJwb3NlZnVsbHkgb25seSByZW5kZXJpbmcgdGhpcyBvbmNlXG4gICAgLy8gZm9yIGh5ZHJhdGlvbiwgYWZ0ZXIgdGhhdCB3ZSB3YW50IHRvIGp1c3QgY29udGludWUgcmVuZGVyaW5nIHRoZSBpbml0aWFsXG4gICAgLy8gc2NyaXB0cyBhcyB0aGV5IHdlcmUgd2hlbiB0aGUgcGFnZSBmaXJzdCBsb2FkZWRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgfSwgW10pOyAvLyBhdm9pZCB3YXRlcmZhbGwgd2hlbiBpbXBvcnRpbmcgdGhlIG5leHQgcm91dGUgbW9kdWxlXG5cbiAgbGV0IG5leHRNYXRjaGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbikge1xuICAgICAgLy8gRklYTUU6IGNhbiBwcm9iYWJseSB1c2UgdHJhbnNpdGlvbk1hbmFnZXIgYG5leHRNYXRjaGVzYFxuICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhjbGllbnRSb3V0ZXMsIHBlbmRpbmdMb2NhdGlvbik7XG4gICAgICBpbnZhcmlhbnQobWF0Y2hlcywgYE5vIHJvdXRlcyBtYXRjaCBwYXRoIFwiJHtwZW5kaW5nTG9jYXRpb24ucGF0aG5hbWV9XCJgKTtcbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSwgW3BlbmRpbmdMb2NhdGlvbiwgY2xpZW50Um91dGVzXSk7XG4gIGxldCByb3V0ZVByZWxvYWRzID0gbWF0Y2hlcy5jb25jYXQobmV4dE1hdGNoZXMpLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICByZXR1cm4gKHJvdXRlLmltcG9ydHMgfHwgW10pLmNvbmNhdChbcm91dGUubW9kdWxlXSk7XG4gIH0pLmZsYXQoMSk7XG4gIGxldCBwcmVsb2FkcyA9IG1hbmlmZXN0LmVudHJ5LmltcG9ydHMuY29uY2F0KHJvdXRlUHJlbG9hZHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGRlZHVwZShwcmVsb2FkcykubWFwKHBhdGggPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHtcbiAgICBrZXk6IHBhdGgsXG4gICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICBocmVmOiBwYXRoLFxuICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpblxuICB9KSksIGlzSHlkcmF0ZWQgPyBudWxsIDogaW5pdGlhbFNjcmlwdHMpO1xufVxuXG5mdW5jdGlvbiBkZWR1cGUoYXJyYXkpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycmF5KV07XG59XG5cbi8qKlxuICogQSBSZW1peC1hd2FyZSBgPGZvcm0+YC4gSXQgYmVoYXZlcyBsaWtlIGEgbm9ybWFsIGZvcm0gZXhjZXB0IHRoYXQgdGhlXG4gKiBpbnRlcmFjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgaXMgd2l0aCBgZmV0Y2hgIGluc3RlYWQgb2YgbmV3IGRvY3VtZW50XG4gKiByZXF1ZXN0cywgYWxsb3dpbmcgY29tcG9uZW50cyB0byBhZGQgbmljZXIgVVggdG8gdGhlIHBhZ2UgYXMgdGhlIGZvcm0gaXNcbiAqIHN1Ym1pdHRlZCBhbmQgcmV0dXJucyB3aXRoIGRhdGEuXG4gKi9cbmxldCBGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSk7XG59KTtcbmxldCBGb3JtSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHJlbG9hZERvY3VtZW50ID0gZmFsc2UsXG4gIHJlcGxhY2UgPSBmYWxzZSxcbiAgbWV0aG9kID0gXCJnZXRcIixcbiAgYWN0aW9uID0gXCIuXCIsXG4gIGVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBmZXRjaEtleSxcbiAgb25TdWJtaXQsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoZmV0Y2hLZXkpO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCBmb3JtTWV0aG9kKTtcbiAgbGV0IGZvcm1SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgbGV0IHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGZvcm1SZWYpOyAvLyBXaGVuIGNhbGxpbmcgYHN1Ym1pdGAgb24gdGhlIGZvcm0gZWxlbWVudCBpdHNlbGYsIHdlIGRvbid0IGdldCBkYXRhIGZyb21cbiAgLy8gdGhlIGJ1dHRvbiB0aGF0IHN1Ym1pdHRlZCB0aGUgZXZlbnQuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAgIDxGb3JtPlxuICAvLyAgICAgPGJ1dHRvbiBuYW1lPVwic29tZXRoaW5nXCIgdmFsdWU9XCJ3aGF0ZXZlclwiPlN1Ym1pdDwvYnV0dG9uPlxuICAvLyAgIDwvRm9ybT5cbiAgLy9cbiAgLy8gZm9ybURhdGEuZ2V0KFwic29tZXRoaW5nXCIpIHNob3VsZCBiZSBcIndoYXRldmVyXCIsIGJ1dCB3ZSBkb24ndCBnZXQgdGhhdFxuICAvLyB1bmxlc3Mgd2UgY2FsbCBzdWJtaXQgb24gdGhlIGNsaWNrZWQgYnV0dG9uIGl0c2VsZi5cbiAgLy9cbiAgLy8gVG8gZmlndXJlIG91dCB3aGljaCBidXR0b24gdHJpZ2dlcmVkIHRoZSBzdWJtaXQsIHdlJ2xsIGF0dGFjaCBhIGNsaWNrXG4gIC8vIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBmb3JtLiBUaGUgY2xpY2sgZXZlbnQgaXMgYWx3YXlzIHRyaWdnZXJlZCBiZWZvcmVcbiAgLy8gdGhlIHN1Ym1pdCBldmVudCAoZXZlbiB3aGVuIHN1Ym1pdHRpbmcgdmlhIGtleWJvYXJkIHdoZW4gZm9jdXNlZCBvblxuICAvLyBhbm90aGVyIGZvcm0gZmllbGQsIHllZWVlZXQpIHNvIHdlIHNob3VsZCBoYXZlIGFjY2VzcyB0byB0aGF0IGJ1dHRvbidzXG4gIC8vIGRhdGEgZm9yIHVzZSBpbiB0aGUgc3VibWl0IGhhbmRsZXIuXG5cbiAgbGV0IGNsaWNrZWRCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZm9ybSA9IGZvcm1SZWYuY3VycmVudDtcbiAgICBpZiAoIWZvcm0pIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcbiAgICAgIGxldCBzdWJtaXRCdXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChcImJ1dHRvbixpbnB1dFt0eXBlPXN1Ym1pdF1cIik7XG5cbiAgICAgIGlmIChzdWJtaXRCdXR0b24gJiYgc3VibWl0QnV0dG9uLnR5cGUgPT09IFwic3VibWl0XCIpIHtcbiAgICAgICAgY2xpY2tlZEJ1dHRvblJlZi5jdXJyZW50ID0gc3VibWl0QnV0dG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZm9ybSAmJiBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBtZXRob2Q6IGZvcm1NZXRob2QsXG4gICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgIGVuY1R5cGU6IGVuY1R5cGUsXG4gICAgb25TdWJtaXQ6IHJlbG9hZERvY3VtZW50ID8gdW5kZWZpbmVkIDogZXZlbnQgPT4ge1xuICAgICAgb25TdWJtaXQgJiYgb25TdWJtaXQoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdWJtaXQoY2xpY2tlZEJ1dHRvblJlZi5jdXJyZW50IHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICByZXBsYWNlXG4gICAgICB9KTtcbiAgICAgIGNsaWNrZWRCdXR0b25SZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBwcm9wcykpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQWN0aW9uUmVxdWVzdE1ldGhvZChtZXRob2QpIHtcbiAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBtZXRob2QgPT09IFwicG9zdFwiIHx8IG1ldGhvZCA9PT0gXCJwdXRcIiB8fCBtZXRob2QgPT09IFwicGF0Y2hcIiB8fCBtZXRob2QgPT09IFwiZGVsZXRlXCI7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgYDxmb3JtIGFjdGlvbj5gIHBhdGggcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm91dGUuXG4gKi9cblxuXG5mdW5jdGlvbiB1c2VGb3JtQWN0aW9uKGFjdGlvbiA9IFwiLlwiLCBtZXRob2QgPSBcImdldFwiKSB7XG4gIGxldCB7XG4gICAgaWRcbiAgfSA9IHVzZVJlbWl4Um91dGVDb250ZXh0KCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKGFjdGlvbik7XG4gIGxldCBzZWFyY2ggPSBwYXRoLnNlYXJjaDtcbiAgbGV0IGlzSW5kZXhSb3V0ZSA9IGlkLmVuZHNXaXRoKFwiL2luZGV4XCIpO1xuXG4gIGlmIChhY3Rpb24gPT09IFwiLlwiICYmIGlzSW5kZXhSb3V0ZSAmJiBpc0FjdGlvblJlcXVlc3RNZXRob2QobWV0aG9kKSkge1xuICAgIHNlYXJjaCA9IHNlYXJjaCA/IHNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuXG4gIHJldHVybiBwYXRoLnBhdGhuYW1lICsgc2VhcmNoO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgc3VibWl0IGEgZm9ybSAob3JcbiAqIHNvbWUgYXJiaXRyYXJ5IGRhdGEpIHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZVN1Ym1pdCgpIHtcbiAgcmV0dXJuIHVzZVN1Ym1pdEltcGwoKTtcbn1cbmZ1bmN0aW9uIHVzZVN1Ym1pdEltcGwoa2V5KSB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBkZWZhdWx0QWN0aW9uID0gdXNlRm9ybUFjdGlvbigpO1xuICBsZXQge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soKHRhcmdldCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgbGV0IG1ldGhvZDtcbiAgICBsZXQgYWN0aW9uO1xuICAgIGxldCBlbmNUeXBlO1xuICAgIGxldCBmb3JtRGF0YTtcblxuICAgIGlmIChpc0Zvcm1FbGVtZW50KHRhcmdldCkpIHtcbiAgICAgIGxldCBzdWJtaXNzaW9uVHJpZ2dlciA9IG9wdGlvbnMuc3VibWlzc2lvblRyaWdnZXI7XG4gICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCB0YXJnZXQubWV0aG9kO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgdGFyZ2V0LmFjdGlvbjtcbiAgICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgdGFyZ2V0LmVuY3R5cGU7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSh0YXJnZXQpO1xuXG4gICAgICBpZiAoc3VibWlzc2lvblRyaWdnZXIgJiYgc3VibWlzc2lvblRyaWdnZXIubmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoc3VibWlzc2lvblRyaWdnZXIubmFtZSwgc3VibWlzc2lvblRyaWdnZXIudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG5cbiAgICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3VibWl0IGEgPGJ1dHRvbj4gd2l0aG91dCBhIDxmb3JtPmApO1xuICAgICAgfSAvLyA8YnV0dG9uPi88aW5wdXQgdHlwZT1cInN1Ym1pdFwiPiBtYXkgb3ZlcnJpZGUgYXR0cmlidXRlcyBvZiA8Zm9ybT5cblxuXG4gICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLm1ldGhvZDtcbiAgICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtYWN0aW9uXCIpIHx8IGZvcm0uYWN0aW9uO1xuICAgICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikgfHwgZm9ybS5lbmN0eXBlO1xuICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7IC8vIEluY2x1ZGUgbmFtZSArIHZhbHVlIGZyb20gYSA8YnV0dG9uPlxuXG4gICAgICBpZiAodGFyZ2V0Lm5hbWUpIHtcbiAgICAgICAgZm9ybURhdGEuc2V0KHRhcmdldC5uYW1lLCB0YXJnZXQudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIGAgKyBgPGlucHV0IHR5cGU9XCJzdWJtaXR8aW1hZ2VcIj5gKTtcbiAgICAgIH1cblxuICAgICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJnZXRcIjtcbiAgICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IGRlZmF1bHRBY3Rpb247XG4gICAgICBlbmNUeXBlID0gb3B0aW9ucy5lbmNUeXBlIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICBmb3JtRGF0YSA9IHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgICAgICAgIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXModGFyZ2V0KSkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHRhcmdldFtuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgbGV0IHVybCA9IG5ldyBVUkwoYWN0aW9uLCBgJHtwcm90b2NvbH0vLyR7aG9zdH1gKTtcblxuICAgIGlmIChtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIikge1xuICAgICAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBmb3JtRGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN1Ym1pdCBiaW5hcnkgZm9ybSBkYXRhIHVzaW5nIEdFVGApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGFjdGlvbjogdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCxcbiAgICAgIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICBlbmNUeXBlLFxuICAgICAga2V5OiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOClcbiAgICB9O1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiZmV0Y2hlclwiLFxuICAgICAgICBocmVmOiBzdWJtaXNzaW9uLmFjdGlvbixcbiAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0TmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pO1xuICAgICAgbmF2aWdhdGUodXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCwge1xuICAgICAgICByZXBsYWNlOiBvcHRpb25zLnJlcGxhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2RlZmF1bHRBY3Rpb24sIGtleSwgbmF2aWdhdGUsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG59XG5sZXQgbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uO1xuXG5mdW5jdGlvbiBzZXROZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikge1xuICBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uO1xufVxuXG5mdW5jdGlvbiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCkge1xuICBsZXQgc3VibWlzc2lvbiA9IG5leHROYXZpZ2F0aW9uU3VibWlzc2lvbjtcbiAgbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uID0gdW5kZWZpbmVkO1xuICByZXR1cm4gc3VibWlzc2lvbjtcbn1cblxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzRm9ybUVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmb3JtXCI7XG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYGJlZm9yZXVubG9hZGAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcywgd2hpY2ggYXV0b21hdGljYWxseSBoYXBwZW5zIG9uIHRoZSBuZXh0IGA8TGluaz5gIGNsaWNrIHdoZW4gUmVtaXhcbiAqIGRldGVjdHMgYSBuZXcgdmVyc2lvbiBvZiB0aGUgYXBwIGlzIGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyLlxuICpcbiAqIE5vdGU6IFRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIGNyZWF0ZWQgd2l0aFxuICogYFJlYWN0LnVzZUNhbGxiYWNrKClgLlxuICovXG5cblxuZnVuY3Rpb24gdXNlQmVmb3JlVW5sb2FkKGNhbGxiYWNrKSB7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrXSk7XG59XG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVEYXRhLFxuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICB2YXIgX3JvdXRlTW9kdWxlcyRtYXRjaCRyO1xuXG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IG1hdGNoO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogbWF0Y2gucm91dGUuaWQsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGRhdGE6IHJvdXRlRGF0YVttYXRjaC5yb3V0ZS5pZF0sXG4gICAgICAvLyBpZiB0aGUgbW9kdWxlIGZhaWxzIHRvIGxvYWQgb3IgYW4gZXJyb3IvcmVzcG9uc2UgaXMgdGhyb3duLCB0aGUgbW9kdWxlXG4gICAgICAvLyB3b24ndCBiZSBkZWZpbmVkLlxuICAgICAgaGFuZGxlOiAoX3JvdXRlTW9kdWxlcyRtYXRjaCRyID0gcm91dGVNb2R1bGVzW21hdGNoLnJvdXRlLmlkXSkgPT09IG51bGwgfHwgX3JvdXRlTW9kdWxlcyRtYXRjaCRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcm91dGVNb2R1bGVzJG1hdGNoJHIuaGFuZGxlXG4gICAgfTtcbiAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgZnJvbSB0aGUgY3VycmVudCByb3V0ZSdzIGBsb2FkZXJgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKSB7XG4gIHJldHVybiB1c2VSZW1peFJvdXRlQ29udGV4dCgpLmRhdGE7XG59XG5mdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICBsZXQge1xuICAgIGlkOiByb3V0ZUlkXG4gIH0gPSB1c2VSZW1peFJvdXRlQ29udGV4dCgpO1xuICBsZXQge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQge1xuICAgIGFjdGlvbkRhdGFcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gIHJldHVybiBhY3Rpb25EYXRhID8gYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpLnRyYW5zaXRpb247XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoS2V5KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIC8vIFRPRE86IG1ha2UgQU5PVEhFUiBmb3JtIHcvbyBhIGZldGNoS2V5IHByb3BcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcmVmOiByZWYsXG4gICAgICBmZXRjaEtleTogZmV0Y2hLZXlcbiAgICB9KSk7XG4gIH0pO1xufVxuXG5sZXQgZmV0Y2hlcklkID0gMDtcblxuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqL1xuZnVuY3Rpb24gdXNlRmV0Y2hlcigpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IFtrZXldID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gU3RyaW5nKCsrZmV0Y2hlcklkKSk7XG4gIGxldCBbRm9ybV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVGZXRjaGVyRm9ybShrZXkpKTtcbiAgbGV0IFtsb2FkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGhyZWYgPT4ge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLnNlbmQoe1xuICAgICAgdHlwZTogXCJmZXRjaGVyXCIsXG4gICAgICBocmVmLFxuICAgICAga2V5XG4gICAgfSk7XG4gIH0pO1xuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChrZXkpO1xuICBsZXQgZmV0Y2hlciA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldEZldGNoZXIoa2V5KTtcbiAgbGV0IGZldGNoZXJXaXRoQ29tcG9uZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBGb3JtLFxuICAgIHN1Ym1pdCxcbiAgICBsb2FkLFxuICAgIC4uLmZldGNoZXJcbiAgfSksIFtmZXRjaGVyLCBGb3JtLCBzdWJtaXQsIGxvYWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJcyB0aGlzIGJ1c3RlZCB3aGVuIHRoZSBSZWFjdCB0ZWFtIGdldHMgcmVhbCB3ZWlyZCBhbmQgY2FsbHMgZWZmZWN0c1xuICAgIC8vIHR3aWNlIG9uIG1vdW50PyAgV2UgcmVhbGx5IGp1c3QgbmVlZCB0byBnYXJiYWdlIGNvbGxlY3QgaGVyZSB3aGVuIHRoaXNcbiAgICAvLyBmZXRjaGVyIGlzIG5vIGxvbmdlciBhcm91bmQuXG4gICAgcmV0dXJuICgpID0+IHRyYW5zaXRpb25NYW5hZ2VyLmRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBrZXldKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHtcbiAgICB0cmFuc2l0aW9uTWFuYWdlclxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IHtcbiAgICBmZXRjaGVyc1xuICB9ID0gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgcmV0dXJuIFsuLi5mZXRjaGVycy52YWx1ZXMoKV07XG59XG5mdW5jdGlvbiBMaXZlUmVsb2FkKHtcbiAgcG9ydCA9IDgwMDJcbn0pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIpIHJldHVybiBudWxsO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbiAgICAgICAgICBsZXQgd3MgPSBuZXcgV2ViU29ja2V0KFwid3M6Ly9sb2NhbGhvc3Q6JHtwb3J0fS9zb2NrZXRcIik7XG4gICAgICAgICAgd3Mub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJMT0dcIikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcIlJFTE9BRFwiKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXHVEODNEXHVEQ0JGIFJlbG9hZGluZyB3aW5kb3cgLi4uXCIpO1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3cy5vbmVycm9yID0gZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZW1peCBkZXYgYXNzZXQgc2VydmVyIHdlYiBzb2NrZXQgZXJyb3I6XCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfTtcbiAgICAgIGBcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VDb21wb3NlZFJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgZm9yIChsZXQgcmVmIG9mIHJlZnMpIHtcbiAgICAgIGlmIChyZWYgPT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG5cbiAgfSwgcmVmcyk7XG59XG5cbmV4cG9ydCB7IEZvcm0sIEZvcm1JbXBsLCBMaW5rLCBMaW5rcywgTGl2ZVJlbG9hZCwgTWV0YSwgTmF2TGluaywgUHJlZmV0Y2hQYWdlTGlua3MsIFJlbWl4RW50cnksIFJlbWl4Um91dGUsIFNjcmlwdHMsIGNvbXBvc2VFdmVudEhhbmRsZXJzLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMb2FkZXJEYXRhLCB1c2VNYXRjaGVzLCB1c2VTdWJtaXQsIHVzZVN1Ym1pdEltcGwsIHVzZVRyYW5zaXRpb24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCB7IF9leHRlbmRzIGFzIGV4dGVuZHMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG5jbGFzcyBSZW1peEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdF9fZGVmYXVsdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsXG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb25cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvclxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIC8vIFdoZW4gd2UgZ2V0IGludG8gYW4gZXJyb3Igc3RhdGUsIHRoZSB1c2VyIHdpbGwgbGlrZWx5IGNsaWNrIFwiYmFja1wiIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBhZ2UgdGhhdCBkaWRuJ3QgaGF2ZSBhbiBlcnJvci4gQmVjYXVzZSB0aGlzIHdyYXBzIHRoZSBlbnRpcmVcbiAgICAvLyBhcHBsaWNhdGlvbiAoZXZlbiB0aGUgSFRNTCEpIHRoYXQgd2lsbCBoYXZlIG5vIGVmZmVjdC0tdGhlIGVycm9yIHBhZ2VcbiAgICAvLyBjb250aW51ZXMgdG8gZGlzcGxheS4gVGhpcyBnaXZlcyB1cyBhIG1lY2hhbmlzbSB0byByZWNvdmVyIGZyb20gdGhlIGVycm9yXG4gICAgLy8gd2hlbiB0aGUgbG9jYXRpb24gY2hhbmdlcy5cbiAgICAvL1xuICAgIC8vIFdoZXRoZXIgd2UncmUgaW4gYW4gZXJyb3Igc3RhdGUgb3Igbm90LCB3ZSB1cGRhdGUgdGhlIGxvY2F0aW9uIGluIHN0YXRlXG4gICAgLy8gc28gdGhhdCB3aGVuIHdlIGFyZSBpbiBhbiBlcnJvciBzdGF0ZSwgaXQgZ2V0cyByZXNldCB3aGVuIGEgbmV3IGxvY2F0aW9uXG4gICAgLy8gY29tZXMgaW4gYW5kIHRoZSB1c2VyIHJlY292ZXJzIGZyb20gdGhlIGVycm9yLlxuICAgIGlmIChzdGF0ZS5sb2NhdGlvbiAhPT0gcHJvcHMubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvciB8fCBudWxsLFxuICAgICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb25cbiAgICAgIH07XG4gICAgfSAvLyBJZiB3ZSdyZSBub3QgY2hhbmdpbmcgbG9jYXRpb25zLCBwcmVzZXJ2ZSB0aGUgbG9jYXRpb24gYnV0IHN0aWxsIHN1cmZhY2VcbiAgICAvLyBhbnkgbmV3IGVycm9ycyB0aGF0IG1heSBjb21lIHRocm91Z2guIFdlIHJldGFpbiB0aGUgZXhpc3RpbmcgZXJyb3IsIHdlIGRvXG4gICAgLy8gdGhpcyBiZWNhdXNlIHRoZSBlcnJvciBwcm92aWRlZCBmcm9tIHRoZSBhcHAgc3RhdGUgbWF5IGJlIGNsZWFyZWQgd2l0aG91dFxuICAgIC8vIHRoZSBsb2NhdGlvbiBjaGFuZ2luZy5cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvciB8fCBzdGF0ZS5lcnJvcixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvblxuICAgIH07XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudCh0aGlzLnByb3BzLmNvbXBvbmVudCwge1xuICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfVxuXG59XG4vKipcbiAqIFdoZW4gYXBwJ3MgZG9uJ3QgcHJvdmlkZSBhIHJvb3QgbGV2ZWwgRXJyb3JCb3VuZGFyeSwgd2UgZGVmYXVsdCB0byB0aGlzLlxuICovXG5cbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5KHtcbiAgZXJyb3Jcbn0pIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwge1xuICAgIGxhbmc6IFwiZW5cIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBcIkFwcGxpY2F0aW9uIEVycm9yIVwiKSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1haW5cIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLFxuICAgICAgcGFkZGluZzogXCIycmVtXCJcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250U2l6ZTogXCIyNHB4XCJcbiAgICB9XG4gIH0sIFwiQXBwbGljYXRpb24gRXJyb3JcIiksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogXCIycmVtXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcImhzbGEoMTAsIDUwJSwgNTAlLCAwLjEpXCIsXG4gICAgICBjb2xvcjogXCJyZWRcIixcbiAgICAgIG92ZXJmbG93OiBcImF1dG9cIlxuICAgIH1cbiAgfSwgZXJyb3Iuc3RhY2spKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJcdUQ4M0RcdURDQkYgSGV5IGRldmVsb3Blclx1RDgzRFx1REM0Qi4gWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMgdGhhbiB0aGlzLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vZ3VpZGVzL2Vycm9ycyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYFxuICAgIH1cbiAgfSkpKTtcbn1cbmxldCBSZW1peENhdGNoQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5mdW5jdGlvbiB1c2VDYXRjaCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUmVtaXhDYXRjaENvbnRleHQpO1xufVxuZnVuY3Rpb24gUmVtaXhDYXRjaEJvdW5kYXJ5KHtcbiAgY2F0Y2g6IGNhdGNoVmFsLFxuICBjb21wb25lbnQ6IENvbXBvbmVudCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgaWYgKGNhdGNoVmFsKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlbWl4Q2F0Y2hDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY2F0Y2hWYWxcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBXaGVuIGFwcCdzIGRvbid0IHByb3ZpZGUgYSByb290IGxldmVsIENhdGNoQm91bmRhcnksIHdlIGRlZmF1bHQgdG8gdGhpcy5cbiAqL1xuXG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSgpIHtcbiAgbGV0IGNhdWdodCA9IHVzZUNhdGNoKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwge1xuICAgIGxhbmc6IFwiZW5cIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBcIlVuaGFuZGxlZCBUaHJvd24gUmVzcG9uc2UhXCIpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLFxuICAgICAgcGFkZGluZzogXCIycmVtXCJcbiAgICB9XG4gIH0sIGNhdWdodC5zdGF0dXMsIFwiIFwiLCBjYXVnaHQuc3RhdHVzVGV4dCksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiXHVEODNEXHVEQ0JGIEhleSBkZXZlbG9wZXJcdUQ4M0RcdURDNEIuIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggd2hlbiB5b3VyIGFwcCB0aHJvd3MgNDA0cyAoYW5kIG90aGVyIHJlc3BvbnNlcykgdGhhbiB0aGlzLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vZ3VpZGVzL25vdC1mb3VuZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYFxuICAgIH1cbiAgfSkpKTtcbn1cblxuZXhwb3J0IHsgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peEVycm9yQm91bmRhcnksIFJlbWl4Um9vdERlZmF1bHRDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgdXNlQ2F0Y2ggfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBpbnZhcmlhbnQgYXMgZGVmYXVsdCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4xLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfSBmcm9tICcuL3JvdXRlTW9kdWxlcy5qcyc7XG5cbi8vIGltcG9ydCB0eXBlIHsgTG9jYXRpb24gfSBmcm9tIFwiaGlzdG9yeVwiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYDxsaW5rPmAgZWxlbWVudC5cbiAqXG4gKiBXSEFUV0cgU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWxpbmstZWxlbWVudFxuICovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogR2V0cyBhbGwgdGhlIGxpbmtzIGZvciBhIHNldCBvZiBtYXRjaGVzLiBUaGUgbW9kdWxlcyBhcmUgYXNzdW1lZCB0byBoYXZlIGJlZW5cbiAqIGxvYWRlZCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBnZXRMaW5rc0Zvck1hdGNoZXMobWF0Y2hlcywgcm91dGVNb2R1bGVzLCBtYW5pZmVzdCkge1xuICBsZXQgZGVzY3JpcHRvcnMgPSBtYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgdmFyIF9tb2R1bGUkbGlua3M7XG5cbiAgICBsZXQgbW9kdWxlID0gcm91dGVNb2R1bGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICByZXR1cm4gKChfbW9kdWxlJGxpbmtzID0gbW9kdWxlLmxpbmtzKSA9PT0gbnVsbCB8fCBfbW9kdWxlJGxpbmtzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbW9kdWxlJGxpbmtzLmNhbGwobW9kdWxlKSkgfHwgW107XG4gIH0pLmZsYXQoMSk7XG4gIGxldCBwcmVsb2FkcyA9IGdldEN1cnJlbnRQYWdlTW9kdWxlUHJlbG9hZEhyZWZzKG1hdGNoZXMsIG1hbmlmZXN0KTtcbiAgcmV0dXJuIGRlZHVwZShkZXNjcmlwdG9ycywgcHJlbG9hZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlTW9kdWxlKSB7XG4gIGlmICghcm91dGVNb2R1bGUubGlua3MpIHJldHVybjtcbiAgbGV0IGRlc2NyaXB0b3JzID0gcm91dGVNb2R1bGUubGlua3MoKTtcbiAgaWYgKCFkZXNjcmlwdG9ycykgcmV0dXJuO1xuICBsZXQgc3R5bGVMaW5rcyA9IFtdO1xuXG4gIGZvciAobGV0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICBpZiAoIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IucmVsID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgc3R5bGVMaW5rcy5wdXNoKHsgLi4uZGVzY3JpcHRvcixcbiAgICAgICAgcmVsOiBcInByZWxvYWRcIixcbiAgICAgICAgYXM6IFwic3R5bGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIGRvbid0IGJsb2NrIGZvciBub24tbWF0Y2hpbmcgbWVkaWEgcXVlcmllc1xuXG5cbiAgbGV0IG1hdGNoaW5nTGlua3MgPSBzdHlsZUxpbmtzLmZpbHRlcihsaW5rID0+ICFsaW5rLm1lZGlhIHx8IHdpbmRvdy5tYXRjaE1lZGlhKGxpbmsubWVkaWEpLm1hdGNoZXMpO1xuICBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGluZ0xpbmtzLm1hcChwcmVmZXRjaFN0eWxlTGluaykpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFN0eWxlTGluayhkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgIE9iamVjdC5hc3NpZ24obGluaywgZGVzY3JpcHRvcik7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVMaW5rKCkge1xuICAgICAgLy8gaWYgYSBuYXZpZ2F0aW9uIGludGVycnVwdHMgdGhpcyBwcmVmZXRjaCBSZWFjdCB3aWxsIHVwZGF0ZSB0aGUgPGhlYWQ+XG4gICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBsaW5rIHdlIHB1dCBpbiB0aGVyZSBtYW51YWxseSwgc28gd2UgY2hlY2sgaWYgaXQncyBzdGlsbFxuICAgICAgLy8gdGhlcmUgYmVmb3JlIHRyeWluZyB0byByZW1vdmUgaXRcbiAgICAgIGlmIChkb2N1bWVudC5oZWFkLmNvbnRhaW5zKGxpbmspKSB7XG4gICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluay5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIGxpbmsub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHJlbW92ZUxpbmsoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgfSk7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuZnVuY3Rpb24gaXNQYWdlTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnBhZ2UgPT09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc0h0bWxMaW5rRGVzY3JpcHRvcihvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QucmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaHJlZiA9PT0gXCJzdHJpbmdcIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgbGlua3MgPSBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGVzLm1hcChhc3luYyBtYXRjaCA9PiB7XG4gICAgbGV0IG1vZCA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgICByZXR1cm4gbW9kLmxpbmtzID8gbW9kLmxpbmtzKCkgOiBbXTtcbiAgfSkpO1xuICByZXR1cm4gbGlua3MuZmxhdCgxKS5maWx0ZXIoaXNIdG1sTGlua0Rlc2NyaXB0b3IpLmZpbHRlcihsaW5rID0+IGxpbmsucmVsID09PSBcInN0eWxlc2hlZXRcIiB8fCBsaW5rLnJlbCA9PT0gXCJwcmVsb2FkXCIpLm1hcCgoe1xuICAgIHJlbCxcbiAgICAuLi5hdHRyc1xuICB9KSA9PiB7XG4gICAgaWYgKHJlbCA9PT0gXCJwcmVsb2FkXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbDogXCJwcmVmZXRjaFwiLFxuICAgICAgICAuLi5hdHRyc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVsOiBcInByZWZldGNoXCIsXG4gICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgLi4uYXR0cnNcbiAgICB9O1xuICB9KTtcbn0gLy8gVGhpcyBpcyByaWRpY3Vsb3VzbHkgaWRlbnRpY2FsIHRvIHRyYW5zaXRpb24udHMgYGZpbHRlck1hdGNoZXNUb0xvYWRgXG5cbmZ1bmN0aW9uIGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgY3VycmVudE1hdGNoZXMsIGxvY2F0aW9uLCBtb2RlKSB7XG4gIGxldCBwYXRoID0gcGFyc2VQYXRoUGF0Y2gocGFnZSk7XG5cbiAgbGV0IGlzTmV3ID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghY3VycmVudE1hdGNoZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5pZDtcbiAgfTtcblxuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX2N1cnJlbnRNYXRjaGVzJGluZGV4O1xuXG4gICAgcmV0dXJuICgvLyBwYXJhbSBjaGFuZ2UsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgICAgY3VycmVudE1hdGNoZXNbaW5kZXhdLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fCAoKF9jdXJyZW50TWF0Y2hlcyRpbmRleCA9IGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoKSA9PT0gbnVsbCB8fCBfY3VycmVudE1hdGNoZXMkaW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jdXJyZW50TWF0Y2hlcyRpbmRleC5lbmRzV2l0aChcIipcIikpICYmIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTsgLy8gTk9URToga2VlcCB0aGlzIG1vc3RseSB1cC10by1kYXRlIHcvIHRoZSB0cmFuc2l0aW9uIGRhdGEgZGlmZiwgYnV0IHRoaXNcbiAgLy8gdmVyc2lvbiBkb2Vzbid0IGNhcmUgYWJvdXQgc3VibWlzc2lvbnNcblxuXG4gIGxldCBuZXdNYXRjaGVzID0gbW9kZSA9PT0gXCJkYXRhXCIgJiYgbG9jYXRpb24uc2VhcmNoICE9PSBwYXRoLnNlYXJjaCA/IC8vIHRoaXMgaXMgcmVhbGx5IHNpbWlsYXIgdG8gc3R1ZmYgaW4gdHJhbnNpdGlvbi50cywgbWF5YmUgc29tZWJvZHkgc21hcnRlclxuICAvLyB0aGFuIG1lIChvciBpbiBsZXNzIG9mIGEgaHVycnkpIGNhbiBzaGFyZSBzb21lIG9mIGl0LiBZb3UncmUgdGhlIGJlc3QuXG4gIG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQpIHtcbiAgICAgIHJldHVybiBtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQoe1xuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgcHJldlVybDogbmV3IFVSTChsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gsIHdpbmRvdy5vcmlnaW4pLFxuICAgICAgICB1cmw6IG5ldyBVUkwocGFnZSwgd2luZG93Lm9yaWdpbilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KSA6IG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmhhc0xvYWRlciAmJiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpO1xuICB9KTtcbiAgcmV0dXJuIG5ld01hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREYXRhTGlua0hyZWZzKHBhZ2UsIG1hdGNoZXMsIG1hbmlmZXN0KSB7XG4gIGxldCBwYXRoID0gcGFyc2VQYXRoUGF0Y2gocGFnZSk7XG4gIHJldHVybiBkZWR1cGVIcmVmcyhtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdLmhhc0xvYWRlcikubWFwKG1hdGNoID0+IHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2hcbiAgICB9ID0gcGF0aDtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzZWFyY2gpO1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJfZGF0YVwiLCBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgcmV0dXJuIGAke3BhdGhuYW1lfT8ke3NlYXJjaFBhcmFtc31gO1xuICB9KSk7XG59XG5mdW5jdGlvbiBnZXRNb2R1bGVMaW5rSHJlZnMobWF0Y2hlcywgbWFuaWZlc3RQYXRjaCkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMobWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0UGF0Y2gucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBsZXQgaHJlZnMgPSBbcm91dGUubW9kdWxlXTtcblxuICAgIGlmIChyb3V0ZS5pbXBvcnRzKSB7XG4gICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5pbXBvcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZnM7XG4gIH0pLmZsYXQoMSkpO1xufSAvLyBUaGUgYDxTY3JpcHQ+YCB3aWxsIHJlbmRlciByZWw9bW9kdWxlcHJlbG9hZCBmb3IgdGhlIGN1cnJlbnQgcGFnZSwgd2UgZG9uJ3Rcbi8vIG5lZWQgdG8gaW5jbHVkZSB0aGVtIGluIGEgcGFnZSBwcmVmZXRjaCwgdGhpcyBnaXZlcyB1cyB0aGUgbGlzdCB0byByZW1vdmVcbi8vIHdoaWxlIGRlZHVwaW5nLlxuXG5mdW5jdGlvbiBnZXRDdXJyZW50UGFnZU1vZHVsZVByZWxvYWRIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCkge1xuICByZXR1cm4gZGVkdXBlSHJlZnMobWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG5cbiAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaW1wb3J0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWZzO1xuICB9KS5mbGF0KDEpKTtcbn1cblxuZnVuY3Rpb24gZGVkdXBlSHJlZnMoaHJlZnMpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGhyZWZzKV07XG59XG5cbmZ1bmN0aW9uIGRlZHVwZShkZXNjcmlwdG9ycywgcHJlbG9hZHMpIHtcbiAgbGV0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IHByZWxvYWRzU2V0ID0gbmV3IFNldChwcmVsb2Fkcyk7XG4gIHJldHVybiBkZXNjcmlwdG9ycy5yZWR1Y2UoKGRlZHVwZWQsIGRlc2NyaXB0b3IpID0+IHtcbiAgICBsZXQgYWxyZWFkeU1vZHVsZVByZWxvYWQgPSAhaXNQYWdlTGlua0Rlc2NyaXB0b3IoZGVzY3JpcHRvcikgJiYgZGVzY3JpcHRvci5hcyA9PT0gXCJzY3JpcHRcIiAmJiBkZXNjcmlwdG9yLmhyZWYgJiYgcHJlbG9hZHNTZXQuaGFzKGRlc2NyaXB0b3IuaHJlZik7XG5cbiAgICBpZiAoYWxyZWFkeU1vZHVsZVByZWxvYWQpIHtcbiAgICAgIHJldHVybiBkZWR1cGVkO1xuICAgIH1cblxuICAgIGxldCBzdHIgPSBKU09OLnN0cmluZ2lmeShkZXNjcmlwdG9yKTtcblxuICAgIGlmICghc2V0LmhhcyhzdHIpKSB7XG4gICAgICBzZXQuYWRkKHN0cik7XG4gICAgICBkZWR1cGVkLnB1c2goZGVzY3JpcHRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZHVwZWQ7XG4gIH0sIFtdKTtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L2lzc3Vlcy84OTdcblxuZnVuY3Rpb24gcGFyc2VQYXRoUGF0Y2goaHJlZikge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aChocmVmKTtcbiAgaWYgKHBhdGguc2VhcmNoID09PSB1bmRlZmluZWQpIHBhdGguc2VhcmNoID0gXCJcIjtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCB7IGRlZHVwZSwgZ2V0RGF0YUxpbmtIcmVmcywgZ2V0TGlua3NGb3JNYXRjaGVzLCBnZXRNb2R1bGVMaW5rSHJlZnMsIGdldE5ld01hdGNoZXNGb3JMaW5rcywgZ2V0U3R5bGVzaGVldFByZWZldGNoTGlua3MsIGlzSHRtbExpbmtEZXNjcmlwdG9yLCBpc1BhZ2VMaW5rRGVzY3JpcHRvciwgcHJlZmV0Y2hTdHlsZUxpbmtzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjEuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vLyBUT0RPOiBpbXBvcnQvZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyLWRvbVxuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgcmVuZGVyZWQgd2hlbiB0aGUgc2VydmVyIHRocm93cyBhIFJlc3BvbnNlLlxuICovXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIG9uIGEgcm91dGUuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBgPGxpbms+YCB0YWdzIHRvIGJlIGluc2VydGVkIGludG8gdGhlIGA8aGVhZD5gIG9mXG4gKiB0aGUgZG9jdW1lbnQgb24gcm91dGUgdHJhbnNpdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgb2YgbmFtZSArIGNvbnRlbnQgcGFpcnMgdG8gdXNlIGZvclxuICogYDxtZXRhPmAgdGFncyBmb3IgYSByb3V0ZS4gVGhlc2UgdGFncyB3aWxsIGJlIG1lcmdlZCB3aXRoIChhbmQgdGFrZVxuICogcHJlY2VkZW5jZSBvdmVyKSB0YWdzIGZyb20gcGFyZW50IHJvdXRlcy5cbiAqL1xuXG4vKipcbiAqIEEgbmFtZS9jb250ZW50IHBhaXIgdXNlZCB0byByZW5kZXIgYDxtZXRhPmAgdGFncyBpbiBhIG1ldGEgZnVuY3Rpb24gZm9yIGFcbiAqIHJvdXRlLiBUaGUgdmFsdWUgY2FuIGJlIGVpdGhlciBhIHN0cmluZywgd2hpY2ggd2lsbCByZW5kZXIgYSBzaW5nbGUgYDxtZXRhPmBcbiAqIHRhZywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgcmVuZGVyIG11bHRpcGxlIHRhZ3Mgd2l0aCB0aGUgc2FtZVxuICogYG5hbWVgIGF0dHJpYnV0ZS5cbiAqL1xuXG4vKipcbiAqIER1cmluZyBjbGllbnQgc2lkZSB0cmFuc2l0aW9ucyBSZW1peCB3aWxsIG9wdGltaXplIHJlbG9hZGluZyBvZiByb3V0ZXMgdGhhdFxuICogYXJlIGN1cnJlbnRseSBvbiB0aGUgcGFnZSBieSBhdm9pZGluZyBsb2FkaW5nIHJvdXRlcyB0aGF0IGFyZW4ndCBjaGFuZ2luZy5cbiAqIEhvd2V2ZXIsIGluIHNvbWUgY2FzZXMsIGxpa2UgZm9ybSBzdWJtaXNzaW9ucyBvciBzZWFyY2ggcGFyYW1zIFJlbWl4IGRvZXNuJ3RcbiAqIGtub3cgd2hpY2ggcm91dGVzIG5lZWQgdG8gYmUgcmVsb2FkZWQgc28gaXQgcmVsb2FkcyB0aGVtIGFsbCB0byBiZSBzYWZlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbGV0cyBhcHBzIGZ1cnRoZXIgb3B0aW1pemUgYnkgcmV0dXJuaW5nIGBmYWxzZWAgd2hlbiBSZW1peCBpc1xuICogYWJvdXQgdG8gcmVsb2FkIHRoZSByb3V0ZS4gQSBjb21tb24gY2FzZSBpcyBhIHJvb3QgbG9hZGVyIHdpdGggbm90aGluZyBidXRcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlczogYWZ0ZXIgZm9ybSBzdWJtaXNzaW9ucyB0aGUgcm9vdCBwcm9iYWJseSBkb2Vzbid0IG5lZWRcbiAqIHRvIGJlIHJlbG9hZGVkLlxuICovXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCBmb3IgYSByb3V0ZS5cbiAqL1xuXG4vKipcbiAqIEFuIGFyYml0cmFyeSBvYmplY3QgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYSByb3V0ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICBpZiAocm91dGUuaWQgaW4gcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSBhd2FpdCBpbXBvcnQocm91dGUubW9kdWxlKTtcbiAgICByb3V0ZU1vZHVsZXNDYWNoZVtyb3V0ZS5pZF0gPSByb3V0ZU1vZHVsZTtcbiAgICByZXR1cm4gcm91dGVNb2R1bGU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVXNlciBnb3QgY2F1Z2h0IGluIHRoZSBtaWRkbGUgb2YgYSBkZXBsb3kgYW5kIHRoZSBDRE4gbm8gbG9uZ2VyIGhhcyB0aGVcbiAgICAvLyBhc3NldCB3ZSdyZSB0cnlpbmcgdG8gaW1wb3J0ISBSZWxvYWQgZnJvbSB0aGUgc2VydmVyIGFuZCB0aGUgdXNlclxuICAgIC8vIChzaG91bGQpIGdldCB0aGUgbmV3IG1hbmlmZXN0LS11bmxlc3MgdGhlIGRldmVsb3BlciBwdXJnZWQgdGhlIHN0YXRpY1xuICAgIC8vIGFzc2V0cywgdGhlIG1hbmlmZXN0IHBhdGgsIGJ1dCBub3QgdGhlIGRvY3VtZW50cyBcdUQ4M0RcdURFMkNcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHsvLyBjaGVjayBvdXQgb2YgdGhpcyBob29rIGNhdXNlIHRoZSBESnMgbmV2ZXIgZ29ubmEgcmVbc11vbHZlIHRoaXNcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUh0bWwoaHRtbCkge1xuICByZXR1cm4ge1xuICAgIF9faHRtbDogaHRtbFxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVIdG1sIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjEuMFxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfSBmcm9tICcuL3JvdXRlTW9kdWxlcy5qcyc7XG5pbXBvcnQgeyBmZXRjaERhdGEsIGlzQ2F0Y2hSZXNwb25zZSwgZXh0cmFjdERhdGEsIGlzUmVkaXJlY3RSZXNwb25zZSB9IGZyb20gJy4vZGF0YS5qcyc7XG5pbXBvcnQgeyBDYXRjaFZhbHVlLCBUcmFuc2l0aW9uUmVkaXJlY3QgfSBmcm9tICcuL3RyYW5zaXRpb24uanMnO1xuaW1wb3J0IHsgcHJlZmV0Y2hTdHlsZUxpbmtzIH0gZnJvbSAnLi9saW5rcy5qcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJy4vaW52YXJpYW50LmpzJztcblxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGUoZW50cnlSb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUsIENvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgIGNhc2VTZW5zaXRpdmU6ICEhZW50cnlSb3V0ZS5jYXNlU2Vuc2l0aXZlLFxuICAgIGVsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgaWQ6IGVudHJ5Um91dGUuaWRcbiAgICB9KSxcbiAgICBpZDogZW50cnlSb3V0ZS5pZCxcbiAgICBwYXRoOiBlbnRyeVJvdXRlLnBhdGgsXG4gICAgaW5kZXg6IGVudHJ5Um91dGUuaW5kZXgsXG4gICAgbW9kdWxlOiBlbnRyeVJvdXRlLm1vZHVsZSxcbiAgICBsb2FkZXI6IGNyZWF0ZUxvYWRlcihlbnRyeVJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSksXG4gICAgYWN0aW9uOiBjcmVhdGVBY3Rpb24oZW50cnlSb3V0ZSksXG4gICAgc2hvdWxkUmVsb2FkOiBjcmVhdGVTaG91bGRSZWxvYWQoZW50cnlSb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpLFxuICAgIEVycm9yQm91bmRhcnk6IGVudHJ5Um91dGUuaGFzRXJyb3JCb3VuZGFyeSxcbiAgICBDYXRjaEJvdW5kYXJ5OiBlbnRyeVJvdXRlLmhhc0NhdGNoQm91bmRhcnksXG4gICAgaGFzTG9hZGVyOiBlbnRyeVJvdXRlLmhhc0xvYWRlclxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGVzKHJvdXRlTWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQsIHBhcmVudElkKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyb3V0ZU1hbmlmZXN0KS5maWx0ZXIoa2V5ID0+IHJvdXRlTWFuaWZlc3Rba2V5XS5wYXJlbnRJZCA9PT0gcGFyZW50SWQpLm1hcChrZXkgPT4ge1xuICAgIGxldCByb3V0ZSA9IGNyZWF0ZUNsaWVudFJvdXRlKHJvdXRlTWFuaWZlc3Rba2V5XSwgcm91dGVNb2R1bGVzQ2FjaGUsIENvbXBvbmVudCk7XG4gICAgbGV0IGNoaWxkcmVuID0gY3JlYXRlQ2xpZW50Um91dGVzKHJvdXRlTWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQsIHJvdXRlLmlkKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkgcm91dGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICByZXR1cm4gcm91dGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaG91bGRSZWxvYWQocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgc2hvdWxkUmVsb2FkID0gYXJnID0+IHtcbiAgICBsZXQgbW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlLmlkXTtcbiAgICBpbnZhcmlhbnQobW9kdWxlLCBgRXhwZWN0ZWQgcm91dGUgbW9kdWxlIHRvIGJlIGxvYWRlZCBmb3IgJHtyb3V0ZS5pZH1gKTtcblxuICAgIGlmIChtb2R1bGUudW5zdGFibGVfc2hvdWxkUmVsb2FkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLnVuc3RhYmxlX3Nob3VsZFJlbG9hZChhcmcpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBzaG91bGRSZWxvYWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICBhd2FpdCBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGVNb2R1bGUpO1xuICByZXR1cm4gcm91dGVNb2R1bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvYWRlcihyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCBsb2FkZXIgPSBhc3luYyAoe1xuICAgIHVybCxcbiAgICBzaWduYWwsXG4gICAgc3VibWlzc2lvblxuICB9KSA9PiB7XG4gICAgaWYgKHJvdXRlLmhhc0xvYWRlcikge1xuICAgICAgbGV0IFtyZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2ZldGNoRGF0YSh1cmwsIHJvdXRlLmlkLCBzaWduYWwsIHN1Ym1pc3Npb24pLCBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKV0pO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyByZXN1bHQ7XG4gICAgICBsZXQgcmVkaXJlY3QgPSBhd2FpdCBjaGVja1JlZGlyZWN0KHJlc3VsdCk7XG4gICAgICBpZiAocmVkaXJlY3QpIHJldHVybiByZWRpcmVjdDtcblxuICAgICAgaWYgKGlzQ2F0Y2hSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBDYXRjaFZhbHVlKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBhd2FpdCBleHRyYWN0RGF0YShyZXN1bHQuY2xvbmUoKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0cmFjdERhdGEocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsb2FkZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihyb3V0ZSkge1xuICBpZiAoIXJvdXRlLmhhc0FjdGlvbikgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBsZXQgYWN0aW9uID0gYXN5bmMgKHtcbiAgICB1cmwsXG4gICAgc2lnbmFsLFxuICAgIHN1Ym1pc3Npb25cbiAgfSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBmZXRjaERhdGEodXJsLCByb3V0ZS5pZCwgc2lnbmFsLCBzdWJtaXNzaW9uKTtcblxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgcmVzdWx0O1xuICAgIH1cblxuICAgIGxldCByZWRpcmVjdCA9IGF3YWl0IGNoZWNrUmVkaXJlY3QocmVzdWx0KTtcbiAgICBpZiAocmVkaXJlY3QpIHJldHVybiByZWRpcmVjdDtcblxuICAgIGlmIChpc0NhdGNoUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IENhdGNoVmFsdWUocmVzdWx0LnN0YXR1cywgcmVzdWx0LnN0YXR1c1RleHQsIGF3YWl0IGV4dHJhY3REYXRhKHJlc3VsdC5jbG9uZSgpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dHJhY3REYXRhKHJlc3VsdCk7XG4gIH07XG5cbiAgcmV0dXJuIGFjdGlvbjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2hlY2tSZWRpcmVjdChyZXNwb25zZSkge1xuICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG5cbiAgICBpZiAodXJsLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh1cmwuaHJlZik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uUmVkaXJlY3QodXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNsaWVudFJvdXRlLCBjcmVhdGVDbGllbnRSb3V0ZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuXG5mdW5jdGlvbiBpc0NhdGNoUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LUNhdGNoXCIpICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LUVycm9yXCIpICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UgJiYgcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJlZGlyZWN0XCIpICE9IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaERhdGEodXJsLCByb3V0ZUlkLCBzaWduYWwsIHN1Ym1pc3Npb24pIHtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJfZGF0YVwiLCByb3V0ZUlkKTtcbiAgbGV0IGluaXQgPSBzdWJtaXNzaW9uID8gZ2V0QWN0aW9uSW5pdChzdWJtaXNzaW9uLCBzaWduYWwpIDoge1xuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgc2lnbmFsXG4gIH07XG4gIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC5ocmVmLCBpbml0KTtcblxuICBpZiAoaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgIGxldCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgIGVycm9yLnN0YWNrID0gZGF0YS5zdGFjaztcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwb25zZSkge1xuICAvLyBUaGlzIHNhbWUgYWxnb3JpdGhtIGlzIHVzZWQgb24gdGhlIHNlcnZlciB0byBpbnRlcnByZXQgbG9hZFxuICAvLyByZXN1bHRzIHdoZW4gd2UgcmVuZGVyIHRoZSBIVE1MIHBhZ2UuXG4gIGxldCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpO1xuXG4gIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25Jbml0KHN1Ym1pc3Npb24sIHNpZ25hbCkge1xuICBsZXQge1xuICAgIGVuY1R5cGUsXG4gICAgbWV0aG9kLFxuICAgIGZvcm1EYXRhXG4gIH0gPSBzdWJtaXNzaW9uO1xuICBsZXQgaGVhZGVycyA9IHVuZGVmaW5lZDtcbiAgbGV0IGJvZHkgPSBmb3JtRGF0YTtcblxuICBpZiAoZW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikge1xuICAgIGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cbiAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEpIHtcbiAgICAgIGludmFyaWFudCh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIsIGBGaWxlIGlucHV0cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGVuY1R5cGUgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgcGxlYXNlIHVzZSBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiBpbnN0ZWFkLmApO1xuICAgICAgYm9keS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IGVuY1R5cGVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2QsXG4gICAgYm9keSxcbiAgICBzaWduYWwsXG4gICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICBoZWFkZXJzXG4gIH07XG59XG5cbmV4cG9ydCB7IGV4dHJhY3REYXRhLCBmZXRjaERhdGEsIGlzQ2F0Y2hSZXNwb25zZSwgaXNFcnJvclJlc3BvbnNlLCBpc1JlZGlyZWN0UmVzcG9uc2UgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuL2ludmFyaWFudC5qcyc7XG5cbmNsYXNzIENhdGNoVmFsdWUge1xuICBjb25zdHJ1Y3RvcihzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gaXNBY3Rpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pIHtcbiAgcmV0dXJuIFtcIlBPU1RcIiwgXCJQVVRcIiwgXCJQQVRDSFwiLCBcIkRFTEVURVwiXS5pbmNsdWRlcyhzdWJtaXNzaW9uLm1ldGhvZCk7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyU3VibWlzc2lvbihzdWJtaXNzaW9uKSB7XG4gIHJldHVybiBzdWJtaXNzaW9uLm1ldGhvZCA9PT0gXCJHRVRcIjtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBCb29sZWFuKGxvY2F0aW9uLnN0YXRlKSAmJiBsb2NhdGlvbi5zdGF0ZS5pc1JlZGlyZWN0O1xufVxuXG5mdW5jdGlvbiBpc0xvYWRlclJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJsb2FkZXJcIjtcbn1cblxuZnVuY3Rpb24gaXNBY3Rpb25SZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pICYmIGxvY2F0aW9uLnN0YXRlLnR5cGUgPT09IFwiYWN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzRmV0Y2hBY3Rpb25SZWRpcmVjdChsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImZldGNoQWN0aW9uXCI7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyU3VibWlzc2lvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJsb2FkZXJTdWJtaXNzaW9uXCI7XG59XG5cbmNsYXNzIFRyYW5zaXRpb25SZWRpcmVjdCB7XG4gIGNvbnN0cnVjdG9yKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5sb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IGxvY2F0aW9uIDogbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG4gIH1cblxufVxuY29uc3QgSURMRV9UUkFOU0lUSU9OID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IHVuZGVmaW5lZCxcbiAgdHlwZTogXCJpZGxlXCJcbn07XG5jb25zdCBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgdHlwZTogXCJpbml0XCIsXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG59O1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoaW5pdCkge1xuICBsZXQge1xuICAgIHJvdXRlc1xuICB9ID0gaW5pdDtcbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjtcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICBsZXQgbmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuICBsZXQgZmV0Y2hSZWxvYWRJZHMgPSBuZXcgTWFwKCk7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hDbGllbnRSb3V0ZXMocm91dGVzLCBpbml0LmxvY2F0aW9uKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBhbGxvdyB0aGUgQ2F0Y2hCb3VuZGFyeSB0byB0YWtlIG92ZXJcbiAgICBtYXRjaGVzID0gW3tcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBwYXRobmFtZTogXCJcIixcbiAgICAgIHJvdXRlOiByb3V0ZXNbMF1cbiAgICB9XTtcbiAgfVxuXG4gIGxldCBzdGF0ZSA9IHtcbiAgICBsb2NhdGlvbjogaW5pdC5sb2NhdGlvbixcbiAgICBsb2FkZXJEYXRhOiBpbml0LmxvYWRlckRhdGEgfHwge30sXG4gICAgYWN0aW9uRGF0YTogaW5pdC5hY3Rpb25EYXRhLFxuICAgIGNhdGNoOiBpbml0LmNhdGNoLFxuICAgIGVycm9yOiBpbml0LmVycm9yLFxuICAgIGNhdGNoQm91bmRhcnlJZDogaW5pdC5jYXRjaEJvdW5kYXJ5SWQgfHwgbnVsbCxcbiAgICBlcnJvckJvdW5kYXJ5SWQ6IGluaXQuZXJyb3JCb3VuZGFyeUlkIHx8IG51bGwsXG4gICAgbWF0Y2hlcyxcbiAgICBuZXh0TWF0Y2hlczogdW5kZWZpbmVkLFxuICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpXG4gIH07XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHVwZGF0ZXMpIHtcbiAgICBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB1cGRhdGVzKTtcbiAgICBpbml0Lm9uQ2hhbmdlKHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2VuZChldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIm5hdmlnYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgbWF0Y2hlcyA9IFt7XG4gICAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICByb3V0ZTogcm91dGVzWzBdXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZU5vdEZvdW5kTmF2aWdhdGlvbihsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghc3VibWlzc2lvbiAmJiBpc0hhc2hDaGFuZ2VPbmx5KGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlSGFzaENoYW5nZShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBiYWNrL2ZvcndhcmQgYnV0dG9uLCB0cmVhdCBhbGwgYXMgbm9ybWFsIG5hdmlnYXRpb25cbiAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09IEFjdGlvbi5Qb3ApIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWQobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwicG9zdCB8IHB1dCB8IGRlbGV0ZSB8IHBhdGNoXCI+XG4gICAgICAgICAgZWxzZSBpZiAoc3VibWlzc2lvbiAmJiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUFjdGlvblN1Ym1pc3Npb25OYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIDxGb3JtIG1ldGhvZD1cImdldFwiLz5cbiAgICAgICAgICBlbHNlIGlmIChzdWJtaXNzaW9uICYmIGlzTG9hZGVyU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyU3VibWlzc2lvbk5hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gYWN0aW9uPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzQWN0aW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIDxGb3JtIG1ldGhvZD1cImdldFwiPiAtLT4gbG9hZGVyPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzTG9hZGVyU3VibWlzc2lvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gbG9hZGVyPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzTG9hZGVyUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlclJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIHVzZVN1Ym1pc3Npb24oKT0+cmVkaXJlY3RcbiAgICAgICAgICBlbHNlIGlmIChpc0ZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIDxMaW5rPiwgbmF2aWdhdGUoKVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmF2aWdhdGlvbkxvYWRJZCA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJmZXRjaGVyXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc3VibWlzc2lvbixcbiAgICAgICAgICAgIGhyZWZcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGhyZWYpO1xuICAgICAgICAgIGludmFyaWFudChtYXRjaGVzLCBcIk5vIG1hdGNoZXMgZm91bmRcIik7XG4gICAgICAgICAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG4gICAgICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIGFib3J0RmV0Y2hlcihrZXkpO1xuXG4gICAgICAgICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNBY3Rpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVBY3Rpb25GZXRjaFN1Ym1pc3Npb24oa2V5LCBzdWJtaXNzaW9uLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdWJtaXNzaW9uICYmIGlzTG9hZGVyU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyRmV0Y2hTdWJtaXNzaW9uKGhyZWYsIGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJGZXRjaChocmVmLCBrZXksIG1hdGNoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIGV2ZW50IHR5cGU6ICR7ZXZlbnQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG5cbiAgICBmb3IgKGxldCBbLCBjb250cm9sbGVyXSBvZiBmZXRjaENvbnRyb2xsZXJzKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uRmV0Y2hTdWJtaXNzaW9uKGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpIHtcbiAgICBsZXQgY3VycmVudEZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uU3VibWlzc2lvblwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGRhdGE6IChjdXJyZW50RmV0Y2hlciA9PT0gbnVsbCB8fCBjdXJyZW50RmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZldGNoZXIuZGF0YSkgfHwgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBjb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbEFjdGlvbihzdWJtaXNzaW9uLCBtYXRjaCwgY29udHJvbGxlci5zaWduYWwpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJmZXRjaEFjdGlvblwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1heWJlQmFpbE9uRXJyb3IobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBtYXliZUJhaWxPbkNhdGNoKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbG9hZEZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblJlbG9hZFwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvblxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCA9IGlzRXJyb3JSZXN1bHQocmVzdWx0KSA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCA9IGlzQ2F0Y2hSZXN1bHQocmVzdWx0KSA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbWF0Y2hlc1RvTG9hZCA9IHN0YXRlLm5leHRNYXRjaGVzIHx8IHN0YXRlLm1hdGNoZXM7XG4gICAgbGV0IGhyZWZUb0xvYWQgPSBjcmVhdGVIcmVmKHN0YXRlLnRyYW5zaXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb24pO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbExvYWRlcnMoc3RhdGUsIGNyZWF0ZVVybChocmVmVG9Mb2FkKSwgbWF0Y2hlc1RvTG9hZCwgY29udHJvbGxlci5zaWduYWwsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQsIG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQsIHN1Ym1pc3Npb24sIG1hdGNoLnJvdXRlLmlkLCBsb2FkRmV0Y2hlcik7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuXG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZWRpcmVjdC5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IFtlcnJvciwgZXJyb3JCb3VuZGFyeUlkXSA9IGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgc3RhdGUubWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IFtjYXRjaFZhbCwgY2F0Y2hCb3VuZGFyeUlkXSA9IGF3YWl0IGZpbmRDYXRjaEFuZEJvdW5kYXJ5SWQocmVzdWx0cywgc3RhdGUubWF0Y2hlcywgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCk7XG4gICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgdHlwZTogXCJkb25lXCIsXG4gICAgICBkYXRhOiByZXN1bHQudmFsdWUsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICBsZXQgYWJvcnRlZEtleXMgPSBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuXG4gICAgaWYgKGFib3J0ZWRLZXlzKSB7XG4gICAgICBtYXJrRmV0Y2hlcnNEb25lKGFib3J0ZWRLZXlzKTtcbiAgICB9XG5cbiAgICBsZXQgeWVldGVkTmF2aWdhdGlvbiA9IHllZXRTdGFsZU5hdmlnYXRpb25Mb2FkKGxvYWRJZCk7IC8vIG5lZWQgdG8gZG8gd2hhdCB3ZSB3b3VsZCBoYXZlIGRvbmUgd2hlbiB0aGUgbmF2aWdhdGlvbiBsb2FkIGNvbXBsZXRlZFxuXG4gICAgaWYgKHllZXRlZE5hdmlnYXRpb24pIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHRyYW5zaXRpb25cbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGludmFyaWFudCh0cmFuc2l0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiwgXCJFeHBlY3RlZCBsb2FkaW5nIHRyYW5zaXRpb25cIik7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBsb2NhdGlvbjogdHJhbnNpdGlvbi5sb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogc3RhdGUubmV4dE1hdGNoZXMsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5SWQsXG4gICAgICAgIGNhdGNoOiBjYXRjaFZhbCxcbiAgICAgICAgY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgICBsb2FkZXJEYXRhOiBtYWtlTG9hZGVyRGF0YShzdGF0ZSwgcmVzdWx0cywgbWF0Y2hlc1RvTG9hZCksXG4gICAgICAgIGFjdGlvbkRhdGE6IHRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiA/IHN0YXRlLmFjdGlvbkRhdGEgOiB1bmRlZmluZWQsXG4gICAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9KTtcbiAgICB9IC8vIG90aGVyd2lzZSBqdXN0IHVwZGF0ZSB0aGUgaW5mbyBmb3IgdGhlIGRhdGFcbiAgICBlbHNlIHtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGVycm9yQm91bmRhcnlJZCxcbiAgICAgICAgbG9hZGVyRGF0YTogbWFrZUxvYWRlckRhdGEoc3RhdGUsIHJlc3VsdHMsIG1hdGNoZXNUb0xvYWQpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB5ZWV0U3RhbGVOYXZpZ2F0aW9uTG9hZChsYW5kZWRJZCkge1xuICAgIGxldCBpc0xvYWRpbmdOYXZpZ2F0aW9uID0gc3RhdGUudHJhbnNpdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCI7XG5cbiAgICBpZiAoaXNMb2FkaW5nTmF2aWdhdGlvbiAmJiBuYXZpZ2F0aW9uTG9hZElkIDwgbGFuZGVkSWQpIHtcbiAgICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0ZldGNoZXJzRG9uZShrZXlzKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgIGxldCBmZXRjaGVyID0gZ2V0RmV0Y2hlcihrZXkpO1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgICBkYXRhOiBmZXRjaGVyLmRhdGEsXG4gICAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG5cbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG5cbiAgICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICAgICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWVldGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geWVldGVkS2V5cy5sZW5ndGggPyB5ZWV0ZWRLZXlzIDogZmFsc2U7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJGZXRjaFN1Ym1pc3Npb24oaHJlZiwga2V5LCBzdWJtaXNzaW9uLCBtYXRjaCkge1xuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZGF0YTogKGN1cnJlbnRGZXRjaGVyID09PSBudWxsIHx8IGN1cnJlbnRGZXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmV0Y2hlci5kYXRhKSB8fCB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGNvbnRyb2xsZXIpO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyKG1hdGNoLCBjcmVhdGVVcmwoaHJlZiksIGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZXN1bHQudmFsdWUubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGRvbmVGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgdHlwZTogXCJkb25lXCIsXG4gICAgICBkYXRhOiByZXN1bHQudmFsdWUsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJGZXRjaChocmVmLCBrZXksIG1hdGNoKSB7XG4gICAgbGV0IGN1cnJlbnRGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbExvYWRcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGRhdGE6IChjdXJyZW50RmV0Y2hlciA9PT0gbnVsbCB8fCBjdXJyZW50RmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZldGNoZXIuZGF0YSkgfHwgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBjb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlcihtYXRjaCwgY3JlYXRlVXJsKGhyZWYpLCBjb250cm9sbGVyLnNpZ25hbCk7XG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHJldHVybjtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpIHtcbiAgICBpZiAoaXNDYXRjaFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgY2F0Y2hCb3VuZGFyeUlkID0gZmluZE5lYXJlc3RDYXRjaEJvdW5kYXJ5KG1hdGNoLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGNhdGNoOiB7XG4gICAgICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLmRhdGEsXG4gICAgICAgICAgc3RhdHVzOiByZXN1bHQudmFsdWUuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3VsdC52YWx1ZS5zdGF0dXNUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkge1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvckJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBlcnJvcjogcmVzdWx0LnZhbHVlLFxuICAgICAgICBlcnJvckJvdW5kYXJ5SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTm90Rm91bmROYXZpZ2F0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbExvYWRcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7IC8vIEZvcmNlIGFzeW5jIHNvIFVJIGNvZGUgZG9lc24ndCBoYXZlIHRvIHNwZWNpYWwgbm90IGZvdW5kIHJvdXRlIGNoYW5nZXMgbm90XG4gICAgLy8gc2tpcHBpbmcgdGhlIHBlbmRpbmcgc3RhdGUgKGxpa2Ugc2Nyb2xsIHJlc3RvcmF0aW9uIGdldHMgcmVhbGx5XG4gICAgLy8gY29tcGxpY2F0ZWQgd2l0aG91dCB0aGUgcGVuZGluZyBzdGF0ZSwgbWF5YmUgd2UgY2FuIGZpZ3VyZSBzb21ldGhpbmcgZWxzZVxuICAgIC8vIG91dCBsYXRlciwgYnV0IHRoaXMgd29ya3MgZ3JlYXQuKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbGV0IGNhdGNoQm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShtYXRjaGVzWzBdLCBtYXRjaGVzKTtcbiAgICB1cGRhdGUoe1xuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgY2F0Y2g6IHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCJcbiAgICAgIH0sXG4gICAgICBjYXRjaEJvdW5kYXJ5SWQsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvblN1Ym1pc3Npb25OYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblN1Ym1pc3Npb25cIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cbiAgICBpZiAoIWlzSW5kZXhSZXF1ZXN0QWN0aW9uKHN1Ym1pc3Npb24uYWN0aW9uKSAmJiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaWQuZW5kc1dpdGgoXCIvaW5kZXhcIikpIHtcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICBsZXQgbGVhZk1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxBY3Rpb24oc3VibWlzc2lvbiwgbGVhZk1hdGNoLCBjb250cm9sbGVyLnNpZ25hbCk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImFjdGlvblwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQ2F0Y2hSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IFtjYXRjaFZhbCwgY2F0Y2hCb3VuZGFyeUlkXSA9IGF3YWl0IGZpbmRDYXRjaEFuZEJvdW5kYXJ5SWQoW3Jlc3VsdF0sIG1hdGNoZXMsIHJlc3VsdCk7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICAgIGNhdGNoOiBjYXRjaFZhbCxcbiAgICAgICAgY2F0Y2hCb3VuZGFyeUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbG9hZFRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImFjdGlvblJlbG9hZFwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbjogbG9hZFRyYW5zaXRpb24sXG4gICAgICBhY3Rpb25EYXRhOiB7XG4gICAgICAgIFtsZWFmTWF0Y2gucm91dGUuaWRdOiByZXN1bHQudmFsdWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxlYWZNYXRjaC5yb3V0ZS5pZCwgcmVzdWx0KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlclN1Ym1pc3Npb25OYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25cIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcIm5vcm1hbExvYWRcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7IC8vIEZvcmNlIGFzeW5jIHNvIFVJIGNvZGUgZG9lc24ndCBoYXZlIHRvIHNwZWNpYWwgY2FzZSBoYXNoIGNoYW5nZXMgbm90XG4gICAgLy8gc2tpcHBpbmcgdGhlIHBlbmRpbmcgc3RhdGUgKGxpa2Ugc2Nyb2xsIHJlc3RvcmF0aW9uIGdldHMgcmVhbGx5XG4gICAgLy8gY29tcGxpY2F0ZWQgd2l0aG91dCB0aGUgcGVuZGluZyBzdGF0ZSwgbWF5YmUgd2UgY2FuIGZpZ3VyZSBzb21ldGhpbmcgZWxzZVxuICAgIC8vIG91dCBsYXRlciwgYnV0IHRoaXMgd29ya3MgZ3JlYXQuKVxuXG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdXBkYXRlKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTlxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJSZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxSZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyU3VibWlzc2lvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgaW52YXJpYW50KHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJsb2FkZXJTdWJtaXNzaW9uXCIsIGBVbmV4cGVjdGVkIHRyYW5zaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoc3RhdGUudHJhbnNpdGlvbil9YCk7XG4gICAgbGV0IHtcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9ID0gc3RhdGUudHJhbnNpdGlvbjtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibG9hZGVyU3VibWlzc2lvblJlZGlyZWN0XCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwiZmV0Y2hBY3Rpb25SZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBpbnZhcmlhbnQoc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblN1Ym1pc3Npb25cIiB8fCAvLyBsb2FkZXIgcmVkaXJlY3RlZCBkdXJpbmcgYWN0aW9uIHJlbG9hZFxuICAgIHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiwgYFVuZXhwZWN0ZWQgdHJhbnNpdGlvbjogJHtKU09OLnN0cmluZ2lmeShzdGF0ZS50cmFuc2l0aW9uKX1gKTtcbiAgICBsZXQge1xuICAgICAgc3VibWlzc2lvblxuICAgIH0gPSBzdGF0ZS50cmFuc2l0aW9uO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkobG9jYXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlSHJlZihzdGF0ZS5sb2NhdGlvbikgPT09IGNyZWF0ZUhyZWYobG9jYXRpb24pICYmIHN0YXRlLmxvY2F0aW9uLmhhc2ggIT09IGxvY2F0aW9uLmhhc2g7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24sIHN1Ym1pc3Npb25Sb3V0ZUlkLCBhY3Rpb25SZXN1bHQpIHtcbiAgICBsZXQgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCA9IGFjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkgPyBhY3Rpb25SZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQgPSBhY3Rpb25SZXN1bHQgJiYgaXNDYXRjaFJlc3VsdChhY3Rpb25SZXN1bHQpID8gYWN0aW9uUmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgbmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbExvYWRlcnMoc3RhdGUsIGNyZWF0ZVVybChjcmVhdGVIcmVmKGxvY2F0aW9uKSksIG1hdGNoZXMsIGNvbnRyb2xsZXIuc2lnbmFsLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0LCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcblxuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgLy8gbG9hZGVyIHJlZGlyZWN0ZWQgZHVyaW5nIGFuIGFjdGlvbiByZWxvYWQsIHRyZWF0IGl0IGxpa2UgYW5cbiAgICAgIC8vIGFjdGlvblJlZGlyZWN0IGluc3RlYWQgc28gdGhhdCBhbGwgdGhlIGxvYWRlcnMgZ2V0IGNhbGxlZCBhZ2FpbiBhbmQgdGhlXG4gICAgICAvLyBzdWJtaXNzaW9uIHN0aWNrcyBhcm91bmQgZm9yIG9wdGltaXN0aWMvcGVuZGluZyBVSS5cbiAgICAgIGlmIChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIpIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcImFjdGlvblwiXG4gICAgICAgIH07XG4gICAgICAgIGluaXQub25SZWRpcmVjdChyZWRpcmVjdC5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJsb2FkZXJTdWJtaXNzaW9uXCIpIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25cIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiBcImxvYWRlclwiXG4gICAgICAgIH07XG4gICAgICAgIGluaXQub25SZWRpcmVjdChyZWRpcmVjdC5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgW2Vycm9yLCBlcnJvckJvdW5kYXJ5SWRdID0gZmluZEVycm9yQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0KTtcbiAgICBsZXQgW2NhdGNoVmFsLCBjYXRjaEJvdW5kYXJ5SWRdID0gYXdhaXQgZmluZENhdGNoQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0KTtcbiAgICBsZXQgYWJvcnRlZElkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKG5hdmlnYXRpb25Mb2FkSWQpO1xuXG4gICAgaWYgKGFib3J0ZWRJZHMpIHtcbiAgICAgIG1hcmtGZXRjaGVyc0RvbmUoYWJvcnRlZElkcyk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgY2F0Y2g6IGNhdGNoVmFsLFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgbG9hZGVyRGF0YTogbWFrZUxvYWRlckRhdGEoc3RhdGUsIHJlc3VsdHMsIG1hdGNoZXMpLFxuICAgICAgYWN0aW9uRGF0YTogc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiID8gc3RhdGUuYWN0aW9uRGF0YSA6IHVuZGVmaW5lZCxcbiAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgIGZldGNoZXJzOiBhYm9ydGVkSWRzID8gbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgOiBzdGF0ZS5mZXRjaGVyc1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCkge1xuICAgIHZhciBfcGVuZGluZ05hdmlnYXRpb25Db247XG5cbiAgICAoX3BlbmRpbmdOYXZpZ2F0aW9uQ29uID0gcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSA9PT0gbnVsbCB8fCBfcGVuZGluZ05hdmlnYXRpb25Db24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZW5kaW5nTmF2aWdhdGlvbkNvbi5hYm9ydCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRGZXRjaGVyKGtleSkge1xuICAgIGxldCBjb250cm9sbGVyID0gZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KTtcbiAgICBpbnZhcmlhbnQoY29udHJvbGxlciwgYEV4cGVjdGVkIGZldGNoIGNvbnRyb2xsZXI6ICR7a2V5fWApO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZW5kLFxuICAgIGdldFN0YXRlLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcixcbiAgICBkaXNwb3NlLFxuXG4gICAgZ2V0IF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnMoKSB7XG4gICAgICByZXR1cm4gZmV0Y2hDb250cm9sbGVycztcbiAgICB9XG5cbiAgfTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gaXNJbmRleFJlcXVlc3RBY3Rpb24oYWN0aW9uKSB7XG4gIGxldCBpbmRleFJlcXVlc3QgPSBmYWxzZTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYWN0aW9uLnNwbGl0KFwiP1wiLCAyKVsxXSB8fCBcIlwiKTtcblxuICBmb3IgKGxldCBwYXJhbSBvZiBzZWFyY2hQYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIikpIHtcbiAgICBpZiAoIXBhcmFtKSB7XG4gICAgICBpbmRleFJlcXVlc3QgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleFJlcXVlc3Q7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzKHN0YXRlLCB1cmwsIG1hdGNoZXMsIHNpZ25hbCwgYWN0aW9uRXJyb3JSZXN1bHQsIGFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgZmV0Y2hlcikge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IGZpbHRlck1hdGNoZXNUb0xvYWQoc3RhdGUsIHVybCwgbWF0Y2hlcywgYWN0aW9uRXJyb3JSZXN1bHQsIGFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgZmV0Y2hlcik7XG4gIHJldHVybiBQcm9taXNlLmFsbChtYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBjYWxsTG9hZGVyKG1hdGNoLCB1cmwsIHNpZ25hbCkpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcihtYXRjaCwgdXJsLCBzaWduYWwpIHtcbiAgaW52YXJpYW50KG1hdGNoLnJvdXRlLmxvYWRlciwgYEV4cGVjdGVkIGxvYWRlciBmb3IgJHttYXRjaC5yb3V0ZS5pZH1gKTtcblxuICB0cnkge1xuICAgIGxldCB7XG4gICAgICBwYXJhbXNcbiAgICB9ID0gbWF0Y2g7XG4gICAgbGV0IHZhbHVlID0gYXdhaXQgbWF0Y2gucm91dGUubG9hZGVyKHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHVybCxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZTogZXJyb3JcbiAgICB9O1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxBY3Rpb24oc3VibWlzc2lvbiwgbWF0Y2gsIHNpZ25hbCkge1xuICBpZiAoIW1hdGNoLnJvdXRlLmFjdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgUm91dGUgXCIke21hdGNoLnJvdXRlLmlkfVwiIGRvZXMgbm90IGhhdmUgYW4gYWN0aW9uLCBidXQgeW91IGFyZSB0cnlpbmcgYCArIGB0byBzdWJtaXQgdG8gaXQuIFRvIGZpeCB0aGlzLCBwbGVhc2UgYWRkIGFuIFxcYGFjdGlvblxcYCBmdW5jdGlvbiB0byB0aGUgcm91dGVgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbGV0IHZhbHVlID0gYXdhaXQgbWF0Y2gucm91dGUuYWN0aW9uKHtcbiAgICAgIHVybDogY3JlYXRlVXJsKHN1Ym1pc3Npb24uYWN0aW9uKSxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZTogZXJyb3JcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlck1hdGNoZXNUb0xvYWQoc3RhdGUsIHVybCwgbWF0Y2hlcywgYWN0aW9uRXJyb3JSZXN1bHQsIGFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgZmV0Y2hlcikge1xuICAvLyBGaWx0ZXIgb3V0IGFsbCByb3V0ZXMgYmVsb3cgdGhlIHByb2JsZW1hdGljIHJvdXRlIGFzIHRoZXkgYXJlbid0IGdvaW5nXG4gIC8vIHRvIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbS5cbiAgaWYgKHN1Ym1pc3Npb25Sb3V0ZUlkICYmIChhY3Rpb25DYXRjaFJlc3VsdCB8fCBhY3Rpb25FcnJvclJlc3VsdCkpIHtcbiAgICBsZXQgZm91bmRQcm9ibGVtYXRpY1JvdXRlID0gZmFsc2U7XG4gICAgbWF0Y2hlcyA9IG1hdGNoZXMuZmlsdGVyKG1hdGNoID0+IHtcbiAgICAgIGlmIChmb3VuZFByb2JsZW1hdGljUm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IHN1Ym1pc3Npb25Sb3V0ZUlkKSB7XG4gICAgICAgIGZvdW5kUHJvYmxlbWF0aWNSb3V0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBsZXQgaXNOZXcgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgLy8gW2FdIC0+IFthLCBiXVxuICAgIGlmICghc3RhdGUubWF0Y2hlc1tpbmRleF0pIHJldHVybiB0cnVlOyAvLyBbYSwgYl0gLT4gW2EsIGNdXG5cbiAgICByZXR1cm4gbWF0Y2gucm91dGUuaWQgIT09IHN0YXRlLm1hdGNoZXNbaW5kZXhdLnJvdXRlLmlkO1xuICB9O1xuXG4gIGxldCBtYXRjaFBhdGhDaGFuZ2VkID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIHZhciBfc3RhdGUkbWF0Y2hlcyRpbmRleCQ7XG5cbiAgICByZXR1cm4gKC8vIHBhcmFtIGNoYW5nZSwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgICBzdGF0ZS5tYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgKChfc3RhdGUkbWF0Y2hlcyRpbmRleCQgPSBzdGF0ZS5tYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoKSA9PT0gbnVsbCB8fCBfc3RhdGUkbWF0Y2hlcyRpbmRleCQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRtYXRjaGVzJGluZGV4JC5lbmRzV2l0aChcIipcIikpICYmIHN0YXRlLm1hdGNoZXNbaW5kZXhdLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl1cbiAgICApO1xuICB9O1xuXG4gIGxldCBmaWx0ZXJCeVJvdXRlUHJvcHMgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQpIHtcbiAgICAgIGxldCBwcmV2VXJsID0gY3JlYXRlVXJsKGNyZWF0ZUhyZWYoc3RhdGUubG9jYXRpb24pKTtcbiAgICAgIHJldHVybiBtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQoe1xuICAgICAgICBwcmV2VXJsLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBsZXQgaXNJblJvb3RDYXRjaEJvdW5kYXJ5ID0gc3RhdGUubWF0Y2hlcy5sZW5ndGggPT09IDE7XG5cbiAgaWYgKGlzSW5Sb290Q2F0Y2hCb3VuZGFyeSkge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiAhIW1hdGNoLnJvdXRlLmxvYWRlcik7XG4gIH1cblxuICBpZiAoKGZldGNoZXIgPT09IG51bGwgfHwgZmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hlci50eXBlKSA9PT0gXCJhY3Rpb25SZWxvYWRcIikge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihmaWx0ZXJCeVJvdXRlUHJvcHMpO1xuICB9IGVsc2UgaWYgKCAvLyBtdXRhdGlvbiwgcmVsb2FkIGZvciBmcmVzaCBkYXRhXG4gIHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiB8fCBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVkaXJlY3RcIiB8fCAvLyBjbGlja2VkIHRoZSBzYW1lIGxpbmssIHJlc3VibWl0dGVkIGEgR0VUIGZvcm1cbiAgY3JlYXRlSHJlZih1cmwpID09PSBjcmVhdGVIcmVmKHN0YXRlLmxvY2F0aW9uKSB8fCAvLyBzZWFyY2ggYWZmZWN0cyBhbGwgbG9hZGVyc1xuICB1cmwuc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCkgIT09IHN0YXRlLmxvY2F0aW9uLnNlYXJjaCkge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihmaWx0ZXJCeVJvdXRlUHJvcHMpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgsIGFycikgPT4ge1xuICAgIC8vIGRvbid0IGxvYWQgZXJyb3JlZCBhY3Rpb24gcm91dGVcbiAgICBpZiAoKGFjdGlvbkVycm9yUmVzdWx0IHx8IGFjdGlvbkNhdGNoUmVzdWx0KSAmJiBhcnIubGVuZ3RoIC0gMSA9PT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2gucm91dGUubG9hZGVyICYmIChpc05ldyhtYXRjaCwgaW5kZXgpIHx8IG1hdGNoUGF0aENoYW5nZWQobWF0Y2gsIGluZGV4KSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgVHJhbnNpdGlvblJlZGlyZWN0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gIHJldHVybiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbn1cblxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHMpIHtcbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIG1hdGNoZXMsIGFjdGlvbkNhdGNoUmVzdWx0KSB7XG4gIGxldCBsb2FkZXJDYXRjaFJlc3VsdDtcblxuICBmb3IgKGxldCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgIGlmIChpc0NhdGNoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxvYWRlckNhdGNoUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgbGV0IGV4dHJhY3RDYXRjaERhdGEgPSBhc3luYyByZXMgPT4gKHtcbiAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c1RleHQsXG4gICAgZGF0YTogcmVzLmRhdGFcbiAgfSk7IC8vIFdlaXJkIGNhc2Ugd2hlcmUgYWN0aW9uIHRocmV3LCBhbmQgdGhlbiBhIHBhcmVudCBsb2FkZXIgQUxTTyB0aHJldywgd2VcbiAgLy8gdXNlIHRoZSBhY3Rpb24gY2F0Y2ggYnV0IHRoZSBsb2FkZXIncyBuZWFyZXN0IGJvdW5kYXJ5IChjYXVzZSB3ZSBjYW4ndFxuICAvLyByZW5kZXIgZG93biB0byB0aGUgYm91bmRhcnkgdGhlIGFjdGlvbiB3b3VsZCBwcmVmZXIpXG5cblxuICBpZiAoYWN0aW9uQ2F0Y2hSZXN1bHQgJiYgbG9hZGVyQ2F0Y2hSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShsb2FkZXJDYXRjaFJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthd2FpdCBleHRyYWN0Q2F0Y2hEYXRhKGFjdGlvbkNhdGNoUmVzdWx0LnZhbHVlKSwgYm91bmRhcnlJZF07XG4gIH1cblxuICBpZiAobG9hZGVyQ2F0Y2hSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShsb2FkZXJDYXRjaFJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthd2FpdCBleHRyYWN0Q2F0Y2hEYXRhKGxvYWRlckNhdGNoUmVzdWx0LnZhbHVlKSwgYm91bmRhcnlJZF07XG4gIH1cblxuICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cblxuZnVuY3Rpb24gZmluZEVycm9yQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBhY3Rpb25FcnJvclJlc3VsdCkge1xuICBsZXQgbG9hZGVyRXJyb3JSZXN1bHQ7XG5cbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsb2FkZXJFcnJvclJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBXZWlyZCBjYXNlIHdoZXJlIGFjdGlvbiBlcnJvcmVkLCBhbmQgdGhlbiBhIHBhcmVudCBsb2FkZXIgQUxTTyBlcnJvcmVkLCB3ZVxuICAvLyB1c2UgdGhlIGFjdGlvbiBlcnJvciBidXQgdGhlIGxvYWRlcidzIG5lYXJlc3QgYm91bmRhcnkgKGNhdXNlIHdlIGNhbid0XG4gIC8vIHJlbmRlciBkb3duIHRvIHRoZSBib3VuZGFyeSB0aGUgYWN0aW9uIHdvdWxkIHByZWZlcilcblxuXG4gIGlmIChhY3Rpb25FcnJvclJlc3VsdCAmJiBsb2FkZXJFcnJvclJlc3VsdCkge1xuICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShsb2FkZXJFcnJvclJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFthY3Rpb25FcnJvclJlc3VsdC52YWx1ZSwgYm91bmRhcnlJZF07XG4gIH1cblxuICBpZiAoYWN0aW9uRXJyb3JSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoYWN0aW9uRXJyb3JSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYWN0aW9uRXJyb3JSZXN1bHQudmFsdWUsIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGxvYWRlckVycm9yUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGxvYWRlckVycm9yUmVzdWx0Lm1hdGNoLCBtYXRjaGVzKTtcbiAgICByZXR1cm4gW2xvYWRlckVycm9yUmVzdWx0LnZhbHVlLCBib3VuZGFyeUlkXTtcbiAgfVxuXG4gIHJldHVybiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xufVxuXG5mdW5jdGlvbiBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobWF0Y2hXaXRoRXJyb3IsIG1hdGNoZXMpIHtcbiAgbGV0IG5lYXJlc3RCb3VuZGFyeUlkID0gbnVsbDtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLkNhdGNoQm91bmRhcnkpIHtcbiAgICAgIG5lYXJlc3RCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfSAvLyBvbmx5IHNlYXJjaCBwYXJlbnRzIChzdG9wIGF0IHRocm93aW5nIG1hdGNoKVxuXG5cbiAgICBpZiAobWF0Y2ggPT09IG1hdGNoV2l0aEVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEJvdW5kYXJ5SWQ7XG59XG5cbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hXaXRoRXJyb3IsIG1hdGNoZXMpIHtcbiAgbGV0IG5lYXJlc3RCb3VuZGFyeUlkID0gbnVsbDtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgaWYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpIHtcbiAgICAgIG5lYXJlc3RCb3VuZGFyeUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfSAvLyBvbmx5IHNlYXJjaCBwYXJlbnRzIChzdG9wIGF0IHRocm93aW5nIG1hdGNoKVxuXG5cbiAgICBpZiAobWF0Y2ggPT09IG1hdGNoV2l0aEVycm9yKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVhcmVzdEJvdW5kYXJ5SWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzKSB7XG4gIGxldCBuZXdEYXRhID0ge307XG5cbiAgZm9yIChsZXQge1xuICAgIG1hdGNoLFxuICAgIHZhbHVlXG4gIH0gb2YgcmVzdWx0cykge1xuICAgIG5ld0RhdGFbbWF0Y2gucm91dGUuaWRdID0gdmFsdWU7XG4gIH1cblxuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IHtcbiAgICByb3V0ZVxuICB9IG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgdmFsdWUgPSBuZXdEYXRhW3JvdXRlLmlkXSAhPT0gdW5kZWZpbmVkID8gbmV3RGF0YVtyb3V0ZS5pZF0gOiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlLmlkXTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2FkZXJEYXRhW3JvdXRlLmlkXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2FkZXJEYXRhO1xufVxuXG5mdW5jdGlvbiBpc0NhdGNoUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgQ2F0Y2hWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvclJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcmwoaHJlZikge1xuICByZXR1cm4gbmV3IFVSTChocmVmLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbn1cblxuZXhwb3J0IHsgQ2F0Y2hWYWx1ZSwgSURMRV9GRVRDSEVSLCBJRExFX1RSQU5TSVRJT04sIFRyYW5zaXRpb25SZWRpcmVjdCwgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IG1hdGNoUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbi8vIFRPRE86IGV4cG9ydC9pbXBvcnQgZnJvbSByZWFjdC1yb3V0ZXItZG9tXG5mdW5jdGlvbiBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbik7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBtYXRjaENsaWVudFJvdXRlcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4xLjBcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTG9jYXRpb24gfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCB7IHVzZUJlZm9yZVVubG9hZCwgdXNlVHJhbnNpdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5cbmxldCBTVE9SQUdFX0tFWSA9IFwicG9zaXRpb25zXCI7XG5sZXQgcG9zaXRpb25zID0ge307XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcblxuICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgIHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKCk7IC8vIHdhaXQgZm9yIHRoZSBicm93c2VyIHRvIHJlc3RvcmUgaXQgb24gaXRzIG93blxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICB9LCBbXSk7IC8vIGxldCB0aGUgYnJvd3NlciByZXN0b3JlIG9uIGl0J3Mgb3duIGZvciByZWZyZXNoXG5cbiAgdXNlQmVmb3JlVW5sb2FkKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICB9LCBbXSkpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICBfX2h0bWw6IGBcbiAgICAgICAgICBsZXQgU1RPUkFHRV9LRVkgPSAke0pTT04uc3RyaW5naWZ5KFNUT1JBR0VfS0VZKX07XG4gICAgICAgICAgaWYgKCF3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCAhd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5KSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKDIpIH0sIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSkgPz8gJ3t9JylcbiAgICAgICAgICAgIGxldCBzdG9yZWRZID0gcG9zaXRpb25zW3dpbmRvdy5oaXN0b3J5LnN0YXRlLmtleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzdG9yZWRZKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZKVxuICAgICAgICAgIH1cbiAgICAgICAgYFxuICAgIH1cbiAgfSk7XG59XG5sZXQgaHlkcmF0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB0cmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbigpO1xuICBsZXQgd2FzU3VibWlzc2lvblJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24uc3VibWlzc2lvbikge1xuICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24ubG9jYXRpb24pIHtcbiAgICAgIHBvc2l0aW9uc1tsb2NhdGlvbi5rZXldID0gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuICB9LCBbdHJhbnNpdGlvbiwgbG9jYXRpb25dKTtcbiAgdXNlQmVmb3JlVW5sb2FkKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShwb3NpdGlvbnMpKTtcbiAgfSwgW10pKTtcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIG9uIGh5ZHJhdGlvbiwgdGhlIGNvbXBvbmVudCBhbHJlYWR5IGRpZCB0aGlzIHdpdGggYW5cbiAgICAgIC8vIGlubGluZSBzY3JpcHQuXG4gICAgICBpZiAoIWh5ZHJhdGVkKSB7XG4gICAgICAgIGh5ZHJhdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgeSA9IHBvc2l0aW9uc1tsb2NhdGlvbi5rZXldOyAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcblxuICAgICAgaWYgKHkpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcblxuXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGxvY2F0aW9uLmhhc2gpO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIGRvbid0IGRvIGFueXRoaW5nIG9uIHN1Ym1pc3Npb25zXG5cblxuICAgICAgaWYgKHdhc1N1Ym1pc3Npb25SZWYuY3VycmVudCA9PT0gdHJ1ZSkge1xuICAgICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBvdGhlcndpc2UgZ28gdG8gdGhlIHRvcCBvbiBuZXcgbG9jYXRpb25zXG5cblxuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgIH0sIFtsb2NhdGlvbl0pO1xuICB9XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvbi5zdWJtaXNzaW9uKSB7XG4gICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3RyYW5zaXRpb25dKTtcbn1cblxuZXhwb3J0IHsgU2Nyb2xsUmVzdG9yYXRpb24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMS4wXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IEFjdGlvbiwgY3JlYXRlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVtaXhFbnRyeSB9IGZyb20gJy4vY29tcG9uZW50cy5qcyc7XG5cbi8qKlxuICogVGhlIGVudHJ5IHBvaW50IGZvciBhIFJlbWl4IGFwcCB3aGVuIGl0IGlzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgKGluXG4gKiBgYXBwL2VudHJ5LnNlcnZlci5qc2ApLiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBIVE1MIGluIHRoZVxuICogcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiBSZW1peFNlcnZlcih7XG4gIGNvbnRleHQsXG4gIHVybFxufSkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgfVxuXG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lLFxuICAgIHNlYXJjaDogdXJsLnNlYXJjaCxcbiAgICBoYXNoOiBcIlwiLFxuICAgIHN0YXRlOiBudWxsLFxuICAgIGtleTogXCJkZWZhdWx0XCJcbiAgfTtcbiAgbGV0IHN0YXRpY05hdmlnYXRvciA9IHtcbiAgICBjcmVhdGVIcmVmKHRvKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgICB9LFxuXG4gICAgcHVzaCh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IucHVzaCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuXG4gICAgcmVwbGFjZSh0bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IucmVwbGFjZSgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke0pTT04uc3RyaW5naWZ5KHRvKX0sIHsgcmVwbGFjZTogdHJ1ZSB9KVxcYCBzb21ld2hlcmUgYCArIGBpbiB5b3VyIGFwcC5gKTtcbiAgICB9LFxuXG4gICAgZ28oZGVsdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmdvKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuIFRoaXMgZXJyb3Igd2FzIHByb2JhYmx5IHRyaWdnZXJlZCB3aGVuIHlvdSBkaWQgYSBgICsgYFxcYG5hdmlnYXRlKCR7ZGVsdGF9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIGJhY2soKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5iYWNrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfSxcblxuICAgIGZvcndhcmQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5mb3J3YXJkKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfSxcblxuICAgIGJsb2NrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuYmxvY2soKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC5gKTtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbWl4RW50cnksIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGFjdGlvbjogQWN0aW9uLlBvcCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgbmF2aWdhdG9yOiBzdGF0aWNOYXZpZ2F0b3IsXG4gICAgc3RhdGljOiB0cnVlXG4gIH0pO1xufVxuXG5leHBvcnQgeyBSZW1peFNlcnZlciB9O1xuIiwgImltcG9ydCB7XG4gIExpbmtzLFxuICBMaXZlUmVsb2FkLFxuICBNZXRhLFxuICBPdXRsZXQsXG4gIFNjcmlwdHMsXG4gIFNjcm9sbFJlc3RvcmF0aW9uXG59IGZyb20gXCJyZW1peFwiO1xuaW1wb3J0IHR5cGUgeyBNZXRhRnVuY3Rpb24gfSBmcm9tIFwicmVtaXhcIjtcblxuZXhwb3J0IGNvbnN0IG1ldGE6IE1ldGFGdW5jdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIHsgdGl0bGU6IFwiTmV3IFJlbWl4IEFwcFwiIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBcHAoKSB7XG4gIHJldHVybiAoXG4gICAgPGh0bWwgbGFuZz1cImVuXCI+XG4gICAgICA8aGVhZD5cbiAgICAgICAgPG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz5cbiAgICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTFcIiAvPlxuICAgICAgICA8TWV0YSAvPlxuICAgICAgICA8TGlua3MgLz5cbiAgICAgIDwvaGVhZD5cbiAgICAgIDxib2R5PlxuICAgICAgICA8T3V0bGV0IC8+XG4gICAgICAgIDxTY3JvbGxSZXN0b3JhdGlvbiAvPlxuICAgICAgICA8U2NyaXB0cyAvPlxuICAgICAgICB7cHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiA8TGl2ZVJlbG9hZCAvPn1cbiAgICAgIDwvYm9keT5cbiAgICA8L2h0bWw+XG4gICk7XG59XG4iLCAiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSW5kZXgoKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLCBsaW5lSGVpZ2h0OiBcIjEuNFwiIH19PlxuICAgICAgPGgxPldlbGNvbWUgdG8gUmVtaXg8L2gxPlxuICAgICAgPHVsPlxuICAgICAgICA8bGk+XG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9yZW1peC5ydW4vdHV0b3JpYWxzL2Jsb2dcIlxuICAgICAgICAgICAgcmVsPVwibm9yZWZlcnJlclwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgMTVtIFF1aWNrc3RhcnQgQmxvZyBUdXRvcmlhbFxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cbiAgICAgICAgPGxpPlxuICAgICAgICAgIDxhXG4gICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vcmVtaXgucnVuL3R1dG9yaWFscy9qb2tlc1wiXG4gICAgICAgICAgICByZWw9XCJub3JlZmVycmVyXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBEZWVwIERpdmUgSm9rZXMgQXBwIFR1dG9yaWFsXG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuICAgICAgICA8bGk+XG4gICAgICAgICAgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHBzOi8vcmVtaXgucnVuL2RvY3NcIiByZWw9XCJub3JlZmVycmVyXCI+XG4gICAgICAgICAgICBSZW1peCBEb2NzXG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsICJleHBvcnQgZGVmYXVsdCB7J3ZlcnNpb24nOic5MzFhNTJiNycsJ2VudHJ5Jzp7J21vZHVsZSc6Jy9idWlsZC9lbnRyeS5jbGllbnQtWUtVWFk3UEguanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLTJMTkFDSlBXLmpzJywnL2J1aWxkL19zaGFyZWQvY2h1bmstRTdWTU9VWUwuanMnXX0sJ3JvdXRlcyc6eydyb290Jzp7J2lkJzoncm9vdCcsJ3BhcmVudElkJzp1bmRlZmluZWQsJ3BhdGgnOicnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb290LTJHUUlPWkRILmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvaW5kZXgnOnsnaWQnOidyb3V0ZXMvaW5kZXgnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzp1bmRlZmluZWQsJ2luZGV4Jzp0cnVlLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvaW5kZXgtWUxJWEFWV1QuanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6ZmFsc2UsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX19LCd1cmwnOicvYnVpbGQvbWFuaWZlc3QtOTMxQTUyQjcuanMnfTsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUVBLFFBQUksd0JBQXdCLE9BQU87QUFDbkMsUUFBSSxrQkFBaUIsT0FBTyxVQUFVO0FBQ3RDLFFBQUksbUJBQW1CLE9BQU8sVUFBVTtBQUV4QyxzQkFBa0IsS0FBSztBQUN0QixVQUFJLFFBQVEsUUFBUSxRQUFRLFFBQVc7QUFDdEMsY0FBTSxJQUFJLFVBQVU7QUFBQTtBQUdyQixhQUFPLE9BQU87QUFBQTtBQUdmLCtCQUEyQjtBQUMxQixVQUFJO0FBQ0gsWUFBSSxDQUFDLE9BQU8sUUFBUTtBQUNuQixpQkFBTztBQUFBO0FBTVIsWUFBSSxRQUFRLElBQUksT0FBTztBQUN2QixjQUFNLEtBQUs7QUFDWCxZQUFJLE9BQU8sb0JBQW9CLE9BQU8sT0FBTyxLQUFLO0FBQ2pELGlCQUFPO0FB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VUFDUixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixXQUFXO0FBQUEsVUFDWCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixhQUFhO0FBQUEsVUFDYixjQUFjO0FBQUEsVUFDZCxLQUFLO0FBQUEsVUFDTCxXQUFXO0FBQUEsVUFDWCxPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixRQUFRO0FBQUEsVUFDUixLQUFLO0FBQUEsVUFDTCxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxhQUFhO0FBQUEsVUFDYixhQUFhO0FBQUEsVUFDYixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixVQUFVO0FBQUEsVUFDVixnQkFBZ0I7QUFBQSxVQUNoQixLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixZQUFZO0FBQUEsVUFDWixLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxRQUFRO0FB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ZCxpQkFBaUI7QUFBQSxVQUNqQixZQUFZO0FBQUEsVUFDWixnQkFBZ0I7QUFBQSxVQUNoQixjQUFjO0FBQUEsVUFDZCxhQUFhO0FBQUEsVUFDYixnQkFBZ0I7QUFBQSxVQUNoQixRQUFRO0FBQUEsVUFDUixjQUFjO0FBQUEsVUFDZCxpQkFBaUI7QUFBQSxVQUNqQixTQUFTO0FBQUEsVUFDVCxVQUFVO0FBQUEsVUFDVixjQUFjO0FBQUEsVUFDZCxhQUFhO0FBQUEsVUFDYixpQkFBaUI7QUFBQSxVQUNqQixhQUFhO0FBQUEsVUFDYixpQkFBaUI7QUFBQSxVQUNqQixVQUFVO0FBQUEsVUFDVixhQUFhO0FBQUEsVUFDYixjQUFjO0FBQUEsVUFDZCxpQkFBaUI7QUFBQSxVQUNqQixTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixZQUFZO0FBQUEsVUFDWixlQUFlO0FBQUEsVUFDZixrQkFBa0I7QUFBQSxVQUNsQixPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixhQUFhO0FBQUEsVUFDYixnQkFBZ0I7QUFBQSxVQUNoQixhQUFhO0FBQUEsVUFDYixnQkFBZ0I7QUFBQSxVQUNoQixJQUFJO0FBQUEsVUFDSixJQUFJO0FBQUEsVUFDSixHQUFHO0FBQUEsVUFDSCxrQkFBa0I7QUFBQSxVQUNsQixTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixjQUFjO0FBQUEsVUFDZCxpQkFBaUI7QUFBQSxVQUNqQixjQUFjO0FBQUEsVUFDZCxpQkFBaUI7QUFBQSxVQUNqQixXQUFXO0FBQUEsVUFDWCxjQUFjO0FBQUEsVUFDZCxXQUFXO0FBQUEsVUFDWCxjQUFjO0FBQUEsVUFDZCxXQUFXO0FBQUEsVUFDWCxjQUFjO0FBQUEsVUFDZCxZQUFZO0FBQUEsVUFDWixlQUFlO0FBQUEsVUFDZixXQUFXO0FBQUEsVUFDWCxjQUFjO0FBQUEsVUFDZCxTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixPQUFPO0FBQUEsVUFDUCxhQUFhO0FBQUEsVUFDYixZQUFZ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
